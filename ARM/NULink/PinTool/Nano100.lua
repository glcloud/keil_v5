REG=
{
GCR_PDID=1342177280,
GCR_RST_SRC=1342177284,
GCR_IPRST_CTL1=1342177288,
GCR_IPRST_CTL2=1342177292,
GCR_TEMPCTL=1342177312,
GCR_PA_L_MFP=1342177328,
GCR_PA_H_MFP=1342177332,
GCR_PB_L_MFP=1342177336,
GCR_PB_H_MFP=1342177340,
GCR_PC_L_MFP=1342177344,
GCR_PC_H_MFP=1342177348,
GCR_PD_L_MFP=1342177352,
GCR_PD_H_MFP=1342177356,
GCR_PE_L_MFP=1342177360,
GCR_PE_H_MFP=1342177364,
GCR_PF_L_MFP=1342177368,
GCR_PORCTL=1342177376,
GCR_BODCTL=1342177380,
GCR_BODSTS=1342177384,
GCR_VREFCTL=1342177388,
GCR_IRCTRIMCTL=1342177408,
GCR_IRCTRIMIEN=1342177412,
GCR_IRCTRIMINT=1342177416,
GCR_REGLOCKADDR=1342177536,
CLK_PWRCTL=1342177792,
CLK_AHBCLK=1342177796,
CLK_APBCLK=1342177800,
CLK_CLKSTATUS=1342177804,
CLK_CLKSEL0=1342177808,
CLK_CLKSEL1=1342177812,
CLK_CLKSEL2=1342177816,
CLK_CLKDIV0=1342177820,
CLK_CLKDIV1=1342177824,
CLK_PLLCTL=1342177828,
CLK_FRQDIV=1342177832,
CLK_MCLKO=1342177836,
CLK_WK_INTSTS=1342177840,
CLK_APBDIV=1342177844,
CLK_FRQDIV1=1342177848,
ADC_ADC_RESULT0=1074659328,
ADC_ADC_RESULT1=1074659332,
ADC_ADC_RESULT2=1074659336,
ADC_ADC_RESULT3=1074659340,
ADC_ADC_RESULT4=1074659344,
ADC_ADC_RESULT5=1074659348,
ADC_ADC_RESULT6=1074659352,
ADC_ADC_RESULT7=1074659356,
ADC_ADC_RESULT8=1074659360,
ADC_ADC_RESULT9=1074659364,
ADC_ADC_RESULT10=1074659368,
ADC_ADCR=1074659376,
ADC_ADCHER=1074659380,
ADC_ADCMPR0=1074659384,
ADC_ADCMPR1=1074659388,
ADC_ADSR=1074659392,
ADC_ADFCR=1074659412,
ADC_ADPDMA=1074659424,
ADC_ADCDELSEL=1074659428,
DAC_DAC0_CTL=1074397184,
DAC_DAC0_DATA=1074397188,
DAC_DAC0_STS=1074397192,
DAC_DAC1_CTL=1074397200,
DAC_DAC1_DATA=1074397204,
DAC_DAC1_STS=1074397208,
DAC_DAC01_COMCTL=1074397216,
DAC_DAC0_FPGA_DAT=1074397232,
DAC_DAC1_FPGA_DAT=1074397236,
VDMA_VDMA_CSR=1342210048,
VDMA_VDMA_SAR=1342210052,
VDMA_VDMA_DAR=1342210056,
VDMA_VDMA_BCR=1342210060,
VDMA_VDMA_CSAR=1342210068,
VDMA_VDMA_CDAR=1342210072,
VDMA_VDMA_CBCR=1342210076,
VDMA_VDMA_IER=1342210080,
VDMA_VDMA_ISR=1342210084,
VDMA_VDMA_SASOCR=1342210092,
VDMA_VDMA_DASOCR=1342210096,
VDMA_VDMA_BUF0=1342210176,
VDMA_VDMA_BUF1=1342210180,
PDMA1_PDMA_CSRx=1342210304,
PDMA1_PDMA_SARx=1342210308,
PDMA1_PDMA_DARx=1342210312,
PDMA1_PDMA_BCRx=1342210316,
PDMA1_PDMA_CSARx=1342210324,
PDMA1_PDMA_CDARx=1342210328,
PDMA1_PDMA_CBCRx=1342210332,
PDMA1_PDMA_IERx=1342210336,
PDMA1_PDMA_ISRx=1342210340,
PDMA1_PDMA_TCRx=1342210344,
PDMA1_PDMA_BUFx=1342210432,
PDMA2_PDMA_CSRx=1342210560,
PDMA2_PDMA_SARx=1342210564,
PDMA2_PDMA_DARx=1342210568,
PDMA2_PDMA_BCRx=1342210572,
PDMA2_PDMA_CSARx=1342210580,
PDMA2_PDMA_CDARx=1342210584,
PDMA2_PDMA_CBCRx=1342210588,
PDMA2_PDMA_IERx=1342210592,
PDMA2_PDMA_ISRx=1342210596,
PDMA2_PDMA_TCRx=1342210600,
PDMA2_PDMA_BUFx=1342210688,
PDMA3_PDMA_CSRx=1342210816,
PDMA3_PDMA_SARx=1342210820,
PDMA3_PDMA_DARx=1342210824,
PDMA3_PDMA_BCRx=1342210828,
PDMA3_PDMA_CSARx=1342210836,
PDMA3_PDMA_CDARx=1342210840,
PDMA3_PDMA_CBCRx=1342210844,
PDMA3_PDMA_IERx=1342210848,
PDMA3_PDMA_ISRx=1342210852,
PDMA3_PDMA_TCRx=1342210856,
PDMA3_PDMA_BUFx=1342210944,
PDMA4_PDMA_CSRx=1342211072,
PDMA4_PDMA_SARx=1342211076,
PDMA4_PDMA_DARx=1342211080,
PDMA4_PDMA_BCRx=1342211084,
PDMA4_PDMA_CSARx=1342211092,
PDMA4_PDMA_CDARx=1342211096,
PDMA4_PDMA_CBCRx=1342211100,
PDMA4_PDMA_IERx=1342211104,
PDMA4_PDMA_ISRx=1342211108,
PDMA4_PDMA_TCRx=1342211112,
PDMA4_PDMA_BUFx=1342211200,
DMA_GCR_DMA_GCRCSR=1342213888,
DMA_GCR_DMA_DSSR0=1342213892,
DMA_GCR_DMA_DSSR1=1342213896,
DMA_GCR_DMA_GCRISR=1342213900,
EBI_EBICON=1342242816,
EBI_EXTIME=1342242820,
FMC_ISPCON=1342226432,
FMC_ISPADR=1342226436,
FMC_ISPDAT=1342226440,
FMC_ISPCMD=1342226444,
FMC_ISPTRG=1342226448,
FMC_DFBADR=1342226452,
FMC_ISPSTA=1342226496,
GPIO_GPIOA_PMD=1342193664,
GPIO_GPIOA_OFFD=1342193668,
GPIO_GPIOA_DOUT=1342193672,
GPIO_GPIOA_DMASK=1342193676,
GPIO_GPIOA_PIN=1342193680,
GPIO_GPIOA_DBEN=1342193684,
GPIO_GPIOA_IMD=1342193688,
GPIO_GPIOA_IER=1342193692,
GPIO_GPIOA_ISR=1342193696,
GPIO_GPIOA_PUEN=1342193700,
GPIO_GPIOB_PMD=1342193728,
GPIO_GPIOB_OFFD=1342193732,
GPIO_GPIOB_DOUT=1342193736,
GPIO_GPIOB_DMASK=1342193740,
GPIO_GPIOB_PIN=1342193744,
GPIO_GPIOB_DBEN=1342193748,
GPIO_GPIOB_IMD=1342193752,
GPIO_GPIOB_IER=1342193756,
GPIO_GPIOB_ISR=1342193760,
GPIO_GPIOB_PUEN=1342193764,
GPIO_GPIOC_PMD=1342193792,
GPIO_GPIOC_OFFD=1342193796,
GPIO_GPIOC_DOUT=1342193800,
GPIO_GPIOC_DMASK=1342193804,
GPIO_GPIOC_PIN=1342193808,
GPIO_GPIOC_DBEN=1342193812,
GPIO_GPIOC_IMD=1342193816,
GPIO_GPIOC_IER=1342193820,
GPIO_GPIOC_ISR=1342193824,
GPIO_GPIOC_PUEN=1342193828,
GPIO_GPIOD_PMD=1342193856,
GPIO_GPIOD_OFFD=1342193860,
GPIO_GPIOD_DOUT=1342193864,
GPIO_GPIOD_DMASK=1342193868,
GPIO_GPIOD_PIN=1342193872,
GPIO_GPIOD_DBEN=1342193876,
GPIO_GPIOD_IMD=1342193880,
GPIO_GPIOD_IER=1342193884,
GPIO_GPIOD_ISR=1342193888,
GPIO_GPIOD_PUEN=1342193892,
GPIO_GPIOE_PMD=1342193920,
GPIO_GPIOE_OFFD=1342193924,
GPIO_GPIOE_DOUT=1342193928,
GPIO_GPIOE_DMASK=1342193932,
GPIO_GPIOE_PIN=1342193936,
GPIO_GPIOE_DBEN=1342193940,
GPIO_GPIOE_IMD=1342193944,
GPIO_GPIOE_IER=1342193948,
GPIO_GPIOE_ISR=1342193952,
GPIO_GPIOE_PUEN=1342193956,
GPIO_GPIOF_PMD=1342193984,
GPIO_GPIOF_OFFD=1342193988,
GPIO_GPIOF_DOUT=1342193992,
GPIO_GPIOF_DMASK=1342193996,
GPIO_GPIOF_PIN=1342194000,
GPIO_GPIOF_DBEN=1342194004,
GPIO_GPIOF_IMD=1342194008,
GPIO_GPIOF_IER=1342194012,
GPIO_GPIOF_ISR=1342194016,
GPIO_GPIOF_PUEN=1342194020,
GPIO_DBNCECON=1342194048,
GPIO_GPIOA0=1342194176,
GPIO_GPIOA1=1342194180,
GPIO_GPIOA2=1342194184,
GPIO_GPIOA3=1342194188,
GPIO_GPIOA4=1342194192,
GPIO_GPIOA5=1342194196,
GPIO_GPIOA6=1342194200,
GPIO_GPIOA7=1342194204,
GPIO_GPIOA8=1342194208,
GPIO_GPIOA9=1342194212,
GPIO_GPIOA10=1342194216,
GPIO_GPIOA11=1342194220,
GPIO_GPIOA12=1342194224,
GPIO_GPIOA13=1342194228,
GPIO_GPIOA14=1342194232,
GPIO_GPIOA15=1342194236,
GPIO_GPIOB0=1342194240,
GPIO_GPIOB1=1342194244,
GPIO_GPIOB2=1342194248,
GPIO_GPIOB3=1342194252,
GPIO_GPIOB4=1342194256,
GPIO_GPIOB5=1342194260,
GPIO_GPIOB6=1342194264,
GPIO_GPIOB7=1342194268,
GPIO_GPIOB8=1342194272,
GPIO_GPIOB9=1342194276,
GPIO_GPIOB10=1342194280,
GPIO_GPIOB11=1342194284,
GPIO_GPIOB12=1342194288,
GPIO_GPIOB13=1342194292,
GPIO_GPIOB14=1342194296,
GPIO_GPIOB15=1342194300,
GPIO_GPIOC0=1342194304,
GPIO_GPIOC1=1342194308,
GPIO_GPIOC2=1342194312,
GPIO_GPIOC3=1342194316,
GPIO_GPIOC4=1342194320,
GPIO_GPIOC5=1342194324,
GPIO_GPIOC6=1342194328,
GPIO_GPIOC7=1342194332,
GPIO_GPIOC8=1342194336,
GPIO_GPIOC9=1342194340,
GPIO_GPIOC10=1342194344,
GPIO_GPIOC11=1342194348,
GPIO_GPIOC12=1342194352,
GPIO_GPIOC13=1342194356,
GPIO_GPIOC14=1342194360,
GPIO_GPIOC15=1342194364,
GPIO_GPIOD0=1342194368,
GPIO_GPIOD1=1342194372,
GPIO_GPIOD2=1342194376,
GPIO_GPIOD3=1342194380,
GPIO_GPIOD4=1342194384,
GPIO_GPIOD5=1342194388,
GPIO_GPIOD6=1342194392,
GPIO_GPIOD7=1342194396,
GPIO_GPIOD8=1342194400,
GPIO_GPIOD9=1342194404,
GPIO_GPIOD10=1342194408,
GPIO_GPIOD11=1342194412,
GPIO_GPIOD12=1342194416,
GPIO_GPIOD13=1342194420,
GPIO_GPIOD14=1342194424,
GPIO_GPIOD15=1342194428,
GPIO_GPIOE0=1342194432,
GPIO_GPIOE1=1342194436,
GPIO_GPIOE2=1342194440,
GPIO_GPIOE3=1342194444,
GPIO_GPIOE4=1342194448,
GPIO_GPIOE5=1342194452,
GPIO_GPIOE6=1342194456,
GPIO_GPIOE7=1342194460,
GPIO_GPIOE8=1342194464,
GPIO_GPIOE9=1342194468,
GPIO_GPIOE10=1342194472,
GPIO_GPIOE11=1342194476,
GPIO_GPIOE12=1342194480,
GPIO_GPIOE13=1342194484,
GPIO_GPIOE14=1342194488,
GPIO_GPIOE15=1342194492,
GPIO_GPIOF0=1342194496,
GPIO_GPIOF1=1342194500,
GPIO_GPIOF2=1342194504,
GPIO_GPIOF3=1342194508,
GPIO_GPIOF4=1342194512,
GPIO_GPIOF5=1342194516,
I2C0_I2CCON=1073872896,
I2C0_I2CINTSTS=1073872900,
I2C0_I2CSTATUS=1073872904,
I2C0_I2CDIV=1073872908,
I2C0_I2CTOUT=1073872912,
I2C0_I2CDATA=1073872916,
I2C0_I2CSADDR0=1073872920,
I2C0_I2CSADDR1=1073872924,
I2C0_I2CSAMASK0=1073872936,
I2C0_I2CSAMASK1=1073872940,
I2C1_I2CCON=1074921472,
I2C1_I2CINTSTS=1074921476,
I2C1_I2CSTATUS=1074921480,
I2C1_I2CDIV=1074921484,
I2C1_I2CTOUT=1074921488,
I2C1_I2CDATA=1074921492,
I2C1_I2CSADDR0=1074921496,
I2C1_I2CSADDR1=1074921500,
I2C1_I2CSAMASK0=1074921512,
I2C1_I2CSAMASK1=1074921516,
I2S_I2S_CTRL=1075445760,
I2S_I2S_CLKDIV=1075445764,
I2S_I2S_INTEN=1075445768,
I2S_I2S_STATUS=1075445772,
I2S_I2S_TXFIFO=1075445776,
I2S_I2S_RXFIFO=1075445780,
LCD_LCD_CTL=1074462720,
LCD_LCD_DISPCTL=1074462724,
LCD_LCD_MEM0=1074462728,
LCD_LCD_MEM1=1074462732,
LCD_LCD_MEM2=1074462736,
LCD_LCD_MEM3=1074462740,
LCD_LCD_MEM4=1074462744,
LCD_LCD_MEM5=1074462748,
LCD_LCD_MEM6=1074462752,
LCD_LCD_MEM7=1074462756,
LCD_LCD_FCR=1074462760,
LCD_LCD_FCSTS=1074462764,
PWM0_PWMx_PRES=1074003968,
PWM0_PWMx_CLKSEL=1074003972,
PWM0_PWMx_CTL=1074003976,
PWM0_PWMx_INTEN=1074003980,
PWM0_PWMx_INTSTS=1074003984,
PWM0_PWMx_OE=1074003988,
PWM0_PWMx_DUTY0=1074003996,
PWM0_PWMx_DATA0=1074004000,
PWM0_PWMx_DUTY1=1074004008,
PWM0_PWMx_DATA1=1074004012,
PWM0_PWMx_DUTY2=1074004020,
PWM0_PWMx_DATA2=1074004024,
PWM0_PWMx_DUTY3=1074004032,
PWM0_PWMx_DATA3=1074004036,
PWM0_PWMx_CAPCTL=1074004052,
PWM0_PWMx_CAPINTEN=1074004056,
PWM0_PWMx_CAPINTSTS=1074004060,
PWM0_PWMx_CRL0=1074004064,
PWM0_PWMx_CFL0=1074004068,
PWM0_PWMx_CRL1=1074004072,
PWM0_PWMx_CFL1=1074004076,
PWM0_PWMx_CRL2=1074004080,
PWM0_PWMx_CFL2=1074004084,
PWM0_PWMx_CRL3=1074004088,
PMW0_PWMx_CFL3=1074004092,
PWM0_PWMx_PDMACH0=1074004096,
PWM0_PWMx_PDMACH2=1074004100,
PWM1_PWMx_PRES=1075052544,
PWM1_PWMx_CLKSEL=1075052548,
PWM1_PWMx_CTL=1075052552,
PWM1_PWMx_INTEN=1075052556,
PWM1_PWMx_INTSTS=1075052560,
PWM1_PWMx_OE=1075052564,
PWM1_PWMx_DUTY0=1075052572,
PWM1_PWMx_DATA0=1075052576,
PWM1_PWMx_DUTY1=1075052584,
PWM1_PWMx_DATA1=1075052588,
PWM1_PWMx_DUTY2=1075052596,
PWM1_PWMx_DATA2=1075052600,
PWM1_PWMx_DUTY3=1075052608,
PWM1_PWMx_DATA3=1075052612,
PWM1_PWMx_CAPCTL=1075052628,
PWM1_PWMx_CAPINTEN=1075052632,
PWM1_PWMx_CAPINTSTS=1075052636,
PWM1_PWMx_CRL0=1075052640,
PWM1_PWMx_CFL0=1075052644,
PWM1_PWMx_CRL1=1075052648,
PWM1_PWMx_CFL1=1075052652,
PWM1_PWMx_CRL2=1075052656,
PWM1_PWMx_CFL2=1075052660,
PWM1_PWMx_CRL3=1075052664,
PMW1_PWMx_CFL3=1075052668,
PWM1_PWMx_PDMACH0=1075052672,
PWM1_PWMx_PDMACH2=1075052676,
RTC_RTC_INIR=1073774592,
RTC_RTC_AER=1073774596,
RTC_RTC_FCR=1073774600,
RTC_RTC_TLR=1073774604,
RTC_RTC_CLR=1073774608,
RTC_RTC_TSSR=1073774612,
RTC_RTC_DWR=1073774616,
RTC_RTC_TAR=1073774620,
RTC_RTC_CAR=1073774624,
RTC_RTC_LIR=1073774628,
RTC_RTC_RIER=1073774632,
RTC_RTC_RIIR=1073774636,
RTC_RTC_TTR=1073774640,
RTC_RTC_SPRCTL=1073774652,
RTC_RTC_SPR0=1073774656,
RTC_RTC_SPR1=1073774660,
RTC_RTC_SPR2=1073774664,
RTC_RTC_SPR3=1073774668,
RTC_RTC_SPR4=1073774672,
RTC_RTC_SPR5=1073774676,
RTC_RTC_SPR6=1073774680,
RTC_RTC_SPR7=1073774684,
RTC_RTC_SPR8=1073774688,
RTC_RTC_SPR9=1073774692,
RTC_RTC_SPR10=1073774696,
RTC_RTC_SPR11=1073774700,
RTC_RTC_SPR12=1073774704,
RTC_RTC_SPR13=1073774708,
RTC_RTC_SPR14=1073774712,
RTC_RTC_SPR15=1073774716,
RTC_RTC_SPR16=1073774720,
RTC_RTC_SPR17=1073774724,
RTC_RTC_SPR18=1073774728,
RTC_RTC_SPR19=1073774732,
SC0_SCx_RBR=1075380224,
SC0_SCx_THR=1075380224,
SC0_SCx_CTL=1075380228,
SC0_SCx_ALTCTL=1075380232,
SC0_SCx_EGTR=1075380236,
SC0_SCx_RFTMR=1075380240,
SC0_SCx_ETUCR=1075380244,
SC0_SCx_IER=1075380248,
SC0_SCx_ISR=1075380252,
SC0_SCx_TRSR=1075380256,
SC0_SCx_PINCSR=1075380260,
SC0_SCx_TMR0=1075380264,
SC0_SCx_TMR1=1075380268,
SC0_SCx_TMR2=1075380272,
SC0_SCx_UACTL=1075380276,
SC0_SCx_TDRA=1075380280,
SC0_SCx_TDRB=1075380284,
SC1_SCx_RBR=1075511296,
SC1_SCx_THR=1075511296,
SC1_SCx_CTL=1075511300,
SC1_SCx_ALTCTL=1075511304,
SC1_SCx_EGTR=1075511308,
SC1_SCx_RFTMR=1075511312,
SC1_SCx_ETUCR=1075511316,
SC1_SCx_IER=1075511320,
SC1_SCx_ISR=1075511324,
SC1_SCx_TRSR=1075511328,
SC1_SCx_PINCSR=1075511332,
SC1_SCx_TMR0=1075511336,
SC1_SCx_TMR1=1075511340,
SC1_SCx_TMR2=1075511344,
SC1_SCx_UACTL=1075511348,
SC1_SCx_TDRA=1075511352,
SC1_SCx_TDRB=1075511356,
SC2_SCx_RBR=1075576832,
SC2_SCx_THR=1075576832,
SC2_SCx_CTL=1075576836,
SC2_SCx_ALTCTL=1075576840,
SC2_SCx_EGTR=1075576844,
SC2_SCx_RFTMR=1075576848,
SC2_SCx_ETUCR=1075576852,
SC2_SCx_IER=1075576856,
SC2_SCx_ISR=1075576860,
SC2_SCx_TRSR=1075576864,
SC2_SCx_PINCSR=1075576868,
SC2_SCx_TMR0=1075576872,
SC2_SCx_TMR1=1075576876,
SC2_SCx_TMR2=1075576880,
SC2_SCx_UACTL=1075576884,
SC2_SCx_TDRA=1075576888,
SC2_SCx_TDRB=1075576892,
SPI0_SPI_CTL=1073938432,
SPI0_SPI_STATUS=1073938436,
SPI0_SPI_CLKDIV=1073938440,
SPI0_SPI_SSR=1073938444,
SPI0_SPI_RX0=1073938448,
SPI0_SPI_RX1=1073938452,
SPI0_SPI_TX0=1073938464,
SPI0_SPI_TX1=1073938468,
SPI0_SPI_VARCLK=1073938484,
SPI0_SPI_PDMA=1073938488,
SPI0_SPI_FFCLR=1073938492,
SPI1_SPI_CTL=1074987008,
SPI1_SPI_STATUS=1074987012,
SPI1_SPI_CLKDIV=1074987016,
SPI1_SPI_SSR=1074987020,
SPI1_SPI_RX0=1074987024,
SPI1_SPI_RX1=1074987028,
SPI1_SPI_TX0=1074987040,
SPI1_SPI_TX1=1074987044,
SPI1_SPI_VARCLK=1074987060,
SPI1_SPI_PDMA=1074987064,
SPI1_SPI_FFCLR=1074987068,
SPI2_SPI_CTL=1074593792,
SPI2_SPI_STATUS=1074593796,
SPI2_SPI_CLKDIV=1074593800,
SPI2_SPI_SSR=1074593804,
SPI2_SPI_RX0=1074593808,
SPI2_SPI_RX1=1074593812,
SPI2_SPI_TX0=1074593824,
SPI2_SPI_TX1=1074593828,
SPI2_SPI_VARCLK=1074593844,
SPI2_SPI_PDMA=1074593848,
SPI2_SPI_FFCLR=1074593852,
TMR0_TMRx_CTL0=1073807360,
TMR0_TMRx_PRECNT0=1073807364,
TMR0_TMRx_CMPR0=1073807368,
TMR0_TMRx_IER0=1073807372,
TMR0_TMRx_ISR0=1073807376,
TMR0_TMRx_DR0=1073807380,
TMR0_TMRx_TCAP0=1073807384,
TMR0_TMRx_CTL1=1073807616,
TMR0_TMRx_PRECNT1=1073807620,
TMR0_TMRx_CMPR1=1073807624,
TMR0_TMRx_IER1=1073807628,
TMR0_TMRx_ISR1=1073807632,
TMR0_TMRx_DR1=1073807636,
TMR0_TMRx_TCAP1=1073807640,
TMR1_TMRx_CTL0=1074855936,
TMR1_TMRx_PRECNT0=1074855940,
TMR1_TMRx_CMPR0=1074855944,
TMR1_TMRx_IER0=1074855948,
TMR1_TMRx_ISR0=1074855952,
TMR1_TMRx_DR0=1074855956,
TMR1_TMRx_TCAP0=1074855960,
TMR1_TMRx_CTL1=1074856192,
TMR1_TMRx_PRECNT1=1074856196,
TMR1_TMRx_CMPR1=1074856200,
TMR1_TMRx_IER1=1074856204,
TMR1_TMRx_ISR1=1074856208,
TMR1_TMRx_DR1=1074856212,
TMR1_TMRx_TCAP1=1074856216,
TMR0_GPA_SHADOW=1073807872,
TMR0_GPB_SHADOW=1073807876,
TMR0_GPC_SHADOW=1073807880,
TMR0_GPD_SHADOW=1073807884,
TMR0_GPE_SHADOW=1073807888,
TMR0_GPF_SHADOW=1073807892,
TK_TK_CTL=1074528256,
TK_TK_STAT=1074528260,
TK_TK_DATA=1074528264,
TK_TK_INTEN=1074528268,
TK_TK_CTL1=1074528256,
TK_TK_CTL2=1074528260,
TK_TK_CTL3=1074528264,
TK_TK_STAT=1074528268,
TK_TK_DATA1=1074528272,
TK_TK_DATA2=1074528276,
TK_TK_DATA3=1074528280,
TK_TK_DATA4=1074528284,
TK_TK_INTEN=1074528288,
TK_TK8_0_THC=1074528292,
TK_TK9_1_THC=1074528296,
TK_TK10_2_THC=1074528300,
TK_TK11_3_THC=1074528304,
TK_TK12_4_THC=1074528308,
TK_TK13_5_THC=1074528312,
TK_TK14_6_THC=1074528316,
TK_TK15_7_THC=1074528320,
UART0_UARTx_RBR=1074069504,
UART0_UARTx_THR=1074069504,
UART0_UARTx_CTL=1074069508,
UART0_UARTx_TLCTL=1074069512,
UART0_UARTx_IER=1074069516,
UART0_UARTx_ISR=1074069520,
UART0_UARTx_TRSR=1074069524,
UART0_UARTx_FSR=1074069528,
UART0_UARTx_MCSR=1074069532,
UART0_UARTx_TMCTL=1074069536,
UART0_UARTx_BAUD=1074069540,
UART0_UARTx_IRCR=1074069552,
UART0_UARTx_ALT_CTL=1074069556,
UART0_UARTx_FUN_SEL=1074069560,
UART1_UARTx_RBR=1075118080,
UART1_UARTx_THR=1075118080,
UART1_UARTx_CTL=1075118084,
UART1_UARTx_TLCTL=1075118088,
UART1_UARTx_IER=1075118092,
UART1_UARTx_ISR=1075118096,
UART1_UARTx_TRSR=1075118100,
UART1_UARTx_FSR=1075118104,
UART1_UARTx_MCSR=1075118108,
UART1_UARTx_TMCTL=1075118112,
UART1_UARTx_BAUD=1075118116,
UART1_UARTx_IRCR=1075118128,
UART1_UARTx_ALT_CTL=1075118132,
UART1_UARTx_FUN_SEL=1075118136,
USB_USB_CTL=1074135040,
USB_USB_BUSSTS=1074135044,
USB_USB_INTEN=1074135048,
USB_USB_INTSTS=1074135052,
USB_USB_FADDR=1074135056,
USB_USB_EPSTS=1074135060,
USB_USB_BUFSEG=1074135064,
USB_USB_BUFSEG0=1074135072,
USB_USB_MXPLD0=1074135076,
USB_USB_CFG0=1074135080,
USB_USB_BUFSEG1=1074135088,
USB_USB_MXPLD1=1074135092,
USB_USB_CFG1=1074135096,
USB_USB_BUFSEG2=1074135104,
USB_USB_MXPLD2=1074135108,
USB_USB_CFG2=1074135112,
USB_USB_BUFSEG3=1074135120,
USB_USB_MXPLD3=1074135124,
USB_USB_CFG3=1074135128,
USB_USB_BUFSEG4=1074135136,
USB_USB_MXPLD4=1074135140,
USB_USB_CFG4=1074135144,
USB_USB_BUFSEG5=1074135152,
USB_USB_MXPLD5=1074135156,
USB_USB_CFG5=1074135160,
USB_USB_PDMA=1074135204,
USB_SRAM=1074135296,
WDT_WDT_CTL=1073758208,
WDT_WDT_IER=1073758212,
WDT_WDT_ISR=1073758216,
}
g_Nano1xx_regs=REG
function read_Nano100_Registers(t,t,t,e)
local a=true
local t={
Nano102_AN_QFN33=1,
Nano102_AN_LQFP48=1,
Nano102_AN_LQFP64=1,
Nano112_AN_LQFP48=1,
Nano112_AN_LQFP64=1,
Nano112_AN_LQFP100=1
}
if t[e]~=nil then a=false end
local o=true
local t={
Nano102_AN_QFN33=1,
Nano102_AN_LQFP48=1,
Nano102_AN_LQFP64=1,
Nano112_AN_LQFP48=1,
Nano112_AN_LQFP64=1,
Nano112_AN_LQFP100=1
}
if t[e]~=nil then o=false end
local t=true
local i={
Nano102_AN_QFN33=1,
Nano102_AN_LQFP48=1,
Nano102_AN_LQFP64=1,
Nano112_AN_LQFP48=1,
Nano112_AN_LQFP64=1,
Nano112_AN_LQFP100=1
}
if i[e]~=nil then t=false end
local e={}
e["GCR_PA_L_MFP"],
e["GCR_PA_H_MFP"],
e["GCR_PB_L_MFP"],
e["GCR_PB_H_MFP"],
e["GCR_PC_L_MFP"],
e["GCR_PC_H_MFP"],
e["GCR_PD_L_MFP"],
e["GCR_PD_H_MFP"],
e["GCR_PE_L_MFP"],
e["GCR_PE_H_MFP"],
e["GCR_PF_L_MFP"]=ice:ReadMem32(g_Nano1xx_regs.GCR_PA_L_MFP,11)
e["GCR_IRCTRIMCTL"]=ice:ReadMem32(g_Nano1xx_regs.GCR_IRCTRIMCTL)
e["GPIO_GPIOA_PMD"],
e["GPIO_GPIOA_OFFD"],
e["GPIO_GPIOA_DOUT"],
e["GPIO_GPIOA_DMASK"],
e["GPIO_GPIOA_PIN"]=ice:ReadMem32(g_Nano1xx_regs.GPIO_GPIOA_PMD,5)
e["GPIO_GPIOB_PMD"],
e["GPIO_GPIOB_OFFD"],
e["GPIO_GPIOB_DOUT"],
e["GPIO_GPIOB_DMASK"],
e["GPIO_GPIOB_PIN"]=ice:ReadMem32(g_Nano1xx_regs.GPIO_GPIOB_PMD,5)
e["GPIO_GPIOC_PMD"],
e["GPIO_GPIOC_OFFD"],
e["GPIO_GPIOC_DOUT"],
e["GPIO_GPIOC_DMASK"],
e["GPIO_GPIOC_PIN"]=ice:ReadMem32(g_Nano1xx_regs.GPIO_GPIOC_PMD,5)
e["GPIO_GPIOD_PMD"],
e["GPIO_GPIOD_OFFD"],
e["GPIO_GPIOD_DOUT"],
e["GPIO_GPIOD_DMASK"],
e["GPIO_GPIOD_PIN"]=ice:ReadMem32(g_Nano1xx_regs.GPIO_GPIOD_PMD,5)
e["GPIO_GPIOE_PMD"],
e["GPIO_GPIOE_OFFD"],
e["GPIO_GPIOE_DOUT"],
e["GPIO_GPIOE_DMASK"],
e["GPIO_GPIOE_PIN"]=ice:ReadMem32(g_Nano1xx_regs.GPIO_GPIOE_PMD,5)
e["GPIO_GPIOF_PMD"],
e["GPIO_GPIOF_OFFD"],
e["GPIO_GPIOF_DOUT"],
e["GPIO_GPIOF_DMASK"],
e["GPIO_GPIOF_PIN"]=ice:ReadMem32(g_Nano1xx_regs.GPIO_GPIOF_PMD,5)
e["GPIO_GPIOA_PUEN"],
e["GPIO_GPIOB_PUEN"],
e["GPIO_GPIOC_PUEN"],
e["GPIO_GPIOD_PUEN"]=ice:ReadMemMulti(g_Nano1xx_regs.GPIO_GPIOA_PUEN,
g_Nano1xx_regs.GPIO_GPIOB_PUEN,
g_Nano1xx_regs.GPIO_GPIOC_PUEN,
g_Nano1xx_regs.GPIO_GPIOD_PUEN)
e["GPIO_GPIOE_PUEN"],
e["GPIO_GPIOF_PUEN"]=ice:ReadMemMulti(g_Nano1xx_regs.GPIO_GPIOE_PUEN,
g_Nano1xx_regs.GPIO_GPIOF_PUEN)
e["CLK_PWRCTL"],
e["CLK_AHBCLK"],
e["CLK_APBCLK"],
e["CLK_CLKSTATUS"],
e["CLK_CLKSEL0"],
e["CLK_CLKSEL1"],
e["CLK_CLKSEL2"],
e["CLK_CLKDIV0"],
e["CLK_CLKDIV1"],
e["CLK_PLLCTL"],
e["CLK_FRQDIV"]=ice:ReadMem32(g_Nano1xx_regs.CLK_PWRCTL,11)
e["CLK_MCLKO"],
e["CLK_APBDIV"],
e["CLK_FRQDIV1"]=ice:ReadMemMulti(g_Nano1xx_regs.CLK_MCLKO,
g_Nano1xx_regs.CLK_APBDIV,
g_Nano1xx_regs.CLK_FRQDIV1)
e["UART0_UARTx_BAUD"],
e["UART1_UARTx_BAUD"]=ice:ReadMemMulti(g_Nano1xx_regs.UART0_UARTx_BAUD,
g_Nano1xx_regs.UART1_UARTx_BAUD)
if a then
e["I2S_I2S_CTRL"],
e["I2S_I2S_CLKDIV"]=ice:ReadMemMulti(g_Nano1xx_regs.I2S_I2S_CTRL,
g_Nano1xx_regs.I2S_I2S_CLKDIV)
end
e["I2C0_I2CCON"],
e["I2C1_I2CCON"],
e["I2C0_I2CDIV"],
e["I2C1_I2CDIV"]=ice:ReadMemMulti(g_Nano1xx_regs.I2C0_I2CCON,
g_Nano1xx_regs.I2C1_I2CCON,
g_Nano1xx_regs.I2C0_I2CDIV,
g_Nano1xx_regs.I2C1_I2CDIV)
e["PWM0_PWMx_CLKSEL"],
e["PWM1_PWMx_CLKSEL"],
e["PWM0_PWMx_PRES"],
e["PWM1_PWMx_PRES"]=ice:ReadMemMulti(g_Nano1xx_regs.PWM0_PWMx_CLKSEL,
g_Nano1xx_regs.PWM1_PWMx_CLKSEL,
g_Nano1xx_regs.PWM0_PWMx_PRES,
g_Nano1xx_regs.PWM1_PWMx_PRES)
e["SPI0_SPI_CTL"],
e["SPI1_SPI_CTL"],
e["SPI2_SPI_CTL"]=ice:ReadMemMulti(g_Nano1xx_regs.SPI0_SPI_CTL,
g_Nano1xx_regs.SPI1_SPI_CTL,
g_Nano1xx_regs.SPI2_SPI_CTL)
if o then
e["EBI_EBICON"]=ice:ReadMem32(g_Nano1xx_regs.EBI_EBICON)
end
e["SPI0_SPI_CLKDIV"],
e["SPI1_SPI_CLKDIV"],
e["SPI2_SPI_CLKDIV"]=ice:ReadMemMulti(g_Nano1xx_regs.SPI0_SPI_CLKDIV,
g_Nano1xx_regs.SPI1_SPI_CLKDIV,
g_Nano1xx_regs.SPI2_SPI_CLKDIV)
if t then
e["TK_TK_CTL"],
e["TK_TK_CTL1"],
e["TK_TK_CTL2"],
e["TK_TK_CTL3"]=ice:ReadMemMulti(g_Nano1xx_regs.TK_TK_CTL,
g_Nano1xx_regs.TK_TK_CTL1,
g_Nano1xx_regs.TK_TK_CTL2,
g_Nano1xx_regs.TK_TK_CTL3)
end
e["TMR0_TMRx_CTL0"],
e["TMR0_TMRx_CTL1"],
e["TMR1_TMRx_CTL0"],
e["TMR1_TMRx_CTL1"]=ice:ReadMemMulti(g_Nano1xx_regs.TMR0_TMRx_CTL0,
g_Nano1xx_regs.TMR0_TMRx_CTL1,
g_Nano1xx_regs.TMR1_TMRx_CTL0,
g_Nano1xx_regs.TMR1_TMRx_CTL1)
e["LCD_LCD_CTL"],
e["SC0_SCx_CTL"],
e["SC1_SCx_CTL"],
e["SC2_SCx_CTL"]=ice:ReadMemMulti(g_Nano1xx_regs.LCD_LCD_CTL,
g_Nano1xx_regs.SC0_SCx_CTL,
g_Nano1xx_regs.SC1_SCx_CTL,
g_Nano1xx_regs.SC2_SCx_CTL)
e["SC0_SCx_UACTL"],
e["SC1_SCx_UACTL"],
e["SC2_SCx_UACTL"]=ice:ReadMemMulti(g_Nano1xx_regs.SC0_SCx_UACTL,
g_Nano1xx_regs.SC1_SCx_UACTL,
g_Nano1xx_regs.SC2_SCx_UACTL)
e["SC0_SCx_ETUCR"],
e["SC1_SCx_ETUCR"],
e["SC2_SCx_ETUCR"]=ice:ReadMemMulti(g_Nano1xx_regs.SC0_SCx_ETUCR,
g_Nano1xx_regs.SC1_SCx_ETUCR,
g_Nano1xx_regs.SC2_SCx_ETUCR)
return e
end
local h={
[0]=kPinDirection_In,
[1]=kPinDirection_PushPullOut,
[2]=kPinDirection_OpenDrainOut,
}
local f={
[0]="INPUT",
[1]="OUTPUT",
[2]="Open-Drain",
}
function get_HXT_clock(o,a)
local e
local t
table.insert(a,"CLK_PWRCTL")
local a=ext.band(o["CLK_PWRCTL"],1)
if a==0 then
e=0
t="invalid external <b>4~24M</b> high speed crystal clock (see PWRCTL[0].HXT_EN)"
else
e=12000000
t="external <b>4~24M</b> high speed crystal clock, <font color=blue>when</font> external input clock is <font color=blue>12M</font>"
end
return e,t
end
function get_LXT_clock(a,o)
local e
local t
table.insert(o,"CLK_PWRCTL")
local a=ext.band(a["CLK_PWRCTL"],2)
if a==0 then
e=0
t="invalid external <b>32.768kHz</b> low speed crystal clock (see PWRCTL[1].LXT_EN)"
else
e=32768
t="external <b>32.768kHz</b> low speed crystal clock"
end
return e,t
end
function get_HIRC_clock(o,a)
local t
local e
table.insert(a,"CLK_PWRCTL")
local i=ext.band(o["CLK_PWRCTL"],4)
if i==0 then
t=0
e="invalid internal <b>12MHz</b> high speed oscillator clock (see PWRCTL[2].HIRC_EN)"
else
table.insert(a,"GCR_IRCTRIMCTL")
local a=ext.band(o["GCR_IRCTRIMCTL"],3)
if a==0 then
t=12000000
e="internal <b>12MHz</b> high speed oscillator clock"
elseif a==1 then
t=11059200
e="internal <b>11.0592MHz</b> high speed oscillator clock (auto trim)"
elseif a==2 then
t=12000000
e="internal <b>12MHz</b> high speed oscillator clock (auto trim)"
else
local a=get_chip_info()["series_group"]
if a==2 then
t=16000000
e="internal <b>16MHz</b> high speed oscillator clock (auto trim)"
else
t=12288000
e="internal <b>12.288MHz</b> high speed oscillator clock (auto trim)"
end
end
end
return t,e
end
function get_LIRC_clock(o,a)
local e
local t
table.insert(a,"CLK_PWRCTL")
local a=ext.band(o["CLK_PWRCTL"],8)
if a==0 then
e=0
t="invalid internal <b>10kHz</b> low speed oscillator clock (see PWRCTL[3].LIRC_EN)"
else
e=10000
t="internal <b>10kHz</b> low speed oscillator clock"
end
return e,t
end
function get_PLL_clock(a,o)
local i=get_chip_info()["series_group"]
local t
local e
table.insert(o,"CLK_PLLCTL")
if ext.band(a["CLK_PLLCTL"],65536)~=0 then
t=0
e="invalid <b>PLL</b> clock, PLL is in power down mode (see PLLCTL[16].PD)"
else
if ext.band(a["CLK_PLLCTL"],131072)~=0 then
t,e=get_HIRC_clock(a,o)
else
t,e=get_HXT_clock(a,o)
end
if t~=0 then
if i==2 then
local o=ext.rshift(ext.band(a["CLK_PLLCTL"],3840),8)
local a=ext.band(a["CLK_PLLCTL"],63)
t=t/(o+1)*a
if a==0 then
e="invalid <b>PLL</b> clock (see PLLCTL[5:0].PLL_MLP)"
else
e=string.format("<b>PLL</b> clock (<b>%sHz</b>), from %s",val2str(t),e)
end
else
local i={2,4,8,16}
local n={1,2}
local o=ext.band(a["CLK_PLLCTL"],31)+32
local i=i[ext.rshift(ext.band(a["CLK_PLLCTL"],768),8)+1]
local a=n[ext.rshift(ext.band(a["CLK_PLLCTL"],4096),12)+1]
t=t*o/i/a
e=string.format("<b>PLL</b> clock (<b>%sHz</b>), from %s",val2str(t),e)
end
else
e="<b>PLL</b> clock from "..e
end
end
return t,e
end
function get_sys_clock(o,a,n)
local e
local t
table.insert(a,"CLK_CLKSEL0")
local i=ext.band(o["CLK_CLKSEL0"],7)
if i==0 then
e,t=get_HXT_clock(o,a)
elseif i==1 then
e,t=get_LXT_clock(o,a)
elseif i==2 then
e,t=get_PLL_clock(o,a)
elseif i==3 then
e,t=get_LIRC_clock(o,a)
elseif i==7 then
e,t=get_HIRC_clock(o,a)
else
e=0
t="invalid <b>"..n.."</b> clock (see CLKSEL0[2:0].HCLK_S)"
return e,t
end
if e==0 then
t="<b>"..n.."</b> clock from "..t
else
table.insert(a,"CLK_CLKDIV0")
local a=ext.band(o["CLK_CLKDIV0"],15)
e=e/(a+1)
t=string.format("<b>%s</b> clock (<b>%sHz</b>), from %s",n,val2str(e),t)
end
return e,t
end
function get_HCLK_clock(e,t)
return get_sys_clock(e,t,"HCLK")
end
function get_PCLK_clock(a,o)
local e=get_chip_info()["series_group"]
if e==2 then
local e
local t
e,t=get_HCLK_clock(a,o)
if e==0 then
t="<b>PCLK</b> clock from "..t
else
table.insert(o,"CLK_APBDIV")
local a=ext.band(a["CLK_APBDIV"],7)
if a<=4 then
e=ext.rshift(e,a)
end
t=string.format("<b>PCLK</b> clock (<b>%sHz</b>), from %s",val2str(e),t)
end
return e,t
else
return get_sys_clock(a,o,"PCLK")
end
end
function get_clk_informnation(t,e)
return reg2str("Clock setting registers",g_Nano1xx_regs,t,e)
end
function get_mfp_regs(e,t,a)
local t={"GCR_P"..t.."_"..a.."_MFP"}
return reg2str("Multi-Function register",g_Nano1xx_regs,e,t)
end
function fill_Nano100_GPIO(o,s,a,e)
local i=""
local t=""
local u=string.format("P%s.%d",a,e)
o["highlight_text"]=u
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_GPIO
o["pin_bg_color"]=kBgColor_GPIO
local n=s["GPIO_GPIO"..a.."_PMD"]
local m=s["GPIO_GPIO"..a.."_OFFD"]
local d=s["GPIO_GPIO"..a.."_DOUT"]
local l=s["GPIO_GPIO"..a.."_DMASK"]
local r=s["GPIO_GPIO"..a.."_PIN"]
local c=s["GPIO_GPIO"..a.."_PUEN"]
local n=ext.band(ext.rshift(n,e*2),3)
o["direction"]=h[n]
if h[n]==kPinDirection_In then
if ext.band(r,ext.lshift(1,e))==0 then
o["status"]=kPinStatus_Low
else
o["status"]=kPinStatus_High
end
elseif h[n]==kPinDirection_PushPullOut
or h[n]==kPinDirection_OpenDrainOut then
if ext.band(l,ext.lshift(1,e))~=0 then
o["status"]=kPinStatus_Unknown
elseif ext.band(d,ext.lshift(1,e))==0 then
o["status"]=kPinStatus_Low
else
o["status"]=kPinStatus_High
end
else
i=string.format("GPIO%s_PMD[%d:%d] is undefined<br>",a,e*2+1,e*2)
end
t=string.format("P%s.%d is in <b>%s</b> mode<br>",
a,e,f[n])
if h[n]==kPinDirection_In then
if ext.band(r,ext.lshift(1,e))==0 then
t=t.."Pin input <b>low</b><br>"
else
t=t.."Pin input <b>high</b><br>"
end
end
if h[n]==kPinDirection_PushPullOut
or h[n]==kPinDirection_OpenDrainOut then
if ext.band(l,ext.lshift(1,e))~=0 then
t=t.."Pin output <b>masked</b><br>"
elseif ext.band(d,ext.lshift(1,e))==0 then
t=t.."Pin output <b>low</b><br>"
else
t=t.."Pin output <b>high</b><br>"
end
end
if ext.band(m,ext.lshift(1,e+16))==0 then
t=t.."IO digital input path <b>enabled</b><br>"
else
t=t.."IO digital input path <b>disabled</b>(digital input tied to low)<br>"
end
if ext.band(ext.rshift(c,e),1)~=0 then
o["pullup"]=true
t=t.."Pull-up resistor <b>enable</b><br>"
else
o["pullup"]=false
t=t.."Pull-up resistor <b>disable</b><br>"
end
if h[n]==kPinDirection_PushPullOut then
if ext.band(d,ext.lshift(1,e))==0 and ext.band(r,ext.lshift(1,e))~=0 then
i=i..string.format("Leakage warning: GPIO%s_DOUT[%d] = 0, GPIO%s_PIN[%d] = 1<br>",a,e,a,e)
elseif ext.band(d,ext.lshift(1,e))~=0 and ext.band(r,ext.lshift(1,e))==0 then
i=i..string.format("Leakage warning: GPIO%s_DOUT[%d] = 1, GPIO%s_PIN[%d] = 0<br>",a,e,a,e)
end
end
local n
if e>=0 and e<=7 then
n="L"
elseif e>=8 and e<=15 then
n="H"
else
i=i.."Bit error, it should be 0~15.<br>"
end
if i~=""then
o["pin_no_color"]=kBgColor_Error
i="<font color=red>"..i.."</font>"
end
local e={
"GPIO_GPIO"..a.."_PMD",
"GPIO_GPIO"..a.."_OFFD",
"GPIO_GPIO"..a.."_DOUT",
"GPIO_GPIO"..a.."_DMASK",
"GPIO_GPIO"..a.."_PIN",
"GPIO_GPIO"..a.."_PUEN"}
local e=reg2str("GPIO setting registers",g_Nano1xx_regs,s,e)
if t~=""then
t="<b>Information</b><br>"..t
end
o["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",u,i,
get_mfp_regs(s,a,n),e,t)
end
function fill_invalid_GPIO(e,i,o,t)
e["highlight_text"]=string.format("P%s.%d",o,t)
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Invalid
e["pin_bg_color"]=kBgColor_Invalid
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
e["pin_no_color"]=kBgColor_Error
local a
if t>=0 and t<=7 then
a="L"
elseif t>=8 and t<=15 then
a="H"
end
local n="<font color=red>Undefined setting in Multi-Function registers for this pin</font><br>"
e["information"]=string.format("<b>P%s.%d</b><br>%s<br>"..
"%s",
o,t,
n,
get_mfp_regs(i,o,a))
end
function fill_Nano100_ACMP(e,a,s,n,o)
local t=""
local i={}
e["highlight_text"]=o
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_CMP
e["pin_bg_color"]=kBgColor_CMP
e["direction"]=kPinDirection_In
e["status"]=kPinStatus_Unknown
table.insert(i,"CLK_APBCLK")
if ext.band(a["CLK_APBCLK"],2048)==0 then
t="ACMP clock is not available (see APBCLK[11].ACMP_EN).<br>"
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
e["information"]=string.format("<b>%s</b><br>%s<br>%s%s",
o,
t,
get_mfp_regs(a,s,n),
get_clk_informnation(a,i))
end
function fill_Nano100_ADC(a,e,r,d,h)
local n=get_chip_info()["series_group"]
local s=""
local o=""
local t={}
a["highlight_text"]=h
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_ADC
a["pin_bg_color"]=kBgColor_ADC
a["direction"]=kPinDirection_In
a["status"]=kPinStatus_Unknown
table.insert(t,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],268435456)~=0 then
table.insert(t,"CLK_CLKSEL1")
local i=0
if n==2 then
i=ext.rshift(ext.band(e["CLK_CLKSEL1"],3670016),19)
else
i=ext.rshift(ext.band(e["CLK_CLKSEL1"],12),2)
end
local h=ext.rshift(ext.band(e["CLK_CLKDIV0"],16711680),16)
local n
local a
if i==0 then
n,a=get_HXT_clock(e,t)
elseif i==1 then
n,a=get_LXT_clock(e,t)
elseif i==2 then
n,a=get_PLL_clock(e,t)
elseif i==3 then
n,a=get_HIRC_clock(e,t)
else
n,a=get_HCLK_clock(e,t)
end
if o==""then
local e=n/(h+1)
if e~=0 then
table.insert(t,"CLK_CLKDIV0")
s=string.format("ADC clock frequency: <b>%sHz</b>, from %s.<br>",val2str(e),a)
else
o="ADC clock is not available, "..a..".<br>"
end
end
else
o="ADC clock is not available (see APBCLK[28].ADC_EN).<br>"
end
if o~=""then
o="<font color=red>"..o.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if s~=""then
s="<b>Information</b><br>"..s
end
a["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
h,
o,
get_mfp_regs(e,r,d),
get_clk_informnation(e,t),
s)
end
function fill_Nano100_DAC(e,o,h,s,n)
local a=""
local t=""
local i={}
e["highlight_text"]=n
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_DAC
e["pin_bg_color"]=kBgColor_DAC
e["direction"]=kPinDirection_PushPullOut
e["status"]=kPinStatus_Unknown
table.insert(i,"CLK_APBCLK")
if ext.band(o["CLK_APBCLK"],33554432)~=0 then
local e
local t
e,t=get_PCLK_clock(o,i)
a=string.format("DAC clock frequency: <b>%sHz</b>, from %s.<br>",val2str(e),t)
else
t="DAC clock is not available (see APBCLK[25].DAC_EN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
e["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
n,
t,
get_mfp_regs(o,h,s),
get_clk_informnation(o,i),
a)
end
function fill_Nano100_I2S(a,t,h,r,s)
local e=""
local i=""
local o={}
a["highlight_text"]=s
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_I2S
a["pin_bg_color"]=kBgColor_I2S
a["direction"]=kPinDirection_Unknown
a["status"]=kPinStatus_Unknown
table.insert(o,"CLK_APBCLK")
if ext.band(t["CLK_APBCLK"],536870912)~=0 then
table.insert(o,"CLK_CLKSEL2")
local s=ext.rshift(ext.band(t["CLK_CLKSEL2"],196608),16)
local a
local n
if s==0 then
a,n=get_HXT_clock(t,o)
elseif s==1 then
a,n=get_PLL_clock(t,o)
else
a,n=get_HIRC_clock(t,o)
end
if a~=0 then
table.insert(o,"I2S_I2S_CTRL")
table.insert(o,"I2S_I2S_CLKDIV")
local o=ext.band(t["I2S_I2S_CTRL"],1)
if o~=0 then
e="I2S is enabled<br>"
else
e="I2S is <font color=red>disabled</font>, (see I2S_CTRL[0].I2SEN)<br>"
end
e=e..string.format("I2S_CLK frequency: <b>%sHz</b>, from %s.<br>",val2str(a),n)
local i=ext.band(ext.rshift(t["I2S_I2S_CLKDIV"],8),255)
local o=ext.band(t["I2S_I2S_CLKDIV"],7)
local i=a/(2*(i+1))
local t=a
if o~=0 then
t=a/(2*o)
end
e=e..string.format("I2S BCLK frequency: <b>%sHz</b><br>",val2str(i))
e=e..string.format("I2S MCLK frequency: <b>%sHz</b><br>",val2str(t))
else
i="I2S clock is not available, "..n..".<br>"
end
else
i="I2S clock is not available (see APBCLK[29].I2S_EN).<br>"
end
if i~=""then
i="<font color=red>"..i.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if e~=""then
e="<b>Information</b><br>"..e
end
a["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
s,
i,
get_mfp_regs(t,h,r),
get_clk_informnation(t,o),
e)
end
function fill_Nano100_EBI(t,a,r,h,s)
local e=""
local o=""
local i={}
t["highlight_text"]=s
t["normal_color"]=kColor_Invalid
t["highlight_color"]=kColor_EBI
t["pin_bg_color"]=kBgColor_EBI
t["direction"]=kPinDirection_PushPullOut
t["status"]=kPinStatus_Unknown
table.insert(i,"CLK_AHBCLK")
local n=ext.band(a["CLK_AHBCLK"],8)
if n~=0 then
local t
local n
t,n=get_HCLK_clock(a,i)
if t~=0 then
table.insert(i,"EBI_EBICON")
local o=ext.band(ext.rshift(a["EBI_EBICON"],8),7)
local i=t
if o<=5 then
i=ext.rshift(t,o)
end
e=e..string.format("EBI MCLK frequency: <b>%sHz</b>, from %s<br>",
val2str(i),n)
local o=ext.band(ext.rshift(a["EBI_EBICON"],11),1)
local t=ext.band(ext.rshift(a["EBI_EBICON"],1),1)
local a=ext.band(a["EBI_EBICON"],1)
if a~=0 then
e=e..string.format("EBI Bank: address/data bus multiplex mode, and data width <b>%d-bit</b><br>",
(t~=0)and 16 or 8)
if o==0 then
e=e..string.format("EBI <b>disabled</b> to generate clock to external device<br>")
end
else
e=e..string.format("EBI Bank <b>disabled</b><br>")
end
else
o=string.format("EBI clock is not available, %s.<br>",n)
end
else
o="EBI clock is disabled (see AHBCLK[3].EBI_EN).<br>"
end
if o~=""then
o="<font color=red>"..o.."</font>"
t["pin_no_color"]=kBgColor_Error
end
if e~=""then
e="<b>Information</b><br>"..e
end
t["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
s,
o,
get_mfp_regs(a,r,h),
get_clk_informnation(a,i),
e)
end
function fill_Nano100_I2C(t,o,r,d,s,e)
local n=""
local a=""
local i={}
t["highlight_text"]=s
t["normal_color"]=kColor_Invalid
t["highlight_color"]=kColor_I2C
t["pin_bg_color"]=kBgColor_I2C
t["direction"]=kPinDirection_Unknown
t["status"]=kPinStatus_Unknown
table.insert(i,"CLK_APBCLK")
if ext.band(o["CLK_APBCLK"],ext.lshift(256,e))~=0 then
local t=string.format("I2C%d_I2CCON",e)
local s=string.format("I2C%d_I2CDIV",e)
table.insert(i,t)
local t=ext.band(o[t],1)
if t~=0 then
local t,h=get_PCLK_clock(o,i)
if t~=0 then
table.insert(i,s)
local a=ext.band(o[s],255)
local t=t/(4*(a+1))
n=string.format("I2C%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(t),h)
else
a=string.format("I2C%d clock is not available, %s.<br>",e,h)
end
else
a=string.format("I2C%d controller disabled (see I2C%d.I2CCON[0].IPEN).<br>",e,e)
end
else
a=string.format("I2C%d clock is not available (see APBCLK[%d].I2C_EN).<br>",e,8+e)
end
if a~=""then
a="<font color=red>"..a.."</font>"
t["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
t["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
s,
a,
get_mfp_regs(o,r,d),
get_clk_informnation(o,i),
n)
end
function fill_Nano100_CLKO(o,e,l,u,d,i)
local c=get_chip_info()["series_group"]
local s=""
local t=""
local n={}
if i==nil then i=0 end
o["highlight_text"]=d
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_CLK
o["pin_bg_color"]=kBgColor_CLK
o["direction"]=kPinDirection_PushPullOut
o["status"]=kPinStatus_Unknown
table.insert(n,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],ext.lshift(64,i))~=0 then
local h=({"CLK_FRQDIV","CLK_FRQDIV1"})[i+1]
table.insert(n,h)
if ext.band(e[h],16)~=0 then
table.insert(n,"CLK_CLKSEL2")
local r=ext.band(ext.rshift(e["CLK_CLKSEL2"],2*(1-i)),3)
local d=ext.band(e[h],15)
local o
local a
if r==0 then
o,a=get_HXT_clock(e,n)
elseif r==1 then
o,a=get_LXT_clock(e,n)
elseif r==2 then
o,a=get_HCLK_clock(e,n)
elseif r==3 then
o,a=get_HIRC_clock(e,n)
end
if t==""then
local n
local e=ext.band(e[h],32)
if c==2 and e~=0 then
n=o
else
n=o/ext.lshift(1,(d+1))
end
if n~=0 then
if i==0 then
s=string.format("FRQDIV clock frequency: <b>%sHz</b>, from %s.<br>",val2str(n),a)
else
s=string.format("FRQDIV1 clock frequency: <b>%sHz</b>, from %s.<br>",val2str(n),a)
end
else
if i==0 then
t="FRQDIV clock is not available, "..a..".<br>"
else
t="FRQDIV1 clock is not available, "..a..".<br>"
end
end
end
else
t=string.format("Frequency divider disabled (see %s[4].FDIV_EN).<br>",h)
end
else
if i==0 then
t="FRQDIV clock is not available (see APBCLK[6].FDIV_EN).<br>"
else
t="FRQDIV1 clock is not available (see APBCLK[7].FDIV1_EN).<br>"
end
end
if t~=""then
t="<font color=red>"..t.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if s~=""then
s="<b>Information</b><br>"..s
end
o["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
d,
t,
get_mfp_regs(e,l,u),
get_clk_informnation(e,n),
s)
end
function fill_Nano100_TM(n,t,u,l,d,r,h)
local c=get_chip_info()["series_group"]
local i=""
local o=""
local a={}
local e=ext.lshift(r,1)+h
n["highlight_text"]=d
n["normal_color"]=kColor_Invalid
n["highlight_color"]=kColor_TM
n["pin_bg_color"]=kBgColor_TM
n["direction"]=kPinDirection_Unknown
n["status"]=kPinStatus_Unknown
table.insert(a,"CLK_APBCLK")
local s=ext.band(t["CLK_APBCLK"],ext.lshift(4,e))
if s~=0 then
local n=string.format("TMR%d_TMRx_CTL%d",r,h)
table.insert(a,n)
local n=ext.band(t[n],4096)
if n~=0 then
i=string.format("Timer%d counting is controlled by external event pin.<br>",e)
else
if e==0 then
TMR_S=ext.rshift(ext.band(t["CLK_CLKSEL1"],1792),8)
table.insert(a,"CLK_CLKSEL1")
elseif e==1 then
TMR_S=ext.rshift(ext.band(t["CLK_CLKSEL1"],28672),12)
table.insert(a,"CLK_CLKSEL1")
elseif e==2 then
TMR_S=ext.rshift(ext.band(t["CLK_CLKSEL2"],1792),8)
table.insert(a,"CLK_CLKSEL2")
elseif e==3 then
TMR_S=ext.rshift(ext.band(t["CLK_CLKSEL2"],28672),12)
table.insert(a,"CLK_CLKSEL2")
else
o=string.format("Timer%d do not exist.<br>",e)
end
local s=0
local n
if TMR_S==0 then
s,n=get_HXT_clock(t,a)
elseif TMR_S==1 then
s,n=get_LXT_clock(t,a)
elseif TMR_S==2 then
s,n=get_LIRC_clock(t,a)
elseif TMR_S==3 then
i=string.format("Timer%d clock is from external pin.<br>",e)
elseif ext.band(TMR_S,4)~=0 then
s,n=get_HIRC_clock(t,a)
else
if c==2 then
s,n=get_HCLK_clock(t,a)
else
o=string.format("Timer%d clock source is undefined (see CLK_CLKSEL%s[%d:%d].TMR%d_S).<br>",
e,(r+1),h*4+10,h*4+8,e)
end
end
if o==""and i==""then
if s~=0 then
i=string.format("Timer%d clock frequency: <b>%sHz</b>, from %s<br>",
e,val2str(s),n)
else
o=string.format("Timer%d clock is not available, %s.<br>",e,n)
end
end
end
else
o=string.format("Timer%d clock is disabled (see APBCLK[%d].TMR%d_EN).<br>",e,(e+2),e)
end
if o~=""then
o="<font color=red>"..o.."</font>"
n["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
n["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
d,
o,
get_mfp_regs(t,u,l),
get_clk_informnation(t,a),
i)
end
function fill_Nano100_USB(e,i,s)
local a=""
local t=""
local o={}
e["highlight_text"]=s
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_USB
e["pin_bg_color"]=kBgColor_USB
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
table.insert(o,"CLK_APBCLK")
if ext.band(i["CLK_APBCLK"],134217728)~=0 then
local n
local e
n,e=get_PLL_clock(i,o)
if n~=0 then
table.insert(o,"CLK_CLKDIV0")
local t=ext.band(ext.rshift(i["CLK_CLKDIV0"],4),15)
local t=n/(t+1)
a=string.format("USB clock frequency: <b>%sHz</b>, from %s.<br>",val2str(t),e)
else
t="USB clock is not available, "..e..".<br>"
end
else
t="USB clock is not available (see APBCLK[27].USBD_EN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
e["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s",
s,
t,
get_clk_informnation(i,o),
a)
end
function fill_Nano100_SPI(n,e,c,m,u,t)
local l=get_chip_info()["series_group"]
local a=""
local s=""
local i={}
n["highlight_text"]=u
n["normal_color"]=kColor_Invalid
n["highlight_color"]=kColor_SPI
n["pin_bg_color"]=kBgColor_SPI
n["direction"]=kPinDirection_Unknown
n["status"]=kPinStatus_Unknown
table.insert(i,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],ext.lshift(4096,t))~=0 then
local o,h
if l==0 then
o,h=get_PCLK_clock(e,i)
else
table.insert(i,"CLK_CLKSEL2")
local t=ext.band(ext.rshift(e["CLK_CLKSEL2"],t+20),1)
if t==0 then
o,h=get_PLL_clock(e,i)
else
o,h=get_HCLK_clock(e,i)
end
end
if o~=0 then
local d=string.format("SPI%d_SPI_CTL",t)
local n=string.format("SPI%d_SPI_CLKDIV",t)
table.insert(i,d)
local s=ext.band(e[d],262144)
if s~=0 then
a=string.format("SPI%d is in <b>slave</b> mode.<br>",t)
else
a=string.format("SPI%d is in <b>master</b> mode.<br>",t)
local s=0
local r=0
if l==0 then
table.insert(i,n)
local t=ext.band(e[n],65535)
local e=ext.band(ext.rshift(e[n],16),65535)
if t==0 then
s=o
else
s=o/(t*2)
end
r=o/((e+1)*2)
else
table.insert(i,n)
local t=ext.band(e[n],255)
local e=ext.band(ext.rshift(e[n],16),255)
s=o/(t+1)
r=o/((e+1)*2)
end
local e=ext.band(e[d],8388608)
if e~=0 then
a=a..string.format("SPI%d clock frequency is variable: <b>%sHz</b> or <b>%sHz</b>, from %s.<br>",
t,val2str(s),val2str(r),h)
else
a=a..string.format("SPI%d clock frequency: <b>%sHz</b>, from %s.<br>",
t,val2str(s),h)
end
end
else
s=string.format("SPI%d clock is not available, ",t)..h..".<br>"
end
else
s=string.format("SPI%d clock is not available (see APBCLK[%d].SPI%d_EN).<br>",t,t+12,t)
end
if s~=""then
s="<font color=red>"..s.."</font>"
n["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
n["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
u,
s,
get_mfp_regs(e,c,m),
get_clk_informnation(e,i),
a)
end
function fill_Nano100_SPI_IO(e,o,a,t)
local a=string.format("SPI%d_SPI_CTL",a)
local a=ext.band(o[a],262144)
if a==0 then
if t then
e["direction"]=kPinDirection_In
else
e["direction"]=kPinDirection_PushPullOut
end
else
if t then
e["direction"]=kPinDirection_PushPullOut
else
e["direction"]=kPinDirection_In
end
end
end
function fill_Nano100_PWM(s,a,w,y,f,t,e)
local u=""
local o=""
local i={}
s["highlight_text"]=f
s["normal_color"]=kColor_Invalid
s["highlight_color"]=kColor_PWM
s["pin_bg_color"]=kBgColor_PWM
s["direction"]=kPinDirection_Unknown
s["status"]=kPinStatus_Unknown
local l
local r
local n
local m
local c
local h
if t==0 and(e==0 or e==1)then
l=20
r="PWM0_CH01"
c="CP01"
h=0
n=ext.rshift(ext.band(a["CLK_CLKSEL1"],48),4)
m="CLK_CLKSEL1"
table.insert(i,"CLK_CLKSEL1")
elseif t==0 and(e==2 or e==3)then
l=21
r="PWM0_CH23"
c="CP23"
h=8
n=ext.rshift(ext.band(a["CLK_CLKSEL1"],192),6)
m="CLK_CLKSEL1"
table.insert(i,"CLK_CLKSEL1")
elseif t==1 and(e==0 or e==1)then
l=22
r="PWM1_CH01"
c="CP01"
h=0
n=ext.rshift(ext.band(a["CLK_CLKSEL2"],48),4)
m="CLK_CLKSEL2"
table.insert(i,"CLK_CLKSEL2")
elseif t==1 and(e==2 or e==3)then
l=23
r="PWM1_CH23"
c="CP23"
h=8
n=ext.rshift(ext.band(a["CLK_CLKSEL2"],192),6)
m="CLK_CLKSEL2"
table.insert(i,"CLK_CLKSEL2")
else
o=string.format("PWM%d Channel%d do not exist",t,e)
end
if o==""then
table.insert(i,"CLK_APBCLK")
local s=ext.band(a["CLK_APBCLK"],ext.lshift(1,l))
if s~=0 then
local s
local d
if n==0 then
s,d=get_HXT_clock(a,i)
elseif n==1 then
s,d=get_LXT_clock(a,i)
elseif n==2 then
s,d=get_HCLK_clock(a,i)
elseif n==3 then
s,d=get_HIRC_clock(a,i)
else
o=string.format("PWM%d channel%d clock source select error (see %s.%s_S).<br>",
t,e,m,r)
end
if o==""then
if s==0 then
o=string.format("PWM%d channel%d clock is not available, %s.<br>",t,e,d)
else
local n=string.format("PWM%d",t).."_PWMx_CLKSEL"
local r=string.format("PWM%d",t).."_PWMx_PRES"
table.insert(i,n)
table.insert(i,r)
local i=ext.band(ext.rshift(a[n],e*4),7)
local i=({2,4,8,16,1,0,0,0})[i+1]
local a=ext.band(ext.rshift(a[r],h),255)
if a==0 then
o=string.format("PWM%d channel%d counter will be stopped since %s[%d:%d].%s = 0<br>",
t,e,r,
h+7,
h,
c)
elseif i==0 then
o=string.format("PWM%d channel%d counter clock is not available (see %s[%d:%d].CLKSEL%d).<br>",
t,e,n,
4*e+2,
4*e,
e)
else
local a=s/(a+1)
local o=a/i
u=string.format("PWM%d channel%d clock frequency: <b>%sHz</b> (Pre-Scaled), from %s.<br>"..
"PWM%d channel%d counter frequency: <b>%sHz</b><br>",
t,e,val2str(a),d,
t,e,val2str(o))
end
end
end
else
o=string.format("PWM%d channel%d clock is not available (see APBCLK[%d].%s_EN).<br>",
t,e,l,r)
end
end
if o~=""then
o="<font color=red>"..o.."</font>"
s["pin_no_color"]=kBgColor_Error
end
if u~=""then
u="<b>Information</b><br>"..u
end
s["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
f,
o,
get_mfp_regs(a,w,y),
get_clk_informnation(a,i),
u)
end
function fill_Nano100_UART(o,e,l,u,d,i)
local n=""
local t=""
local a={}
local h=0
o["highlight_text"]=d
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_UART
o["pin_bg_color"]=kBgColor_UART
o["direction"]=kPinDirection_Unknown
o["status"]=kPinStatus_Unknown
function get_uart_baudate(o)
local t=string.format("UART%d_UARTx_BAUD",i)
table.insert(a,t)
local i=ext.band(e[t],2147483648)
local t=ext.band(e[t],65535)
local e=0
local a=""
if i==0 then
e=o/(t+1)
a="BRD must > 8"
else
e=o/(16*(t+1))
end
return e,a
end
table.insert(a,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],ext.lshift(65536,i))~=0 then
table.insert(a,"CLK_CLKSEL1")
local r=ext.band(e["CLK_CLKSEL1"],3)
local d=ext.band(ext.rshift(e["CLK_CLKDIV0"],8),15)
local s
local o
if r==0 then
s,o=get_HXT_clock(e,a)
elseif r==1 then
s,o=get_LXT_clock(e,a)
elseif r==2 then
s,o=get_PLL_clock(e,a)
elseif r==3 then
s,o=get_HIRC_clock(e,a)
else
t=string.format("UART%d clock source select error (see CLKSEL1[1:0].UART_S).<br>",i)
end
if t==""then
h=s/(d+1)
if h~=0 then
table.insert(a,"CLK_CLKDIV0")
n=string.format("UART%d clock frequency: <b>%sHz</b>, from %s.<br>",i,val2str(h),o)
else
t=string.format("UART%d clock is not available, %s.<br>",i,o)
end
end
else
t=string.format("UART%d clock is not available (see APBCLK[%d].UART%d_EN).<br>",
i,i+16,i)
end
if t==""then
local e,a=get_uart_baudate(h)
if e~=0 then
n=n..string.format("UART baudrate: <b>%d</b><br>",e)
else
t=a..".<br>"
end
end
if t~=""then
t="<font color=red>"..t.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
o["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
d,
t,
get_mfp_regs(e,l,u),
get_clk_informnation(e,a),
n)
end
function fill_Nano100_TK(n,e,u,l,d,t)
local r=get_chip_info()["series_group"]
local i=""
local a=""
local o={}
n["highlight_text"]=d
n["normal_color"]=kColor_Invalid
n["highlight_color"]=kColor_TK
n["pin_bg_color"]=kBgColor_TK
n["direction"]=kPinDirection_In
n["status"]=kPinStatus_Unknown
table.insert(o,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],16777216)~=0 then
local n=0
if r==0 then
n=ext.band(e["TK_TK_CTL"],32768)
table.insert(o,"TK_TK_CTL")
else
n=ext.band(e["TK_TK_CTL1"],2147483648)
table.insert(o,"TK_TK_CTL1")
end
if n~=0 then
table.insert(o,"CLK_CLKSEL1")
local s=ext.rshift(ext.band(e["CLK_CLKSEL1"],196608),16)
local d=ext.rshift(ext.band(e["CLK_CLKDIV0"],251658240),24)
local h
local n
if s==0 then
h,n=get_HXT_clock(e,o)
elseif s==1 then
h,n=get_PLL_clock(e,o)
elseif s==2 or s==3 then
h,n=get_HIRC_clock(e,o)
else
a="Touch key clock source select error (see CLKSEL1[17:16].TK_S).<br>"
end
if a==""then
local s=h/(d+1)
if s~=0 then
table.insert(o,"CLK_CLKDIV0")
i=string.format("Touch key clock frequency: <b>%sHz</b>, from %s.<br>",val2str(s),n)
local n
if r==0 then
n=s/ext.lshift(1,ext.rshift(ext.band(e["TK_TK_CTL"],48),4))
i=i..string.format("Touch key time-base clock frequency: <b>%sHz</b>.<br>",val2str(n))
else
if t~=nil then
t=t%8
local h
local r
local d=ext.band(e["TK_TK_CTL1"],ext.lshift(256,t))
if d~=0 then
if t<4 then
h="TK_TK_CTL2"
else
h="TK_TK_CTL3"
end
table.insert(o,h)
r=1+ext.band(ext.rshift(e[h],(t%4)*8),15)
n=s/r
i=i..string.format("Touch key %d/%d time-base clock frequency: <b>%sHz</b>.<br>",t+8,t,val2str(n))
else
a=string.format("Touch key %d/%d is always disabled for Touch Key scan. (see TK_CTL1[%d].EN_TK%d_%d).<br>",
t+8,t,t+8,t+8,t)
end
end
end
else
a="Touch key clock is not available, "..n..".<br>"
end
end
else
if r==0 then
a="Touch key scan disable (see TK_CTL[15].TK_EN).<br>"
else
a="Touch key scan disable (see TK_CTL1[31].TK_EN).<br>"
end
end
else
a="Touch Key clock is not available (see APBCLK[24].TK_EN).<br>"
end
if a~=""then
a="<font color=red>"..a.."</font>"
n["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
n["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
d,
a,
get_mfp_regs(e,u,l),
get_clk_informnation(e,o),
i)
end
function fill_Nano100_LCD(i,o,l,u,d)
local r=get_chip_info()["series_group"]
local s=""
local e=""
local n={}
i["highlight_text"]=d
i["normal_color"]=kColor_Invalid
i["highlight_color"]=kColor_LCD
i["pin_bg_color"]=kBgColor_LCD
i["direction"]=kPinDirection_PushPullOut
i["status"]=kPinStatus_Unknown
table.insert(n,"CLK_APBCLK")
if ext.band(o["CLK_APBCLK"],67108864)~=0 then
table.insert(n,"LCD_LCD_CTL")
if ext.band(o["LCD_LCD_CTL"],1)~=0 then
table.insert(n,"CLK_CLKSEL1")
local t=ext.rshift(ext.band(o["CLK_CLKSEL1"],262144),18)
local h
local i
if t==0 then
h,i=get_LXT_clock(o,n)
else
e="LCD clock source select error (see CLKSEL1[18].LCD_S).<br>"
end
if e==""then
local a
local t
if r==0 then
t=ext.rshift(ext.band(o["LCD_LCD_CTL"],56),3)
else
t=ext.rshift(ext.band(o["LCD_LCD_CTL"],112),4)
end
if t==0 then
a=32
elseif t==1 then
a=64
elseif t==2 then
a=96
elseif t==3 then
a=128
elseif t==4 then
a=192
elseif t==5 then
a=256
elseif t==6 then
a=384
elseif t==7 then
a=512
else
if r==0 then
e="LCD frequency select error (see LCD_CTL[5:3].FREQ).<br>"
else
e="LCD frequency select error (see LCD_CTL[6:4].FREQ).<br>"
end
end
if e==""then
local t=h/a
if t~=0 then
s=string.format("LCD clock frequency: <b>%sHz</b>, from %s.<br>",val2str(t),i)
else
e="LCD clock is not available, "..i..".<br>"
end
end
end
else
e="LCD controller operation disabled (see LCD_CTL[0].EN).<br>"
end
else
e="LCD clock is not available (see APBCLK[26].LCD_EN).<br>"
end
if e~=""then
e="<font color=red>"..e.."</font>"
i["pin_no_color"]=kBgColor_Error
end
if s~=""then
s="<b>Information</b><br>"..s
end
i["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
d,
e,
get_mfp_regs(o,l,u),
get_clk_informnation(o,n),
s)
end
function fill_Nano100_SC(n,t,m,c,u,e)
local d=get_chip_info()["series_group"]
local i=""
local o=""
local a={}
local r=0
n["highlight_text"]=u
n["normal_color"]=kColor_Invalid
n["highlight_color"]=kColor_SC
n["pin_bg_color"]=kBgColor_SC
n["direction"]=kPinDirection_PushPullOut
n["status"]=kPinStatus_Unknown
local s=0
if e==0 or e==1 then
s=ext.band(t["CLK_APBCLK"],ext.lshift(1073741824,e))
elseif e==2 then
s=ext.band(t["CLK_APBCLK"],128)
end
table.insert(a,"CLK_APBCLK")
if s~=0 then
local l=string.format("SC%d_SCx_CTL",e)
table.insert(a,l)
if ext.band(t[l],1)~=0 then
table.insert(a,"CLK_CLKSEL2")
local h=ext.rshift(ext.band(t["CLK_CLKSEL2"],786432),18)
local s
local n
if h==0 then
s,n=get_HXT_clock(t,a)
elseif h==1 then
s,n=get_PLL_clock(t,a)
elseif h==2 then
s,n=get_HIRC_clock(t,a)
elseif h==3 then
if d==2 then
s,n=get_HCLK_clock(t,a)
else
s,n=get_HIRC_clock(t,a)
end
end
if o==""then
local h
if e==0 then
h=ext.rshift(ext.band(t["CLK_CLKDIV0"],4026531840),28)
table.insert(a,"CLK_CLKDIV0")
elseif e==1 or e==2 then
h=ext.band(ext.rshift(t["CLK_CLKDIV1"],(e-1)*4),15)
table.insert(a,"CLK_CLKDIV1")
else
o=string.format("SC%d do not exist.<br>",e)
end
if o==""then
r=s/(h+1)
if r~=0 then
i=string.format("SC%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(r),n)
else
o=string.format("SC%d clock is not available, ",e)..n..".<br>"
end
end
end
else
o=string.format("SC%d engine disable (see %s[0].SC_CEN).<br>",e,l)
end
else
if e==0 or e==1 then
o=string.format("SC%d clock is not available (see APBCLK[%d].SC%d_EN).<br>",e,e+30,e)
elseif e==2 then
o="SC2 clock is not available (see APBCLK[7].SC2_EN).<br>"
end
end
if o==""then
if d==1 or d==2 then
local o=string.format("SC%d_SCx_UACTL",e)
local n=string.format("SC%d_SCx_ETUCR",e)
table.insert(a,o)
table.insert(a,n)
local a=ext.band(t[n],4095)
local a=r/(a+1)
if ext.band(t[o],1)~=0 then
i=string.format("SC%d is in <b>UART</b> mode.<br>",e)..i
..string.format("UART baudrate: <b>%d</b><br>",a)
else
i=string.format("SC%d is in <b>Smart Card</b> mode.<br>",e)..i
end
end
end
if o~=""then
o="<font color=red>"..o.."</font>"
n["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
n["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
u,
o,
get_mfp_regs(t,m,c),
get_clk_informnation(t,a),
i)
end
function fill_Nano100_MCLKO(a,n,e,e,s)
local i=""
local o=""
local h={}
a["highlight_text"]=s
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_CLK
a["pin_bg_color"]=kBgColor_CLK
a["direction"]=kPinDirection_PushPullOut
a["status"]=kPinStatus_Unknown
table.insert(h,"CLK_MCLKO")
if ext.band(n["CLK_MCLKO"],128)~=0 then
local t=ext.band(n["CLK_MCLKO"],63)
local e=""
if t==0 then
e="ISP"
elseif t==1 then
e="HIRC"
elseif t==2 then
e="HXT"
elseif t==3 then
e="LXT"
elseif t==4 then
e="LIRC"
elseif t==5 then
e="PLL output"
elseif t==6 then
e="PLL input"
elseif t==7 then
e="System Tick"
elseif t==8 then
e="HCLK"
elseif t==10 then
e="PCLK"
elseif t==32 then
e="TMR0"
elseif t==33 then
e="TMR1"
elseif t==34 then
e="UART0"
elseif t==35 then
e="USB"
elseif t==36 then
e="ADC"
elseif t==37 then
e="WDT"
elseif t==38 then
e="PWM0_CH01"
elseif t==39 then
e="PWM0_CH23"
elseif t==41 then
e="LCD"
elseif t==42 then
e="TK"
elseif t==56 then
e="TMR2"
elseif t==57 then
e="TMR3"
elseif t==58 then
e="UART1"
elseif t==59 then
e="PWM1_CH01"
elseif t==60 then
e="PWM1_CH23"
elseif t==61 then
e="I2S"
elseif t==62 then
e="SC0"
elseif t==63 then
e="SC1"
else
o="Module clock output source is not available (see MCLKO[5:0].MCLK_SEL).<br>"
end
if e~=""then
i=string.format("Module clock output source is from <b>%s</b> clock.<br>",e)
end
else
o="Module clock output disabled (see MCLKO[7].MCLK_EN).<br>"
end
if o~=""then
o="<font color=red>"..o.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
a["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s",
s,
o,
get_clk_informnation(n,h),
i)
end
function fill_Nano100_Normal(e,i,a,o,t)
local n=""
e["highlight_text"]=t
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Normal
e["pin_bg_color"]=kBgColor_Normal
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
n=t.."<br>"
if a==nil or o==nil then
e["information"]=string.format(
"<b>%s</b><br>",
t)
else
e["information"]=string.format(
"<b>%s</b><br><br>"..
"%s",
t,
get_mfp_regs(i,a,o))
end
end

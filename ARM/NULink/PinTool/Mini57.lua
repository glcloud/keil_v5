REG=
{
SYS_SYS_PDID=1342177280,
SYS_SYS_RSTSTS=1342177284,
SYS_SYS_IPRST0=1342177288,
SYS_SYS_IPRST1=1342177292,
SYS_SYS_WAIT=1342177296,
SYS_SYS_BODCTL=1342177304,
SYS_SYS_IVSCTL=1342177308,
SYS_SYS_PORCTL=1342177316,
SYS_SYS_GPA_MFP=1342177328,
SYS_SYS_GPB_MFP=1342177332,
SYS_SYS_GPC_MFP=1342177336,
SYS_SYS_GPD_MFP=1342177340,
SYS_SYS_IRCTCTL=1342177408,
SYS_SYS_IRCTIEN=1342177412,
SYS_SYS_IRCTISTS=1342177416,
SYS_SYS_REGLCTL=1342177536,
SYS_SYS_TSOFFSET=1342177556,
SCS_SYST_CTL=3758153744,
SCS_SYST_RVR=3758153748,
SCS_SYST_CVR=3758153752,
SCS_NVIC_ISER=3758153984,
SCS_NVIC_ICER=3758154112,
SCS_NVIC_ISPR=3758154240,
SCS_NVIC_ICPR=3758154368,
SCS_NVIC_IPR0=3758154752,
SCS_NVIC_IPR1=3758154756,
SCS_NVIC_IPR2=3758154760,
SCS_NVIC_IPR3=3758154764,
SCS_NVIC_IPR4=3758154768,
SCS_NVIC_IPR5=3758154772,
SCS_NVIC_IPR6=3758154776,
SCS_NVIC_IPR7=3758154780,
SCS_SCS_CPUID=3758157056,
SCS_SCS_ICSR=3758157060,
SCS_SCS_AIRCR=3758157068,
SCS_SCS_SCR=3758157072,
SCS_SCS_SHPR2=3758157084,
SCS_SCS_SHPR3=3758157088,
INT_INT_NMICTL=1342178176,
INT_INT_IRQSTS=1342178180,
CLK_CLK_PWRCTL=1342177792,
CLK_CLK_AHBCLK=1342177796,
CLK_CLK_APBCLK=1342177800,
CLK_CLK_CLKSEL0=1342177808,
CLK_CLK_CLKSEL1=1342177812,
CLK_CLK_CLKDIV=1342177824,
CLK_CLK_STATUS=1342177872,
CLK_CLK_CLKOCTL=1342177888,
FMC_FMC_ISPCTL=1342226432,
FMC_FMC_ISPADDR=1342226436,
FMC_FMC_ISPDAT=1342226440,
FMC_FMC_ISPCMD=1342226444,
FMC_FMC_ISPTRG=1342226448,
FMC_FMC_DFBA=1342226452,
FMC_FMC_ISPSTS=1342226496,
FMC_FMC_CRCSEED=1342226512,
FMC_FMC_CRCCV=1342226516,
GPIO_PA_MODE=1342193664,
GPIO_PA_DINOFF=1342193668,
GPIO_PA_DOUT=1342193672,
GPIO_PA_DATMSK=1342193676,
GPIO_PA_PIN=1342193680,
GPIO_PA_DBEN=1342193684,
GPIO_PA_INTTYPE=1342193688,
GPIO_PA_INTEN=1342193692,
GPIO_PA_INTSRC=1342193696,
GPIO_PA_SMTEN=1342193700,
GPIO_PA_SLEWCTL=1342193704,
GPIO_PA_PLEN=1342193708,
GPIO_PA_PHEN=1342193712,
GPIO_PB_MODE=1342193728,
GPIO_PB_DINOFF=1342193732,
GPIO_PB_DOUT=1342193736,
GPIO_PB_DATMSK=1342193740,
GPIO_PB_PIN=1342193744,
GPIO_PB_DBEN=1342193748,
GPIO_PB_INTTYPE=1342193752,
GPIO_PB_INTEN=1342193756,
GPIO_PB_INTSRC=1342193760,
GPIO_PB_SMTEN=1342193764,
GPIO_PB_SLEWCTL=1342193768,
GPIO_PB_PLEN=1342193772,
GPIO_PB_PHEN=1342193776,
GPIO_PC_MODE=1342193792,
GPIO_PC_DINOFF=1342193796,
GPIO_PC_DOUT=1342193800,
GPIO_PC_DATMSK=1342193804,
GPIO_PC_PIN=1342193808,
GPIO_PC_DBEN=1342193812,
GPIO_PC_INTTYPE=1342193816,
GPIO_PC_INTEN=1342193820,
GPIO_PC_INTSRC=1342193824,
GPIO_PC_SMTEN=1342193828,
GPIO_PC_SLEWCTL=1342193832,
GPIO_PC_PLEN=1342193836,
GPIO_PC_PHEN=1342193840,
GPIO_PD_MODE=1342193856,
GPIO_PD_DINOFF=1342193860,
GPIO_PD_DOUT=1342193864,
GPIO_PD_DATMSK=1342193868,
GPIO_PD_PIN=1342193872,
GPIO_PD_DBEN=1342193876,
GPIO_PD_INTTYPE=1342193880,
GPIO_PD_INTEN=1342193884,
GPIO_PD_INTSRC=1342193888,
GPIO_PD_SMTEN=1342193892,
GPIO_PD_SLEWCTL=1342193896,
GPIO_PD_PLEN=1342193900,
GPIO_PD_PHEN=1342193904,
GPIO_GPIO_DBCTL=1342194752,
GPIO_PA0_PDIO=1342195712,
GPIO_PA1_PDIO=1342195716,
GPIO_PA2_PDIO=1342195720,
GPIO_PA3_PDIO=1342195724,
GPIO_PA4_PDIO=1342195728,
GPIO_PA5_PDIO=1342195732,
GPIO_PB0_PDIO=1342195776,
GPIO_PB1_PDIO=1342195780,
GPIO_PB2_PDIO=1342195784,
GPIO_PB3_PDIO=1342195788,
GPIO_PB4_PDIO=1342195792,
GPIO_PC0_PDIO=1342195840,
GPIO_PC1_PDIO=1342195844,
GPIO_PC2_PDIO=1342195848,
GPIO_PC3_PDIO=1342195852,
GPIO_PC4_PDIO=1342195856,
GPIO_PD0_PDIO=1342195904,
GPIO_PD1_PDIO=1342195908,
GPIO_PD2_PDIO=1342195912,
GPIO_PD3_PDIO=1342195916,
GPIO_PD4_PDIO=1342195920,
GPIO_PD5_PDIO=1342195924,
GPIO_PD6_PDIO=1342195928,
TMR_TIMER0_CTL=1073807360,
TMR_TIMER0_CMP=1073807364,
TMR_TIMER0_INTSTS=1073807368,
TMR_TIMER0_CNT=1073807372,
TMR_TIMER0_CAP=1073807376,
TMR_TIMER0_EXTCTL=1073807380,
TMR_TIMER0_EINTSTS=1073807384,
TMR_TIMER1_CTL=1073807392,
TMR_TIMER1_CMP=1073807396,
TMR_TIMER1_INTSTS=1073807400,
TMR_TIMER1_CNT=1073807404,
TMR_TIMER1_CAP=1073807408,
TMR_TIMER1_EXTCTL=1073807412,
TMR_TIMER1_EINTSTS=1073807416,
TMR_TIMER_CCAPCTL=1073807424,
TMR_TIMER_CCAP0=1073807428,
TMR_TIMER_CCAP1=1073807432,
TMR_TIMER_CCAP2=1073807436,
TMR_TIMER_CCAP3=1073807440,
ECAP_ECAP_CNT=1075511296,
ECAP_ECAP_HLD0=1075511300,
ECAP_ECAP_HLD1=1075511304,
ECAP_ECAP_HLD2=1075511308,
ECAP_ECAP_CNTCMP=1075511312,
ECAP_ECAP_CTL0=1075511316,
ECAP_ECAP_CTL1=1075511320,
ECAP_ECAP_STS=1075511324,
EPWM_EPWM_NPCTL=1074003968,
EPWM_EPWM_CLKDIV=1074003972,
EPWM_EPWM_CTL=1074003976,
EPWM_EPWM_PERIOD=1074003980,
EPWM_EPWM_CMPDAT0=1074004004,
EPWM_EPWM_CMPDAT1=1074004008,
EPWM_EPWM_CMPDAT2=1074004012,
EPWM_EPWM_CMPDAT3=1074004016,
EPWM_EPWM_CMPDAT4=1074004020,
EPWM_EPWM_CMPDAT5=1074004024,
EPWM_EPWM_CNT=1074004028,
EPWM_EPWM_INTEN=1074004052,
EPWM_EPWM_INTSTS=1074004056,
EPWM_EPWM_RESDLY=1074004060,
EPWM_EPWM_BRKCTL=1074004064,
EPWM_EPWM_DTCTL=1074004068,
EPWM_EPWM_PHCHG=1074004088,
EPWM_EPWM_PHCHGNXT=1074004092,
EPWM_EPWM_PHCHGALT=1074004096,
EPWM_EPWM_IFA=1074004100,
BPWM_BPWM_CLKPSC=1075052544,
BPWM_BPWM_CLKDIV=1075052548,
BPWM_BPWM_CTL=1075052552,
BPWM_BPWM_PERIOD0=1075052556,
BPWM_BPWM_CMPDAT0=1075052560,
BPWM_BPWM_CNT0=1075052564,
BPWM_BPWM_PERIOD1=1075052568,
BPWM_BPWM_CMPDAT1=1075052572,
BPWM_BPWM_CNT1=1075052576,
BPWM_BPWM_INTEN=1075052608,
BPWM_BPWM_INTSTS=1075052612,
BPWM_BPWM_POEN=1075052668,
WDT_WDT_CTL=1073758208,
USPI0_USPI_CTL=1074200576,
USPI0_USPI_INTEN=1074200580,
USPI0_USPI_BRGEN=1074200584,
USPI0_USPI_DATIN0=1074200592,
USPI0_USPI_CTLIN0=1074200608,
USPI0_USPI_CLKIN=1074200616,
USPI0_USPI_LINECTL=1074200620,
USPI0_USPI_TXDAT=1074200624,
USPI0_USPI_RXDAT=1074200628,
USPI0_USPI_BUFCTL=1074200632,
USPI0_USPI_BUFSTS=1074200636,
USPI0_USPI_WKCTL=1074200660,
USPI0_USPI_WKSTS=1074200664,
USPI0_USPI_PROTCTL=1074200668,
USPI0_USPI_PROTIEN=1074200672,
USPI0_USPI_PROTSTS=1074200676,
USPI1_USPI_CTL=1075249152,
USPI1_USPI_INTEN=1075249156,
USPI1_USPI_BRGEN=1075249160,
USPI1_USPI_DATIN0=1075249168,
USPI1_USPI_CTLIN0=1075249184,
USPI1_USPI_CLKIN=1075249192,
USPI1_USPI_LINECTL=1075249196,
USPI1_USPI_TXDAT=1075249200,
USPI1_USPI_RXDAT=1075249204,
USPI1_USPI_BUFCTL=1075249208,
USPI1_USPI_BUFSTS=1075249212,
USPI1_USPI_WKCTL=1075249236,
USPI1_USPI_WKSTS=1075249240,
USPI1_USPI_PROTCTL=1075249244,
USPI1_USPI_PROTIEN=1075249248,
USPI1_USPI_PROTSTS=1075249252,
UI2C0_UI2C_CTL=1074200576,
UI2C0_UI2C_BRGEN=1074200584,
UI2C0_UI2C_LINECTL=1074200620,
UI2C0_UI2C_TXDAT=1074200624,
UI2C0_UI2C_RXDAT=1074200628,
UI2C0_UI2C_DEVADDR0=1074200644,
UI2C0_UI2C_ADDRMSK0=1074200652,
UI2C0_UI2C_WKCTL=1074200660,
UI2C0_UI2C_WKSTS=1074200664,
UI2C0_UI2C_PROTCTL=1074200668,
UI2C0_UI2C_PROTIEN=1074200672,
UI2C0_UI2C_PROTSTS=1074200676,
UI2C0_UI2C_TMCTL=1074200716,
UI2C1_UI2C_CTL=1075249152,
UI2C1_UI2C_BRGEN=1075249160,
UI2C1_UI2C_LINECTL=1075249196,
UI2C1_UI2C_TXDAT=1075249200,
UI2C1_UI2C_RXDAT=1075249204,
UI2C1_UI2C_DEVADDR0=1075249220,
UI2C1_UI2C_ADDRMSK0=1075249228,
UI2C1_UI2C_WKCTL=1075249236,
UI2C1_UI2C_WKSTS=1075249240,
UI2C1_UI2C_PROTCTL=1075249244,
UI2C1_UI2C_PROTIEN=1075249248,
UI2C1_UI2C_PROTSTS=1075249252,
UI2C1_UI2C_TMCTL=1075249292,
HDIV_HDIV_DIVIDEND=1342259200,
HDIV_HDIV_DIVISOR=1342259204,
HDIV_HDIV_QUOTIENT=1342259208,
HDIV_HDIV_REM=1342259212,
HDIV_HDIV_STATUS=1342259216,
ADC_ADC_DAT0=1074659328,
ADC_ADC_DAT1=1074659332,
ADC_ADC_CTL=1074659360,
ADC_ADC_TRGSOR=1074659364,
ADC_ADC_TRGDLY=1074659368,
ADC_ADC_SMPCNT=1074659372,
ADC_ADC_STATUS=1074659376,
ADC_ADC_WCMPCTL=1074659380,
ADC_ADC_WCMPDAT=1074659384,
ACMP_ACMP_CTL0=1074593792,
ACMP_ACMP_CTL1=1074593796,
ACMP_ACMP_STATUS=1074593800,
ACMP_ACMP_VREF=1074593804,
ACMP_ACMP_TRGDLY=1074593808,
PGA_PGA_CTL=1074724864,
USCI0_USCI_CTL=1074200576,
USCI0_USCI_BRGEN=1074200584,
USCI0_USCI_PROTCTL=1074200668,
USCI1_USCI_CTL=1075249152,
USCI1_USCI_BRGEN=1075249160,
USCI1_USCI_PROTCTL=1075249244,
}
g_Mini57_regs=REG
function read_Mini57_Registers(e,e,e,e)
local e={}
e["SYS_SYS_GPA_MFP"],
e["SYS_SYS_GPB_MFP"],
e["SYS_SYS_GPC_MFP"],
e["SYS_SYS_GPD_MFP"]=ice:ReadMem32(g_Mini57_regs.SYS_SYS_GPA_MFP,4)
e["SYS_SYS_IRCTCTL"],
e["CLK_CLK_PWRCTL"],
e["CLK_CLK_AHBCLK"],
e["CLK_CLK_APBCLK"]=ice:ReadMemMulti(g_Mini57_regs.SYS_SYS_IRCTCTL,
g_Mini57_regs.CLK_CLK_PWRCTL,
g_Mini57_regs.CLK_CLK_AHBCLK,
g_Mini57_regs.CLK_CLK_APBCLK)
e["CLK_CLK_CLKSEL0"],
e["CLK_CLK_CLKSEL1"],
e["CLK_CLK_CLKDIV"],
e["CLK_CLK_CLKOCTL"]=ice:ReadMemMulti(g_Mini57_regs.CLK_CLK_CLKSEL0,
g_Mini57_regs.CLK_CLK_CLKSEL1,
g_Mini57_regs.CLK_CLK_CLKDIV,
g_Mini57_regs.CLK_CLK_CLKOCTL)
e["GPIO_PA_MODE"],
e["GPIO_PA_DINOFF"],
e["GPIO_PA_DOUT"],
e["GPIO_PA_DATMSK"],
e["GPIO_PA_PIN"]=ice:ReadMem32(g_Mini57_regs.GPIO_PA_MODE,5)
e["GPIO_PB_MODE"],
e["GPIO_PB_DINOFF"],
e["GPIO_PB_DOUT"],
e["GPIO_PB_DATMSK"],
e["GPIO_PB_PIN"]=ice:ReadMem32(g_Mini57_regs.GPIO_PB_MODE,5)
e["GPIO_PC_MODE"],
e["GPIO_PC_DINOFF"],
e["GPIO_PC_DOUT"],
e["GPIO_PC_DATMSK"],
e["GPIO_PC_PIN"]=ice:ReadMem32(g_Mini57_regs.GPIO_PC_MODE,5)
e["GPIO_PD_MODE"],
e["GPIO_PD_DINOFF"],
e["GPIO_PD_DOUT"],
e["GPIO_PD_DATMSK"],
e["GPIO_PD_PIN"]=ice:ReadMem32(g_Mini57_regs.GPIO_PD_MODE,5)
e["GPIO_PA_SLEWCTL"],
e["GPIO_PB_SLEWCTL"],
e["GPIO_PC_SLEWCTL"],
e["GPIO_PD_SLEWCTL"]=ice:ReadMemMulti(g_Mini57_regs.GPIO_PA_SLEWCTL,
g_Mini57_regs.GPIO_PB_SLEWCTL,
g_Mini57_regs.GPIO_PC_SLEWCTL,
g_Mini57_regs.GPIO_PD_SLEWCTL)
e["TMR_TIMER0_CTL"],
e["TMR_TIMER1_CTL"]=ice:ReadMemMulti(g_Mini57_regs.TMR_TIMER0_CTL,
g_Mini57_regs.TMR_TIMER1_CTL)
e["BPWM_BPWM_CLKPSC"],
e["BPWM_BPWM_CLKDIV"],
e["BPWM_BPWM_CTL"],
e["ECAP_ECAP_CTL0"]=ice:ReadMemMulti(g_Mini57_regs.BPWM_BPWM_CLKPSC,
g_Mini57_regs.BPWM_BPWM_CLKDIV,
g_Mini57_regs.BPWM_BPWM_CTL,
g_Mini57_regs.ECAP_ECAP_CTL0)
e["EPWM_EPWM_CLKDIV"],
e["EPWM_EPWM_CTL"],
e["PGA_PGA_CTL"]=ice:ReadMemMulti(g_Mini57_regs.EPWM_EPWM_CLKDIV,
g_Mini57_regs.EPWM_EPWM_CTL,
g_Mini57_regs.PGA_PGA_CTL)
e["USCI0_USCI_CTL"],
e["USCI0_USCI_BRGEN"],
e["USCI1_USCI_CTL"],
e["USCI1_USCI_BRGEN"]=ice:ReadMemMulti(g_Mini57_regs.USCI0_USCI_CTL,
g_Mini57_regs.USCI0_USCI_BRGEN,
g_Mini57_regs.USCI1_USCI_CTL,
g_Mini57_regs.USCI1_USCI_BRGEN)
e["USCI0_USCI_PROTCTL"],
e["USCI1_USCI_PROTCTL"]=ice:ReadMemMulti(g_Mini57_regs.USCI0_USCI_PROTCTL,
g_Mini57_regs.USCI1_USCI_PROTCTL)
return e
end
local n={
[0]=kPinDirection_In,
[1]=kPinDirection_PushPullOut,
[2]=kPinDirection_OpenDrainOut,
[3]=kPinDirection_Bi,
}
local u={
[0]="INPUT",
[1]="OUTPUT",
[2]="Open-Drain",
[3]="Quasi-bidirectional",
}
function get_mfp_regs(e,t,a)
local t={"SYS_SYS_GP"..t.."_MFP"}
return reg2str("Multi-Function register",g_Mini57_regs,e,t)
end
function get_clk_informnation(t,e)
return reg2str("Clock setting registers",g_Mini57_regs,t,e)
end
function get_LIRC_clock(a,o)
local e
local t
table.insert(o,"CLK_CLK_PWRCTL")
local a=ext.band(a["CLK_CLK_PWRCTL"],8)
if a==0 then
e=0
t="invalid internal <b>10kHz</b> low speed oscillator clock (see CLK_PWRCTL[3].LIRCEN)"
else
e=10000
t="internal <b>10kHz</b> low speed oscillator clock"
end
return e,t
end
function get_HIRC_clock(a,o)
local e
local t
table.insert(o,"CLK_CLK_PWRCTL")
local i=ext.band(a["CLK_CLK_PWRCTL"],4)
if i==0 then
e=0
t="invalid internal <b>48MHz</b> high speed oscillator clock (see CLK_PWRCTL[2].HIRCEN)"
else
table.insert(o,"SYS_SYS_IRCTCTL")
local a=ext.band(a["SYS_SYS_IRCTCTL"],1)
if a==0 then
e=48000000
t="internal <b>48MHz</b> high speed oscillator clock"
else
e=48000000
t="internal <b>48MHz</b> high speed oscillator clock (auto trim)"
end
end
return e,t
end
function get_XTL_clock(o,a)
local e
local t
table.insert(a,"CLK_CLK_PWRCTL")
local a=ext.band(o["CLK_CLK_PWRCTL"],3)
if a==1 then
e=12000000
t="external <b>4~24M</b> high speed crystal clock, <font color=blue>when</font> external input clock is <font color=blue>12M</font>"
elseif a==2 then
e=32768
t="external <b>32.768kHz</b> low speed crystal clock"
else
e=0
t="invalid external high/low crystal clock (see CLK_PWRCTL[1:0].XTLEN)"
end
return e,t
end
function get_sys_clock(o,a,n)
local e
local t
table.insert(a,"CLK_CLK_CLKSEL0")
local i=ext.band(o["CLK_CLK_CLKSEL0"],3)
if i==0 then
e,t=get_XTL_clock(o,a)
elseif i==1 then
e,t=get_LIRC_clock(o,a)
elseif i==3 then
e,t=get_HIRC_clock(o,a)
else
e=0
t="invalid <b>"..n.."</b> clock (see CLK_CLKSEL0[1:0].HCLKSEL)"
return e,t
end
if e==0 then
t="<b>"..n.."</b> clock from "..t
else
table.insert(a,"CLK_CLK_CLKDIV")
local a=ext.band(o["CLK_CLK_CLKDIV"],15)
e=e/(a+1)
t=string.format("<b>%s</b> clock (<b>%sHz</b>), from %s",n,val2str(e),t)
end
return e,t
end
function get_HCLK_clock(e,t)
return get_sys_clock(e,t,"HCLK")
end
function get_PCLK_clock(e,t)
return get_sys_clock(e,t,"PCLK")
end
function fill_Mini57_GPIO(o,s,a,e,d)
if d==nil then d=string.format("P%s.%d",a,e)end
local t=s["GPIO_P"..a.."_MODE"]
local c=s["GPIO_P"..a.."_DINOFF"]
local r=s["GPIO_P"..a.."_DOUT"]
local h=s["GPIO_P"..a.."_DATMSK"]
local l=s["GPIO_P"..a.."_PIN"]
local m=s["GPIO_P"..a.."_SLEWCTL"]
o["highlight_text"]=d
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_GPIO
o["pin_bg_color"]=kBgColor_GPIO
local i=ext.band(ext.rshift(t,e*2),3)
o["direction"]=n[i]
if n[i]==kPinDirection_In
or n[i]==kPinDirection_Bi then
if ext.band(l,ext.lshift(1,e))==0 then
o["status"]=kPinStatus_Low
else
o["status"]=kPinStatus_High
end
else
if ext.band(h,ext.lshift(1,e))~=0 then
o["status"]=kPinStatus_Unknown
elseif ext.band(r,ext.lshift(1,e))==0 then
o["status"]=kPinStatus_Low
else
o["status"]=kPinStatus_High
end
end
local t=string.format("P%s.%d is in <b>%s</b> mode<br>",
a,e,u[i])
if n[i]==kPinDirection_In
or n[i]==kPinDirection_Bi then
if ext.band(l,ext.lshift(1,e))==0 then
t=t.."Pin input <b>low</b><br>"
else
t=t.."Pin input <b>high</b><br>"
end
end
if n[i]==kPinDirection_PushPullOut
or n[i]==kPinDirection_OpenDrainOut
or n[i]==kPinDirection_Bi then
if ext.band(h,ext.lshift(1,e))~=0 then
t=t.."Pin output <b>masked</b><br>"
elseif ext.band(r,ext.lshift(1,e))==0 then
t=t.."Pin output <b>low</b><br>"
else
t=t.."Pin output <b>high</b><br>"
end
end
if ext.band(c,ext.lshift(1,e+16))==0 then
t=t.."IO digital input path <b>enabled</b><br>"
else
t=t.."IO digital input path <b>disabled</b>(digital input tied to low)<br>"
end
local h=ext.band(ext.rshift(m,e),1)
if h==0 then
t=t.."IO output with <b>basic</b> slew rate<br>"
else
t=t.."IO output with <b>higher</b> slew rate<br>"
end
local h=""
if n[i]==kPinDirection_PushPullOut
or n[i]==kPinDirection_Bi then
if ext.band(r,ext.lshift(1,e))==0 and ext.band(l,ext.lshift(1,e))~=0 then
h=string.format("Leakage warning: GPIO%s_DOUT[%d] = 0, GPIO%s_PIN[%d] = 1<br>",a,e,a,e)
elseif ext.band(r,ext.lshift(1,e))~=0 and ext.band(l,ext.lshift(1,e))==0 then
h=string.format("Leakage warning: GPIO%s_DOUT[%d] = 1, GPIO%s_PIN[%d] = 0<br>",a,e,a,e)
end
end
if h~=""then
o["pin_no_color"]=kBgColor_Error
h="<font color=red>"..h.."</font>"
end
local i={
"GPIO_P"..a.."_MODE",
"GPIO_P"..a.."_DINOFF",
"GPIO_P"..a.."_DOUT",
"GPIO_P"..a.."_DATMSK",
"GPIO_P"..a.."_PIN",
"GPIO_P"..a.."_SLEWCTL"}
local i=reg2str("GPIO setting registers",g_Mini57_regs,s,i)
o["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s"..
"<b>Information</b><br>"..
"%s",
d,
h,
get_mfp_regs(s,a,e),
i,
t)
end
function fill_invalid_GPIO(e,i,a,t)
e["highlight_text"]=string.format("P%s.%d",a,t)
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Invalid
e["pin_bg_color"]=kBgColor_Invalid
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
e["pin_no_color"]=kBgColor_Error
local o="<font color=red>Undefined setting in Multi-Function registers for this pin.</font><br>"
e["information"]=string.format(
"<b>P%s.%d</b><br>%s<br>"..
"%s",
a,t,
o,
get_mfp_regs(i,a,t))
end
function fill_Mini57_ADC(t,a,r,d,h,e)
local i=""
local e=""
local o={}
t["highlight_text"]=h
t["normal_color"]=kColor_Invalid
t["highlight_color"]=kColor_ADC
t["pin_bg_color"]=kBgColor_ADC
t["direction"]=kPinDirection_Unknown
t["status"]=kPinStatus_Unknown
table.insert(o,"CLK_CLK_APBCLK")
local n=ext.band(ext.rshift(a["CLK_CLK_APBCLK"],28),1)
if n~=0 then
local n
local t
local s=ext.band(ext.rshift(a["CLK_CLK_CLKSEL1"],4),3)
if s==0 then
n,t=get_XTL_clock(a,o)
elseif s==2 then
n,t=get_HCLK_clock(a,o)
elseif s==3 then
n,t=get_HIRC_clock(a,o)
else
e="ADC clock is not available (see CLK_CLKSEL1[5:4].ADCSEL)"
end
if e==""then
local a=ext.band(ext.rshift(a["CLK_CLK_CLKDIV"],16),255)
local a=n/(a+1)
if a~=0 then
table.insert(o,"CLK_CLK_CLKDIV")
i=string.format("ADC clock frequency: <b>%sHz</b>, from %s.<br>",val2str(a),t)
else
e="ADC clock is not available, "..t..".<br>"
end
end
else
e="ADC clock is not available (see CLK_APBCLK[28].ADCCKEN).<br>"
end
if e~=""then
e="<font color=red>"..e.."</font>"
t["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
t["information"]=string.format(
"<b>%s</b><br>%s<br>%s%s%s",
h,
e,
get_mfp_regs(a,r,d),
get_clk_informnation(a,o),
i)
end
function fill_Mini57_ACMP(e,o,r,h,i,t)
local a=""
local t=""
local n={}
e["highlight_text"]=i
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_CMP
e["pin_bg_color"]=kBgColor_CMP
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
table.insert(n,"CLK_CLK_APBCLK")
local s=ext.band(ext.rshift(o["CLK_CLK_APBCLK"],30),1)
if s==0 then
t="ACMP clock is not available (see CLK_APBCLK[30].ACMPCKEN).<br>"
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
e["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
i,
t,
get_mfp_regs(o,r,h),
get_clk_informnation(o,n),
a)
end
function fill_Mini57_CLKO(a,e,r,d,h)
local i=""
local t=""
local o={}
a["highlight_text"]=h
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_CLK
a["pin_bg_color"]=kBgColor_CLK
a["direction"]=kPinDirection_PushPullOut
a["status"]=kPinStatus_Unknown
table.insert(o,"CLK_CLK_APBCLK")
local n=ext.band(ext.rshift(e["CLK_CLK_APBCLK"],6),1)
if n~=0 then
table.insert(o,"CLK_CLK_CLKOCTL")
local a=ext.band(ext.rshift(e["CLK_CLK_CLKOCTL"],4),1)
if a~=0 then
local a
local n
table.insert(o,"CLK_CLK_CLKSEL1")
local s=ext.band(ext.rshift(e["CLK_CLK_CLKSEL1"],30),3)
if s==0 then
a,n=get_XTL_clock(e,o)
elseif s==2 then
a,n=get_HCLK_clock(e,o)
elseif s==3 then
a,n=get_HIRC_clock(e,o)
else
t="CLKO clock is not available (see CLK_CLKSEL1[31:30].CLKOSEL)"
end
if t==""then
local t=a
local o=ext.band(ext.rshift(e["CLK_CLK_CLKOCTL"],5),1)
if o==0 then
local e=ext.band(e["CLK_CLK_CLKOCTL"],15)
t=a/ext.lshift(1,(e+1))
end
i=string.format("CLKO clock frequency: <b>%sHz</b>, from %s.<br>",val2str(t),n)
end
else
t="CLKO output function disabled (see CLK_CLKOCTL[4].CLKOEN).<br>"
end
else
t="CLKO clock is not available (see CLK_APBCLK[6].CLKOCKEN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
a["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
h,
t,
get_mfp_regs(e,r,d),
get_clk_informnation(e,o),
i)
end
function fill_Mini57_TM(a,t,d,l,r,e)
local o=""
local i=""
local n={}
a["highlight_text"]=r
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_TM
a["pin_bg_color"]=kBgColor_TM
a["direction"]=kPinDirection_Unknown
a["status"]=kPinStatus_Unknown
if e~=nil then
table.insert(n,"CLK_CLK_APBCLK")
local a=ext.band(ext.rshift(t["CLK_CLK_APBCLK"],e+2),1)
if a~=0 then
local a=string.format("TMR_TIMER%d_CTL",e)
table.insert(n,a)
local a=ext.band(ext.rshift(t[a],24),1)
if a~=0 then
o=string.format("TMR%d external counting pin function enabled.<br>",e)
else
local s
local a
table.insert(n,"CLK_CLK_CLKSEL1")
local h=ext.band(ext.rshift(t["CLK_CLK_CLKSEL1"],8+e*4),7)
if h==0 then
s,a=get_XTL_clock(t,n)
elseif h==1 then
s,a=get_LIRC_clock(t,n)
elseif h==2 then
s,a=get_HCLK_clock(t,n,1)
elseif h==3 then
o=string.format("TMR%d clock source is from external clock T%d pin.<br>",e,e)
elseif h==7 then
s,a=get_HIRC_clock(t,n)
else
i=string.format("TMR%d clock source is undefined (see CLK_CLKSEL1[%d:%d].TMR%dSEL).<br>",
e,8+e*4+2,8+e*4,e)
end
if i==""and o==""then
if s~=0 then
o=string.format("TMR%d clock frequency: <b>%sHz</b>, from %s.<br>",
e,val2str(s),a)
else
i=string.format("TMR%d clock is not available, %s.<br>",e,a)
end
end
end
else
i=string.format("TMR%d clock is not available (see CLK_APBCLK[%d].TMR%dCKEN).<br>",e,e+2,e)
end
end
if i~=""then
i="<font color=red>"..i.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if o~=""then
o="<b>Information</b><br>"..o
end
a["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
r,
i,
get_mfp_regs(t,d,l),
get_clk_informnation(t,n),
o)
end
function fill_Mini57_BPWM(a,i,d,r,h,t,e)
local o=""
local t=""
local n={}
a["highlight_text"]=h
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_PWM
a["pin_bg_color"]=kBgColor_PWM
a["direction"]=kPinDirection_Unknown
a["status"]=kPinStatus_Unknown
table.insert(n,"CLK_CLK_APBCLK")
local s=ext.band(ext.rshift(i["CLK_CLK_APBCLK"],23),1)
if s~=0 then
local a
local s
a,s=get_HCLK_clock(i,n)
table.insert(n,"BPWM_BPWM_CTL")
local h=ext.band(ext.rshift(i["BPWM_BPWM_CTL"],e*8),1)
if h==0 then
t=string.format("BPWM timer%d stops running.<br>",e)
else
if a==0 then
t=string.format("BPWM clock is not available, %s.<br>",s)
else
table.insert(n,"BPWM_BPWM_CLKPSC")
table.insert(n,"BPWM_BPWM_CLKDIV")
local n=ext.band(i["BPWM_BPWM_CLKPSC"],255)
local i=ext.band(ext.rshift(i["BPWM_BPWM_CLKDIV"],e*4),7)
local i=({2,4,8,16,1,0,0,0})[i+1]
if n==0 then
t=string.format("BPWM timer%d will be stopped since BPWM_CLKPSC[8:0].CLKPSC01 = 0<br>",
e)
elseif i==0 then
t=string.format("BPWM timer%d is not available (see BPWM_CLKDIV[%d:%d].CLKDIV%d).<br>",
e,e*4+2,e*4,e)
else
a=a/(n+1)
o=string.format("BPWM clock frequency: <b>%sHz</b> (Pre-Scaled), from %s.<br>",
val2str(a),s)
local t=a/i
o=o..string.format("BPWM timer%d frequency: <b>%sHz</b>",
e,val2str(t))
end
end
end
else
t="BPWM clock is not available (see CLK_APBCLK[23].BPWMCKEN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if o~=""then
o="<b>Information</b><br>"..o
end
a["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
h,
t,
get_mfp_regs(i,d,r),
get_clk_informnation(i,n),
o)
end
function fill_Mini57_EPWM(e,a,r,d,s,t,h)
local o=""
local t=""
local i={}
e["highlight_text"]=s
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_PWM
e["pin_bg_color"]=kBgColor_PWM
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
table.insert(i,"CLK_CLK_APBCLK")
local n=ext.band(ext.rshift(a["CLK_CLK_APBCLK"],20),1)
if n~=0 then
local e
local n
e,n=get_HCLK_clock(a,i)
table.insert(i,"EPWM_EPWM_CTL")
local s=ext.band(ext.rshift(a["EPWM_EPWM_CTL"],h),1)
if s==0 then
t=string.format("EPWM timer%d stops running.<br>",h)
else
if e==0 then
t=string.format("EPWM clock is not available, %s.<br>",n)
else
table.insert(i,"EPWM_EPWM_CLKDIV")
local t=ext.band(a["EPWM_EPWM_CLKDIV"],15)
e=e/ext.lshift(1,t)
o=string.format("EPWM clock frequency: <b>%sHz</b>, from %s.<br>",
val2str(e),n)
end
end
else
t="EPWM clock is not available (see CLK_APBCLK[20].EPWMCKEN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
if o~=""then
o="<b>Information</b><br>"..o
end
e["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
s,
t,
get_mfp_regs(a,r,d),
get_clk_informnation(a,i),
o)
end
function fill_Mini57_ECAP(e,o,r,h,s)
local a=""
local t=""
local i={}
e["highlight_text"]=s
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_CAP
e["pin_bg_color"]=kBgColor_CAP
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
table.insert(i,"CLK_CLK_APBCLK")
local n=ext.band(ext.rshift(o["CLK_CLK_APBCLK"],8),1)
if n~=0 then
local n
local e
n,e=get_HCLK_clock(o,i)
if n~=0 then
table.insert(i,"ECAP_ECAP_CTL0")
local o=ext.band(ext.rshift(o["ECAP_ECAP_CTL0"],29),1)
if o~=0 then
a=string.format("ECAP clock frequency: <b>%sHz</b>, from %s.<br>",val2str(n),e)
else
t="Input Capture function disabled (see ECAP_CTL0[29].CAPEN).<br>"
end
else
t=string.format("ECAP clock is not available, %s.<br>",e)
end
else
t="ECAP clock is not available (see CLK_APBCLK[8].ECAPCKEN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
e["information"]=string.format(
"<b>%s</b><br>%s<br>%s%s%s",
s,
t,
get_mfp_regs(o,r,h),
get_clk_informnation(o,i),
a)
end
function fill_Mini57_PGA(e,o,r,h,s)
local a=""
local t=""
local i={}
e["highlight_text"]=s
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Normal
e["pin_bg_color"]=kBgColor_Normal
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
table.insert(i,"CLK_CLK_APBCLK")
local n=ext.band(ext.rshift(o["CLK_CLK_APBCLK"],12),1)
if n~=0 then
local n
local e
n,e=get_HCLK_clock(o,i)
if n~=0 then
table.insert(i,"PGA_PGA_CTL")
local o=ext.band(o["PGA_PGA_CTL"],1)
if o~=0 then
a=string.format("PGA clock frequency: <b>%sHz</b>, from %s.<br>",val2str(n),e)
else
t="Programmable gain amplifier disabled (see PGA_CTL[0].PGAEN).<br>"
end
else
t=string.format("PGA clock is not available, %s.<br>",e)
end
else
t="PGA clock is not available (see CLK_APBCLK[12].PGACKEN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
e["information"]=string.format(
"<b>%s</b><br>%s<br>%s%s%s",
s,
t,
get_mfp_regs(o,r,h),
get_clk_informnation(o,i),
a)
end
function fill_Mini57_USCI(i,a,p,y,m,e)
local t=""
local o=""
local n={}
i["highlight_text"]=m
i["normal_color"]=kColor_Invalid
i["highlight_color"]=kColor_USCI
i["pin_bg_color"]=kBgColor_USCI
i["direction"]=kPinDirection_Unknown
i["status"]=kPinStatus_Unknown
table.insert(n,"CLK_CLK_APBCLK")
local s=ext.band(ext.rshift(a["CLK_CLK_APBCLK"],24+e),1)
if s~=0 then
local i=string.format("USCI%d_USCI_CTL",e)
table.insert(n,i)
local h=ext.band(a[i],7)
local i=string.format("USCI%d_USCI_BRGEN",e)
table.insert(n,i)
local u=ext.band(a[i],1)
local l=ext.band(ext.rshift(a[i],1),1)
local r=ext.band(ext.rshift(a[i],2),3)
local m=ext.band(ext.rshift(a[i],10),31)
local w=ext.band(ext.rshift(a[i],8),3)
local f=ext.band(ext.rshift(a[i],16),1023)
local i=string.format("USCI%d_USCI_PROTCTL",e)
table.insert(n,i)
local d=ext.band(ext.rshift(a[i],31),1)
local c=ext.band(a[i],1)
local s
local i
if u==0 then
s,i=get_HCLK_clock(a,n)
else
s,i=get_XTL_clock(a,n)
end
local n=s
local a=n/2
local l=(l==0)and n or a
local u=l/(f+1)
local f=u/2
local a
if r==0 then
a=u
elseif r==1 then
a=l
elseif r==2 then
a=f
elseif r==3 then
a=n
end
if s~=0 then
if h==0 then
t=string.format("USCI%d is in idle state.<br>",e)
elseif h==1 then
if c==0 then
t=string.format("USCI%d is in <b>SPI master</b> mode.<br>",e)
else
t=string.format("USCI%d is in <b>SPI slave</b> mode.<br>",e)
end
if d==0 then
o=string.format("SPI protocol disabled (see USCI%d_USCI_PROTCTL[31].PROTEN)<br>",e)
elseif c==0 then
local a=a/2
t=t..string.format("USPI%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(a),i)
end
elseif h==2 then
t=string.format("USCI%d is in <b>UART</b> mode.<br>",e)
if d==0 then
o=string.format("UART protocol disabled (see USCI%d_USCI_PROTCTL[31].PROTEN)<br>",e)
else
t=t..string.format("UUART%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(s),i)
local e=a/(m+1)/(w+1)
t=t..string.format("UART baudrate: <b>%d</b><br>",e)
end
elseif h==4 then
t=string.format("USCI%d is in <b>I2C</b> mode.<br>",e)
if d==0 then
o=string.format("I2C protocol disabled (see USCI%d_USCI_PROTCTL[31].PROTEN)<br>",e)
else
local a=a/2
t=t..string.format("UI2C%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(a),i)
end
else
o=string.format("Undefined function mode (see USCI_CTL[2:0].FUNMODE).<br>")
end
else
o=string.format("USCI%d clock is not available, %s.<br>",e,i)
end
else
o=string.format("USCI%d clock is not available (see CLK_APBCLK[%d].USCI%dCKEN).<br>",e,24+e,e)
end
if o~=""then
o="<font color=red>"..o.."</font>"
i["pin_no_color"]=kBgColor_Error
end
if t~=""then
t="<b>Information</b><br>"..t
end
i["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
m,
o,
get_mfp_regs(a,p,y),
get_clk_informnation(a,n),
t)
end
function fill_Mini57_USCI_IO(e,o,i,a)
local t=string.format("USCI%d_USCI_CTL",i)
local t=ext.band(o[t],7)
if t==0 then
elseif t==1 then
local t=string.format("USCI%d_USCI_PROTCTL",i)
local t=ext.band(o[t],1)
if t==0 then
if a==0 then
e["direction"]=kPinDirection_PushPullOut
else
e["direction"]=kPinDirection_In
end
else
if a==0 then
e["direction"]=kPinDirection_In
else
e["direction"]=kPinDirection_PushPullOut
end
end
elseif t==2 then
if a==0 then
e["direction"]=kPinDirection_In
else
e["direction"]=kPinDirection_PushPullOut
end
elseif t==4 then
end
end
function fill_Mini57_UART(i,n,o,t,a,e)
fill_Mini57_USCI(i,n,o,t,a,e)
end
function fill_Mini57_UART_IO(e,t,o,a)
fill_Mini57_USCI_IO(e,t,o,a and 1 or 0)
end
function fill_Mini57_SPI(i,n,o,a,e,t)
fill_Mini57_USCI(i,n,o,a,e,t)
end
function fill_Mini57_SPI_IO(o,a,e,t)
fill_Mini57_USCI_IO(o,a,e,t and 1 or 0)
end
function fill_Mini57_I2C(o,e,t,a,i,n)
fill_Mini57_USCI(o,e,t,a,i,n)
end
function fill_Mini57_CCAP(e,o,i,a,t)
fill_Mini57_TM(e,o,i,a,t)
end
function fill_Mini57_Normal(e,i,o,a,t)
e["highlight_text"]=t
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Normal
e["pin_bg_color"]=kBgColor_Normal
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
if o==nil or a==nil then
e["information"]=string.format(
"<b>%s</b><br>",
t)
else
e["information"]=string.format(
"<b>%s</b><br><br>"..
"%s",
t,
get_mfp_regs(i,o,a))
end
end

REG=
{
GCR_PDID=1342177280,
GCR_RSTSRC=1342177284,
GCR_IPRSTC1=1342177288,
GCR_IPRSTC2=1342177292,
GCR_ITESTCR=1342177300,
GCR_BODCR=1342177304,
GCR_LDOCR=1342177308,
GCR_PORCR=1342177316,
GCR_P0_MFP=1342177328,
GCR_P1_MFP=1342177332,
GCR_P2_MFP=1342177336,
GCR_P3_MFP=1342177340,
GCR_P4_MFP=1342177344,
GCR_P5_MFP=1342177348,
GCR_IRCTRIMCTL=1342177408,
GCR_IRCTRIMIEN=1342177412,
GCR_IRCTRIMINT=1342177416,
GCR_RegLockAddr=1342177536,
GCR_RCADJ=1342177552,
SCS_SYST_CSR=3758153744,
SCS_SYST_RVR=3758153748,
SCS_SYST_CVR=3758153752,
SCS_NVIC_ISER=3758153984,
SCS_NVIC_ICER=3758154112,
SCS_NVIC_ISPR=3758154240,
SCS_NVIC_ICPR=3758154368,
SCS_NVIC_IPR0=3758154752,
SCS_NVIC_IPR1=3758154756,
SCS_NVIC_IPR2=3758154760,
SCS_NVIC_IPR3=3758154764,
SCS_NVIC_IPR4=3758154768,
SCS_NVIC_IPR5=3758154772,
SCS_NVIC_IPR6=3758154776,
SCS_NVIC_IPR7=3758154780,
SCS_CPUID=3758157056,
SCS_ICSR=3758157060,
SCS_AIRCR=3758157068,
SCS_SCR=3758157072,
SCS_SHPR2=3758157084,
SCS_SHPR3=3758157088,
INT_IRQ0_SRC=1342178048,
INT_IRQ1_SRC=1342178052,
INT_IRQ2_SRC=1342178056,
INT_IRQ3_SRC=1342178060,
INT_IRQ4_SRC=1342178064,
INT_IRQ5_SRC=1342178068,
INT_IRQ6_SRC=1342178072,
INT_IRQ7_SRC=1342178076,
INT_IRQ8_SRC=1342178080,
INT_IRQ9_SRC=1342178084,
INT_IRQ12_SRC=1342178096,
INT_IRQ14_SRC=1342178104,
INT_IRQ16_SRC=1342178112,
INT_IRQ17_SRC=1342178116,
INT_IRQ18_SRC=1342178120,
INT_IRQ25_SRC=1342178148,
INT_IRQ28_SRC=1342178160,
INT_IRQ29_SRC=1342178164,
INT_NMI_SEL=1342178176,
INT_MCU_IRQ=1342178180,
CLK_PWRCON=1342177792,
CLK_AHBCLK=1342177796,
CLK_APBCLK=1342177800,
CLK_CLKSTATUS=1342177804,
CLK_CLKSEL0=1342177808,
CLK_CLKSEL1=1342177812,
CLK_CLKSEL2=1342177820,
CLK_CLKDIV=1342177816,
CLK_PLLCTL=1342177824,
CLK_FRQDIV=1342177828,
GPIO_P0_PMD=1342193664,
GPIO_P0_OFFD=1342193668,
GPIO_P0_DOUT=1342193672,
GPIO_P0_DMASK=1342193676,
GPIO_P0_PIN=1342193680,
GPIO_P0_DBEN=1342193684,
GPIO_P0_IMD=1342193688,
GPIO_P0_IEN=1342193692,
GPIO_P0_ISRC=1342193696,
GPIO_P1_PMD=1342193728,
GPIO_P1_OFFD=1342193732,
GPIO_P1_DOUT=1342193736,
GPIO_P1_DMASK=1342193740,
GPIO_P1_PIN=1342193744,
GPIO_P1_DBEN=1342193748,
GPIO_P1_IMD=1342193752,
GPIO_P1_IEN=1342193756,
GPIO_P1_ISRC=1342193760,
GPIO_P2_PMD=1342193792,
GPIO_P2_OFFD=1342193796,
GPIO_P2_DOUT=1342193800,
GPIO_P2_DMASK=1342193804,
GPIO_P2_PIN=1342193808,
GPIO_P2_DBEN=1342193812,
GPIO_P2_IMD=1342193816,
GPIO_P2_IEN=1342193820,
GPIO_P2_ISRC=1342193824,
GPIO_P3_PMD=1342193856,
GPIO_P3_OFFD=1342193860,
GPIO_P3_DOUT=1342193864,
GPIO_P3_DMASK=1342193868,
GPIO_P3_PIN=1342193872,
GPIO_P3_DBEN=1342193876,
GPIO_P3_IMD=1342193880,
GPIO_P3_IEN=1342193884,
GPIO_P3_ISRC=1342193888,
GPIO_P4_PMD=1342193920,
GPIO_P4_OFFD=1342193924,
GPIO_P4_DOUT=1342193928,
GPIO_P4_DMASK=1342193932,
GPIO_P4_PIN=1342193936,
GPIO_P4_DBEN=1342193940,
GPIO_P4_IMD=1342193944,
GPIO_P4_IEN=1342193948,
GPIO_P4_ISRC=1342193952,
GPIO_P5_PMD=1342193984,
GPIO_P5_OFFD=1342193988,
GPIO_P5_DOUT=1342193992,
GPIO_P5_DMASK=1342193996,
GPIO_P5_PIN=1342194000,
GPIO_P5_DBEN=1342194004,
GPIO_P5_IMD=1342194008,
GPIO_P5_IEN=1342194012,
GPIO_P5_ISRC=1342194016,
GPIO_DBNCECON=1342194048,
GPIO_P00_DOUT=1342194176,
GPIO_P01_DOUT=1342194180,
GPIO_P04_DOUT=1342194192,
GPIO_P05_DOUT=1342194196,
GPIO_P06_DOUT=1342194200,
GPIO_P07_DOUT=1342194204,
GPIO_P10_DOUT=1342194208,
GPIO_P12_DOUT=1342194216,
GPIO_P13_DOUT=1342194220,
GPIO_P14_DOUT=1342194224,
GPIO_P15_DOUT=1342194228,
GPIO_P22_DOUT=1342194248,
GPIO_P23_DOUT=1342194252,
GPIO_P24_DOUT=1342194256,
GPIO_P25_DOUT=1342194260,
GPIO_P26_DOUT=1342194264,
GPIO_P30_DOUT=1342194272,
GPIO_P31_DOUT=1342194276,
GPIO_P32_DOUT=1342194280,
GPIO_P34_DOUT=1342194288,
GPIO_P35_DOUT=1342194292,
GPIO_P36_DOUT=1342194296,
GPIO_P46_DOUT=1342194328,
GPIO_P47_DOUT=1342194332,
GPIO_P50_DOUT=1342194336,
GPIO_P51_DOUT=1342194340,
GPIO_P52_DOUT=1342194344,
GPIO_P53_DOUT=1342194348,
GPIO_P54_DOUT=1342194352,
GPIO_P55_DOUT=1342194356,
I2C0_I2C_CTL=1073872896,
I2C0_I2C_ADDR0=1073872900,
I2C0_I2C_DAT=1073872904,
I2C0_I2C_STATUS=1073872908,
I2C0_I2C_CLKDIV=1073872912,
I2C0_I2C_TOCTL=1073872916,
I2C0_I2C_ADDR1=1073872920,
I2C0_I2C_ADDR2=1073872924,
I2C0_I2C_ADDR3=1073872928,
I2C0_I2C_ADDRMSK0=1073872932,
I2C0_I2C_ADDRMSK1=1073872936,
I2C0_I2C_ADDRMSK2=1073872940,
I2C0_I2C_ADDRMSK3=1073872944,
I2C0_I2C_CTL1=1073872956,
I2C0_I2C_STATUS1=1073872960,
I2C1_I2C_CTL=1074921472,
I2C1_I2C_ADDR0=1074921476,
I2C1_I2C_DAT=1074921480,
I2C1_I2C_STATUS=1074921484,
I2C1_I2C_CLKDIV=1074921488,
I2C1_I2C_TOCTL=1074921492,
I2C1_I2C_ADDR1=1074921496,
I2C1_I2C_ADDR2=1074921500,
I2C1_I2C_ADDR3=1074921504,
I2C1_I2C_ADDRMSK0=1074921508,
I2C1_I2C_ADDRMSK1=1074921512,
I2C1_I2C_ADDRMSK2=1074921516,
I2C1_I2C_ADDRMSK3=1074921520,
I2C1_I2C_CTL1=1074921532,
I2C1_I2C_STATUS1=1074921536,
PWM_PPR=1074003968,
PWM_CSR=1074003972,
PWM_PCR=1074003976,
PWM_CNR0=1074003980,
PWM_CNR1=1074003984,
PWM_CNR2=1074003988,
PWM_CNR3=1074003992,
PWM_CNR4=1074003996,
PWM_CNR5=1074004000,
PWM_CMR0=1074004004,
PWM_CMR1=1074004008,
PWM_CMR2=1074004012,
PWM_CMR3=1074004016,
PWM_CMR4=1074004020,
PWM_CMR5=1074004024,
PWM_PDR0=1074004028,
PWM_PDR1=1074004032,
PWM_PDR2=1074004036,
PWM_PDR3=1074004040,
PWM_PDR4=1074004044,
PWM_PDR5=1074004048,
PWM_PIER=1074004052,
PWM_PIIR=1074004056,
PWM_POE=1074004060,
PWM_PFBCON=1074004064,
PWM_PDZIR=1074004068,
SPI_SPI_CNTRL=1073938432,
SPI_SPI_DIVIDER=1073938436,
SPI_SPI_SSR=1073938440,
SPI_SPI_Rx0=1073938448,
SPI_SPI_Rx1=1073938452,
SPI_SPI_Tx0=1073938464,
SPI_SPI_Tx1=1073938468,
SPI_SPI_VARCLK=1073938484,
SPI_SPI_CNTRL2=1073938492,
SPI_SPI_FIFO_CTL=1073938496,
TMR01_TCSR0=1073807360,
TMR01_TCMPR0=1073807364,
TMR01_TISR0=1073807368,
TMR01_TDR0=1073807372,
TMR01_TCAP0=1073807376,
TMR01_TEXCON0=1073807380,
TMR01_TEXISR0=1073807384,
TMR01_TCSR1=1073807392,
TMR01_TCMPR1=1073807396,
TMR01_TISR1=1073807400,
TMR01_TDR1=1073807404,
TMR01_TCAP1=1073807408,
TMR01_TEXCON1=1073807412,
TMR01_TEXISR1=1073807416,
WDT_WTCR=1073758208,
UART0_UART_DAT=1074069504,
UART0_UART_INTEN=1074069508,
UART0_UART_FIFO=1074069512,
UART0_UART_LINE=1074069516,
UART0_UART_MODEM=1074069520,
UART0_UART_MODEMSTS=1074069524,
UART0_UART_FIFOSTS=1074069528,
UART0_UART_INTSTS=1074069532,
UART0_UART_TOUT=1074069536,
UART0_UART_BAUD=1074069540,
UART0_UART_IRDA=1074069544,
UART0_UART_ALTCTL=1074069548,
UART0_UART_FUNCSEL=1074069552,
UART1_UART_DAT=1075118080,
UART1_UART_INTEN=1075118084,
UART1_UART_FIFO=1075118088,
UART1_UART_LINE=1075118092,
UART1_UART_MODEM=1075118096,
UART1_UART_MODEMSTS=1075118100,
UART1_UART_FIFOSTS=1075118104,
UART1_UART_INTSTS=1075118108,
UART1_UART_TOUT=1075118112,
UART1_UART_BAUD=1075118116,
UART1_UART_IRDA=1075118120,
UART1_UART_ALTCTL=1075118124,
UART1_UART_FUNCSEL=1075118128,
ADC_ADDR=1074659328,
ADC_ADCR=1074659360,
ADC_ADCHER=1074659364,
ADC_ADCMPR0=1074659368,
ADC_ADCMPR1=1074659372,
ADC_ADSR=1074659376,
FMC_ISPCON=1342226432,
FMC_ISPADR=1342226436,
FMC_ISPDAT=1342226440,
FMC_ISPCMD=1342226444,
FMC_ISPTRG=1342226448,
FMC_DFBA=1342226452,
FMC_ICPCON=1342226460,
FMC_RMPCON=1342226464,
FMC_ICECON=1342226468,
CMP_CMP0CR=1074593792,
CMP_CMP1CR=1074593796,
CMP_CMPSR=1074593800,
CMP_CMPRVCR=1074593804,
}
g_Mini51_regs=REG
function read_Mini51_Registers()
local t=get_chip_info()["series_group"]
local e={}
e["GCR_P0_MFP"],
e["GCR_P1_MFP"],
e["GCR_P2_MFP"],
e["GCR_P3_MFP"],
e["GCR_P4_MFP"],
e["GCR_P5_MFP"]=ice:ReadMem32(g_Mini51_regs.GCR_P0_MFP,6)
e["GCR_IRCTRIMCTL"]=ice:ReadMem32(g_Mini51_regs.GCR_IRCTRIMCTL)
e["GPIO_P0_PMD"],
e["GPIO_P0_OFFD"],
e["GPIO_P0_DOUT"],
e["GPIO_P0_DMASK"],
e["GPIO_P0_PIN"]=ice:ReadMem32(g_Mini51_regs.GPIO_P0_PMD,5)
e["GPIO_P1_PMD"],
e["GPIO_P1_OFFD"],
e["GPIO_P1_DOUT"],
e["GPIO_P1_DMASK"],
e["GPIO_P1_PIN"]=ice:ReadMem32(g_Mini51_regs.GPIO_P1_PMD,5)
e["GPIO_P2_PMD"],
e["GPIO_P2_OFFD"],
e["GPIO_P2_DOUT"],
e["GPIO_P2_DMASK"],
e["GPIO_P2_PIN"]=ice:ReadMem32(g_Mini51_regs.GPIO_P2_PMD,5)
e["GPIO_P3_PMD"],
e["GPIO_P3_OFFD"],
e["GPIO_P3_DOUT"],
e["GPIO_P3_DMASK"],
e["GPIO_P3_PIN"]=ice:ReadMem32(g_Mini51_regs.GPIO_P3_PMD,5)
e["GPIO_P4_PMD"],
e["GPIO_P4_OFFD"],
e["GPIO_P4_DOUT"],
e["GPIO_P4_DMASK"],
e["GPIO_P4_PIN"]=ice:ReadMem32(g_Mini51_regs.GPIO_P4_PMD,5)
e["GPIO_P5_PMD"],
e["GPIO_P5_OFFD"],
e["GPIO_P5_DOUT"],
e["GPIO_P5_DMASK"],
e["GPIO_P5_PIN"]=ice:ReadMem32(g_Mini51_regs.GPIO_P5_PMD,5)
e["CLK_PWRCON"],
e["CLK_AHBCLK"],
e["CLK_APBCLK"],
e["CLK_CLKSTATUS"],
e["CLK_CLKSEL0"],
e["CLK_CLKSEL1"],
e["CLK_CLKDIV"],
e["CLK_CLKSEL2"],
e["CLK_PLLCTL"],
e["CLK_FRQDIV"]=ice:ReadMem32(g_Mini51_regs.CLK_PWRCON,10)
e["I2C0_I2C_CTL"],
e["I2C0_I2C_CLKDIV"],
e["PWM_PPR"],
e["PWM_CSR"]=ice:ReadMemMulti(g_Mini51_regs.I2C0_I2C_CTL,
g_Mini51_regs.I2C0_I2C_CLKDIV,
g_Mini51_regs.PWM_PPR,
g_Mini51_regs.PWM_CSR)
e["SPI_SPI_CNTRL"],
e["SPI_SPI_CNTRL2"],
e["SPI_SPI_DIVIDER"],
e["UART0_UART_BAUD"]=ice:ReadMemMulti(g_Mini51_regs.SPI_SPI_CNTRL,
g_Mini51_regs.SPI_SPI_CNTRL2,
g_Mini51_regs.SPI_SPI_DIVIDER,
g_Mini51_regs.UART0_UART_BAUD)
if t==2 then
e["UART1_UART_BAUD"],
e["ADC_ADCHER"]=ice:ReadMemMulti(g_Mini51_regs.UART1_UART_BAUD,
g_Mini51_regs.ADC_ADCHER)
elseif t==3 then
e["UART1_UART_BAUD"],
e["I2C1_I2C_CTL"],
e["I2C1_I2C_CLKDIV"]=ice:ReadMemMulti(g_Mini51_regs.UART1_UART_BAUD,
g_Mini51_regs.I2C1_I2C_CTL,
g_Mini51_regs.I2C1_I2C_CLKDIV)
end
e["TMR01_TCSR0"],
e["TMR01_TCSR1"]=ice:ReadMemMulti(g_Mini51_regs.TMR01_TCSR0,
g_Mini51_regs.TMR01_TCSR1)
return e
end
local n={
[0]=kPinDirection_In,
[1]=kPinDirection_PushPullOut,
[2]=kPinDirection_OpenDrainOut,
[3]=kPinDirection_Bi,
}
local u={
[0]="INPUT",
[1]="OUTPUT",
[2]="Open-Drain",
[3]="Quasi-bidirectional",
}
function get_mfp_regs(o,t,a)
local e={}
if t~=nil then
table.insert(e,string.format("GCR_P%d_MFP",t))
end
if a~=nil then
table.insert(e,a)
end
if#e==0 then
return""
elseif#e>1 then
return reg2str("Multi-Function registers",g_Mini51_regs,o,e)
else
return reg2str("Multi-Function register",g_Mini51_regs,o,e)
end
end
function fill_Mini51_GPIO(i,s,e,t,r)
local o
if r==nil then r=string.format("P%d.%d",e,t)end
local a=s[string.format("GCR_P%d_MFP",e)]
local a=s[string.format("GPIO_P%d_PMD",e)]
local c=s[string.format("GPIO_P%d_OFFD",e)]
local d=s[string.format("GPIO_P%d_DOUT",e)]
local h=s[string.format("GPIO_P%d_DMASK",e)]
local l=s[string.format("GPIO_P%d_PIN",e)]
i["highlight_text"]=r
i["normal_color"]=kColor_Invalid
i["highlight_color"]=kColor_GPIO
i["pin_bg_color"]=kBgColor_GPIO
o=ext.band(ext.rshift(a,t*2),3)
i["direction"]=n[o]
if n[o]==kPinDirection_In
or n[o]==kPinDirection_Bi then
if ext.band(l,ext.lshift(1,t))==0 then
i["status"]=kPinStatus_Low
else
i["status"]=kPinStatus_High
end
else
if ext.band(h,ext.lshift(1,t))~=0 then
i["status"]=kPinStatus_Unknown
elseif ext.band(d,ext.lshift(1,t))==0 then
i["status"]=kPinStatus_Low
else
i["status"]=kPinStatus_High
end
end
local a=string.format("P%d.%d is in <b>%s</b> mode<br>",
e,t,u[o])
if n[o]==kPinDirection_In
or n[o]==kPinDirection_Bi then
if ext.band(l,ext.lshift(1,t))==0 then
a=a.."Pin input <b>low</b><br>"
else
a=a.."Pin input <b>high</b><br>"
end
end
if n[o]==kPinDirection_PushPullOut
or n[o]==kPinDirection_OpenDrainOut
or n[o]==kPinDirection_Bi then
if ext.band(h,ext.lshift(1,t))~=0 then
a=a.."Pin output <b>masked</b><br>"
elseif ext.band(d,ext.lshift(1,t))==0 then
a=a.."Pin output <b>low</b><br>"
else
a=a.."Pin output <b>high</b><br>"
end
end
if ext.band(c,ext.lshift(1,t+16))==0 then
a=a.."IO digital input path <b>enabled</b><br>"
else
a=a.."IO digital input path <b>disabled</b>(digital input tied to low)<br>"
end
local h=""
if n[o]==kPinDirection_PushPullOut
or n[o]==kPinDirection_Bi then
if ext.band(d,ext.lshift(1,t))==0 and ext.band(l,ext.lshift(1,t))~=0 then
h=string.format("Leakage warning: P%d_DOUT[%d] = 0, P%d_PIN[%d] = 1<br>",e,t,e,t)
elseif ext.band(d,ext.lshift(1,t))~=0 and ext.band(l,ext.lshift(1,t))==0 then
h=string.format("Leakage warning: P%d_DOUT[%d] = 1, P%d_PIN[%d] = 0<br>",e,t,e,t)
end
end
if h~=""then
i["pin_no_color"]=kBgColor_Error
h="<font color=red>"..h.."</font>"
end
local t={
string.format("GPIO_P%d_PMD",e),
string.format("GPIO_P%d_OFFD",e),
string.format("GPIO_P%d_DOUT",e),
string.format("GPIO_P%d_DMASK",e),
string.format("GPIO_P%d_PIN",e)}
local t=reg2str("GPIO setting registers",g_Mini51_regs,s,t)
i["information"]=string.format("<b>%s</b><br>%s<br>"..
"%s%s"..
"<b>Information</b><br>"..
"%s",
r,
h,
get_mfp_regs(s,e),
t,
a)
end
function fill_invalid_GPIO(e,i,t,a)
e["highlight_text"]=string.format("P%d.%d",t,a)
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Invalid
e["pin_bg_color"]=kBgColor_Invalid
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
e["pin_no_color"]=kBgColor_Error
local o=string.format("<font color=red>Undefined setting in P%d_MFP for this pin</font><br>",
t)
e["information"]=string.format("<b>P%d.%d</b><br>%s<br>"..
"%s",
t,a,
o,
get_mfp_regs(i,t))
end
function get_XTL_clock(a,o)
local e
local t
table.insert(o,"CLK_PWRCON")
local a=ext.band(a["CLK_PWRCON"],3)
if a==1 then
e=12000000
t="external <b>HXT(12M)</b>"
elseif a==2 then
e=32768
t="external <b>LXT(32K)</b>"
elseif a==3 then
e=12000000
t="external input, <font color=blue>when</font> external input clock is <font color=blue>12M</font>"
else
e=0
t="invalid external clock (see PWRCON[1:0].XTLCLK_EN)"
end
return e,t
end
function get_OSC22M_clock(a,o)
local e
local t
table.insert(o,"CLK_PWRCON")
local i=ext.band(a["CLK_PWRCON"],4)
if i==0 then
e=0
t="invalid internal <b>22.1184MHz</b> oscillator clock (see PWRCON[2].OSC22M_EN)"
else
table.insert(o,"GCR_IRCTRIMCTL")
local a=ext.band(a["GCR_IRCTRIMCTL"],1)
if a==0 then
e=22118400
t="internal <b>22.1184MHz</b> oscillator clock"
else
e=22118400
t="internal <b>22.1184MHz</b> oscillator clock (auto trim)"
end
end
return e,t
end
function get_OSC10K_clock(a,o)
local t
local e
table.insert(o,"CLK_PWRCON")
local a=ext.band(a["CLK_PWRCON"],8)
if a==0 then
t=0
e="invalid internal <b>10kHz</b> oscillator clock (see PWRCON[3].OSC10K_EN)"
else
t=10000
e="internal <b>10kHz</b> oscillator clock"
end
return t,e
end
function get_PLL_clock(a,o)
local t
local e
table.insert(o,"CLK_PLLCTL")
if ext.band(a["CLK_PLLCTL"],65536)~=0 then
t=0
e="invalid <b>PLL</b> clock, PLL is in power down mode (see PLLCTL[16].PD)"
else
if ext.band(a["CLK_PLLCTL"],524288)~=0 then
t,e=get_OSC22M_clock(a,o)
else
t,e=get_XTL_clock(a,o)
end
if t~=0 then
if ext.band(a["CLK_PLLCTL"],131072)~=0 then
e=string.format("<b>PLL</b> clock (<b>%sHz</b>), bypassed from %s",val2str(t),e)
else
local n={1,2,2,4}
local i=ext.band(a["CLK_PLLCTL"],511)+2
local o=ext.rshift(ext.band(a["CLK_PLLCTL"],15872),9)+2
local a=n[ext.rshift(ext.band(a["CLK_PLLCTL"],49152),14)+1]
t=t*i/o/a
e=string.format("<b>PLL</b> clock (<b>%sHz</b>), from %s",val2str(t),e)
end
else
e="<b>PLL</b> clock from "..e
end
end
return t,e
end
function get_sys_clock(a,o,n)
local s=get_chip_info()["series_group"]
table.insert(o,"CLK_CLKSEL0")
local i=ext.band(a["CLK_CLKSEL0"],7)
local e
local t
if i==0 then
e,t=get_XTL_clock(a,o)
elseif i==2 and s==3 then
e,t=get_PLL_clock(a,o)
elseif i==3 then
e,t=get_OSC10K_clock(a,o)
elseif i==7 then
e,t=get_OSC22M_clock(a,o)
else
e=0
t="invalid <b>"..n.."</b> clock (see CLKSEL0[2:0].HCLK_S)"
return e,t
end
if e==0 then
t="<b>"..n.."</b> clock from "..t
else
table.insert(o,"CLK_CLKDIV")
local a=ext.band(a["CLK_CLKDIV"],15)
e=e/(a+1)
t=string.format("<b>%s</b> clock (<b>%sHz</b>), from %s",n,val2str(e),t)
end
return e,t
end
function get_HCLK_clock(e,t)
return get_sys_clock(e,t,"HCLK")
end
function get_PCLK_clock(e,t)
return get_sys_clock(e,t,"PCLK")
end
function get_clk_informnation(e,t)
return reg2str("Clock setting registers",g_Mini51_regs,e,t)
end
function fill_Mini51_ACMP(e,a,n,t,i,s)
local t=""
local o={}
e["highlight_text"]=i
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_CMP
e["pin_bg_color"]=kBgColor_CMP
e["direction"]=kPinDirection_In
e["status"]=kPinStatus_Unknown
table.insert(o,"CLK_APBCLK")
if ext.band(a["CLK_APBCLK"],1073741824)==0 then
t="ACMP clock is not available (see APBCLK[30].ACMP_EN).<br>"
t="<font color=red>"..t.."</font>"
e["pin_no_color"]=kBgColor_Error
end
e["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s",
i,
t,
get_mfp_regs(a,n,s),
get_clk_informnation(a,o))
end
function fill_Mini51_UART(i,e,c,a,u,t)
local h=get_chip_info()["series_group"]
local n=""
local a=""
local o={}
local d=0
if t==nil then t=0 end
i["highlight_text"]=u
i["normal_color"]=kColor_Invalid
i["highlight_color"]=kColor_UART
i["pin_bg_color"]=kBgColor_UART
i["direction"]=kPinDirection_Unknown
i["status"]=kPinStatus_Unknown
function get_uart_baudate(i)
local t=string.format("UART%d_UART_BAUD",t)
table.insert(o,t)
local n=ext.band(e[t],536870912)
local o=ext.band(e[t],268435456)
local s=ext.rshift(ext.band(e[t],251658240),24)
local e=ext.band(e[t],65535)
local a=0
local t=""
if n==0 and o==0 then
a=i/(16*(e+2))
elseif n~=0 and o==0 then
if s>=8 then
a=i/((s+1)*(e+2))
else
t="invalid UART_BAUD value, DIVIDER_X must >= 8"
end
elseif n~=0 and o~=0 then
if h==0 then
if e>=3 then
a=i/(e+2)
else
t="invalid UART_BAUD value, BRD must >= 3"
end
else
if e>=8 then
a=i/(e+2)
else
t="invalid UART_BAUD value, BRD must >= 8"
end
end
else
t="invalid UART_BAUD value"
end
return a,t
end
table.insert(o,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],ext.lshift(65536,t))~=0 then
table.insert(o,"CLK_CLKSEL1")
local i
local l
if h==2 then
i=ext.band(ext.rshift(e["CLK_CLKSEL1"],24+t*2),3)
l=ext.band(ext.rshift(e["CLK_CLKDIV"],8+t*4),15)
else
i=ext.band(ext.rshift(e["CLK_CLKSEL1"],24),3)
l=ext.band(ext.rshift(e["CLK_CLKDIV"],8),15)
end
local r
local s
if i==0 then
r,s=get_XTL_clock(e,o)
elseif i==1 and h==3 then
r,s=get_PLL_clock(e,o)
elseif i==2 then
r,s=get_OSC22M_clock(e,o)
elseif i==3 and(h==1 or h==3)then
r,s=get_OSC22M_clock(e,o)
elseif i==3 and h==2 and t==0 then
r,s=get_OSC22M_clock(e,o)
else
if h==2 then
a=string.format("UART%d clock is not available (see CLKSEL1[%d:%d].UART_S).<br>",
t,24+t*2+1,24+t*2)
else
a="UART clock is not available (see CLKSEL1[25:24].UART_S).<br>"
end
end
if a==""then
d=r/(l+1)
if d~=0 then
table.insert(o,"CLK_CLKDIV")
n=string.format("UART%d clock frequency: <b>%sHz</b>, from %s.<br>",t,val2str(d),s)
else
a=string.format("UART%d clock is not available, %s.<br>",t,s)
end
end
else
a=string.format("UART%d clock is not available (see APBCLK[%d].UART_EN).<br>",t,16+t)
end
if a==""then
local e,t=get_uart_baudate(d)
if e~=0 then
n=n..string.format("UART baudrate: <b>%d</b><br>",e)
else
a=t..".<br>"
end
end
if a~=""then
a="<font color=red>"..a.."</font>"
i["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
i["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
u,
a,
get_mfp_regs(e,c),
get_clk_informnation(e,o),
n)
end
function fill_Mini51_SPI(s,e,d,t,r)
local h=get_chip_info()["series_group"]
local a=""
local n=""
local t={}
s["highlight_text"]=r
s["normal_color"]=kColor_Invalid
s["highlight_color"]=kColor_SPI
s["pin_bg_color"]=kBgColor_SPI
s["direction"]=kPinDirection_Unknown
s["status"]=kPinStatus_Unknown
table.insert(t,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],4096)~=0 then
local o,i
if h==0 then
o,i=get_PCLK_clock(e,t)
elseif h==3 then
table.insert(t,"CLK_CLKSEL1")
local a=ext.band(ext.rshift(e["CLK_CLKSEL1"],4),3)
if a==0 then
o,i=get_XTL_clock(e,t)
elseif a==1 then
o,i=get_HCLK_clock(e,t)
elseif a==2 then
o,i=get_PLL_clock(e,t)
else
n="SPI clock is not available (see CLKSEL1[5:4].SPISEL).<br>"
end
else
table.insert(t,"CLK_CLKSEL1")
local a=ext.band(ext.rshift(e["CLK_CLKSEL1"],4),1)
if a==0 then
o,i=get_XTL_clock(e,t)
else
o,i=get_HCLK_clock(e,t)
end
end
if n==""then
if o~=0 then
table.insert(t,"SPI_SPI_CNTRL")
local n=ext.band(e["SPI_SPI_CNTRL"],262144)
if n~=0 then
a="SPI is in <b>slave</b> mode.<br>"
else
a="SPI is in <b>master</b> mode.<br>"
if h==0 then
table.insert(t,"SPI_SPI_CNTRL2")
local n=ext.band(e["SPI_SPI_CNTRL2"],1)
if n~=0 then
a=a..string.format("SPI clock frequency: <b>%sHz</b>, from %s.<br>",
val2str(o),i)
else
table.insert(t,"SPI_SPI_DIVIDER")
local t=ext.band(e["SPI_SPI_DIVIDER"],65535)
local n=ext.band(ext.rshift(e["SPI_SPI_DIVIDER"],16),65535)
local t=o/((t+1)*2)
local o=o/((n+1)*2)
local e=ext.band(e["SPI_SPI_CNTRL"],8388608)
if e~=0 then
a=a..string.format("SPI clock frequency is variable: <b>%sHz</b> or <b>%sHz</b>, from %s.<br>",
val2str(t),val2str(o),i)
else
a=a..string.format("SPI clock frequency: <b>%sHz</b>, from %s.<br>",
val2str(t),i)
end
end
else
table.insert(t,"SPI_SPI_CNTRL2")
table.insert(t,"SPI_SPI_DIVIDER")
local n=ext.band(e["SPI_SPI_CNTRL2"],2147483648)
local t=ext.band(e["SPI_SPI_DIVIDER"],255)
local e=0
if n==0 then
e=o/((t+1)*2)
else
e=o/(t+1)
end
a=a..string.format("SPI clock frequency: <b>%sHz</b>, from %s.<br>",
val2str(e),i)
end
end
else
n="SPI clock is not available, "..i..".<br>"
end
end
else
n="SPI clock is not available (see APBCLK[12].SPI_EN).<br>"
end
if n~=""then
n="<font color=red>"..n.."</font>"
s["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
s["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
r,
n,
get_mfp_regs(e,d),
get_clk_informnation(e,t),
a)
end
function fill_Mini51_SPI_IO(e,a,t)
local a=ext.band(a["SPI_SPI_CNTRL"],262144)
if a==0 then
if t then
e["direction"]=kPinDirection_In
else
e["direction"]=kPinDirection_PushPullOut
end
else
if t then
e["direction"]=kPinDirection_PushPullOut
else
e["direction"]=kPinDirection_In
end
end
end
function fill_Mini51_ADC(o,e,r,t,h,l)
local d=get_chip_info()["series_group"]
local i=""
local a=""
local t={}
o["highlight_text"]=h
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_ADC
o["pin_bg_color"]=kBgColor_ADC
o["direction"]=kPinDirection_In
o["status"]=kPinStatus_Unknown
table.insert(t,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],268435456)~=0 then
table.insert(t,"CLK_CLKSEL1")
local s=ext.rshift(ext.band(e["CLK_CLKSEL1"],12),2)
local h=ext.rshift(ext.band(e["CLK_CLKDIV"],16711680),16)
local n
local o
if s==0 then
n,o=get_XTL_clock(e,t)
elseif s==1 and d==3 then
n,o=get_PLL_clock(e,t)
elseif s==2 then
n,o=get_HCLK_clock(e,t)
elseif s==3 then
n,o=get_OSC22M_clock(e,t)
else
a="ADC clock is not available (see CLKSEL1[3:2].ADC_S).<br>"
end
if a==""then
local e=n/(h+1)
if e~=0 then
table.insert(t,"CLK_CLKDIV")
i=string.format("ADC clock frequency: <b>%sHz</b>, from %s.<br>",val2str(e),o)
else
a="ADC clock is not available, "..o..".<br>"
end
end
else
a="ADC clock is not available (see APBCLK[28].ADC_EN).<br>"
end
if a~=""then
a="<font color=red>"..a.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
o["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
h,
a,
get_mfp_regs(e,r,l),
get_clk_informnation(e,t),
i)
end
function fill_Mini51_I2C(t,o,r,a,h,e)
local i=""
local a=""
local n={}
if e==nil then e=0 end
t["highlight_text"]=h
t["normal_color"]=kColor_Invalid
t["highlight_color"]=kColor_I2C
t["pin_bg_color"]=kBgColor_I2C
t["direction"]=kPinDirection_Unknown
t["status"]=kPinStatus_Unknown
table.insert(n,"CLK_APBCLK")
if ext.band(o["CLK_APBCLK"],ext.lshift(256,e))~=0 then
local t=string.format("I2C%d_I2C_CTL",e)
table.insert(n,t)
local t=ext.band(o[t],64)
if t~=0 then
local s,t=get_PCLK_clock(o,n)
if s~=0 then
local a=string.format("I2C%d_I2C_CLKDIV",e)
table.insert(n,a)
local a=ext.band(o[a],255)
local a=s/(4*(a+1))
i=string.format("I2C%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(a),t)
else
a=string.format("I2C%d clock is not available, %s.<br>",e,t)
end
else
a=string.format("I2C%d controller disabled (see I2CON[6].ENS1).<br>",e)
end
else
a=string.format("I2C%d clock is not available (see APBCLK[%d].I2C_EN).<br>",e,8+e)
end
if a~=""then
a="<font color=red>"..a.."</font>"
t["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
t["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
h,
a,
get_mfp_regs(o,r),
get_clk_informnation(o,n),
i)
end
function fill_Mini51_CKO(o,e,d,t,r)
local h=get_chip_info()["series_group"]
local n=""
local a=""
local t={}
o["highlight_text"]=r
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_CLK
o["pin_bg_color"]=kBgColor_CLK
o["direction"]=kPinDirection_PushPullOut
o["status"]=kPinStatus_Unknown
table.insert(t,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],64)~=0 then
table.insert(t,"CLK_FRQDIV")
if ext.band(e["CLK_FRQDIV"],16)~=0 then
table.insert(t,"CLK_CLKSEL2")
table.insert(t,"CLK_FRQDIV")
local s=ext.rshift(ext.band(e["CLK_CLKSEL2"],12),2)
local r=ext.band(e["CLK_FRQDIV"],15)
local i
local o
if s==0 then
i,o=get_XTL_clock(e,t)
elseif s==1 and h==3 then
i,o=get_OSC10K_clock(e,t)
elseif s==2 then
i,o=get_HCLK_clock(e,t)
elseif s==3 then
i,o=get_OSC22M_clock(e,t)
else
a="Frequency divider is not available (see CLKSEL2[3:2].FRQDIV_S).<br>"
end
if a==""then
local t=ext.band(e["CLK_FRQDIV"],32)
local e=0
if(h==1 or h==2 or h==3)and t~=0 then
e=i
else
e=i/ext.lshift(1,(r+1))
end
if e~=0 then
n=string.format("FRQDIV clock frequency: <b>%sHz</b>, from %s.<br>",val2str(e),o)
else
a="FRQDIV clock is not available, "..o..".<br>"
end
end
else
a="Frequency divider disabled (see FRQDIV[4].DIVIDER_EN).<br>"
end
else
a="FRQDIV clock is not available (see APBCLK[6].FDIV_EN).<br>"
end
if a~=""then
a="<font color=red>"..a.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
o["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
r,
a,
get_mfp_regs(e,d),
get_clk_informnation(e,t),
n)
end
function fill_Mini51_PWM(i,a,u,t,l,e)
local r=get_chip_info()["series_group"]
local s=""
local o=""
local n={}
if e==nil then e=tonumber((l:gsub("^PWM","")))end
local t=ext.rshift(e,1)
i["highlight_text"]=l
i["normal_color"]=kColor_Invalid
i["highlight_color"]=kColor_PWM
i["pin_bg_color"]=kBgColor_PWM
i["direction"]=kPinDirection_Unknown
i["status"]=kPinStatus_Unknown
table.insert(n,"CLK_APBCLK")
local d=ext.band(a["CLK_APBCLK"],ext.lshift(1048576,t))
local h
if d~=0 then
local i
local d
if t==0 then
i="CLKSEL1"
d="[29:28]"
h=ext.rshift(ext.band(a["CLK_CLKSEL1"],805306368),28)
elseif t==1 then
i="CLKSEL1"
d="[31:30]"
h=ext.rshift(ext.band(a["CLK_CLKSEL1"],3221225472),30)
else
i="CLKSEL2"
d="[5:4]"
h=ext.rshift(ext.band(a["CLK_CLKSEL2"],48),4)
end
table.insert(n,"CLK_"..i)
if(r==0 or r==3)and h~=2 then
o=string.format("PWM%d clock is not available (see "..i..d..".PWM%d%d_S).<br>",
e,t*2,t*2+1)
else
local h
local i
h,i=get_HCLK_clock(a,n)
if h==0 then
o=string.format("PWM%d clock is not available, %s.<br>",e,i)
else
table.insert(n,"PWM_CSR")
table.insert(n,"PWM_PPR")
local n=ext.band(ext.rshift(a["PWM_CSR"],4*e),7)
local n=({2,4,8,16,1,0,0,0})[n+1]
local a=ext.band(ext.rshift(a["PWM_PPR"],8*t),255)
if a==0 then
o=string.format("PWM%d counter will be stopped since PWM_PPR[%d:%d].CP%d%d = 0<br>",
e,8*t+7,8*t,t*2,t*2+1)
elseif n==0 and(r==0 or r==1)then
o=string.format("PWM%d counter clock is not available (see PWM_CSR[%d:%d].CSR%d).<br>",
e,4*e+2,4*e,e)
elseif n==0 then
local t=h
s=string.format("PWM%d counter frequency: <b>%sHz</b>, from %s.<br>",
e,val2str(t),i)
else
local t=h/(a+1)
local a=t/n
s=string.format("PWM%d clock frequency: <b>%sHz</b> (Pre-Scaled), from %s.<br>"..
"PWM%d counter frequency: <b>%sHz</b><br>",
e,val2str(t),i,
e,val2str(a))
end
end
end
else
o=string.format("PWM%d clock is not available (see APBCLK[%d].PWM%d%d_EN).<br>",
e,t+20,t*2,t*2+1)
end
if o~=""then
o="<font color=red>"..o.."</font>"
i["pin_no_color"]=kBgColor_Error
end
if s~=""then
s="<b>Information</b><br>"..s
end
i["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
l,
o,
get_mfp_regs(a,u),
get_clk_informnation(a,n),
s)
end
function fill_Mini51_TM(o,t,d,a,r,e)
local n=""
local i=""
local a={}
o["highlight_text"]=r
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_TM
o["pin_bg_color"]=kBgColor_TM
o["direction"]=kPinDirection_Unknown
o["status"]=kPinStatus_Unknown
table.insert(a,"CLK_APBCLK")
local h=ext.band(t["CLK_APBCLK"],ext.lshift(4,e))
local s
if h~=0 then
local o=string.format("TMR01_TCSR%d",e)
table.insert(a,o)
local o=ext.band(t[o],16777216)
if o~=0 then
n=string.format("Timer%d external counter mode enabled.<br>",e)
else
table.insert(a,"CLK_CLKSEL1")
s=ext.band(ext.rshift(t["CLK_CLKSEL1"],8+e*4),7)
local o
local h
if s==0 then
o,h=get_XTL_clock(t,a)
elseif s==1 then
o,h=get_OSC10K_clock(t,a)
elseif s==2 then
o,h=get_HCLK_clock(t,a)
elseif s==3 then
n=string.format("Timer%d clock source from external trigger.<br>",e)
elseif s==7 then
o,h=get_OSC22M_clock(t,a)
else
i=string.format("Timer%d clock source is undefined (see CLK_CLKSEL1[%d:%d].TMR%d_S).<br>",
e,8+e*4+2,8+e*4,e)
end
if i==""and n==""then
if o~=0 then
n=string.format("Timer%d clock frequency: <b>%sHz</b>, from %s<br>",
e,val2str(o),h)
else
i=string.format("Timer%d clock is not available, %s.<br>",e,h)
end
end
end
else
i=string.format("Timer%d clock is disabled (see APBCLK[%d].TMR%d_EN).<br>",e,(e+2),e)
end
if i~=""then
i="<font color=red>"..i.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
o["information"]=string.format(
"<b>%s</b><br>%s<br>"..
"%s%s%s",
r,
i,
get_mfp_regs(t,d),
get_clk_informnation(t,a),
n)
end
function fill_Mini51_Normal(e,o,a,i,t)
local n=""
e["highlight_text"]=t
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Normal
e["pin_bg_color"]=kBgColor_Normal
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
n=t.."<br>"
if a==nil or i==nil then
e["information"]=string.format(
"<b>%s</b><br>",
t)
else
e["information"]=string.format(
"<b>%s</b><br><br>"..
"%s",
t,
get_mfp_regs(o,a))
end
end
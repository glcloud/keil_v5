REG=
{
GCR_PDID=1342177280,
GCR_RSTSRC=1342177284,
GCR_IPRSTC1=1342177288,
GCR_IPRSTC2=1342177292,
GCR_IPRSTC3=1342177296,
GCR_BODCR=1342177304,
GCR_PORCR=1342177316,
GCR_VREFCR=1342177320,
GCR_GPA_MFP=1342177328,
GCR_GPB_MFP=1342177332,
GCR_GPC_MFP=1342177336,
GCR_GPD_MFP=1342177340,
GCR_GPE_MFP=1342177344,
GCR_GPF_MFP=1342177348,
GCR_ALT_MFP=1342177360,
GCR_ALT_MFP2=1342177372,
GCR_ALT_MFP3=1342177376,
GCR_ALT_MFP4=1342177380,
GCR_REGWRPROT=1342177536,
GPIO_GPIOA_PMD=1342193664,
GPIO_GPIOA_OFFD=1342193668,
GPIO_GPIOA_DOUT=1342193672,
GPIO_GPIOA_DMASK=1342193676,
GPIO_GPIOA_PIN=1342193680,
GPIO_GPIOA_DBEN=1342193684,
GPIO_GPIOA_IMD=1342193688,
GPIO_GPIOA_IEN=1342193692,
GPIO_GPIOA_ISRC=1342193696,
GPIO_GPIOB_PMD=1342193728,
GPIO_GPIOB_OFFD=1342193732,
GPIO_GPIOB_DOUT=1342193736,
GPIO_GPIOB_DMASK=1342193740,
GPIO_GPIOB_PIN=1342193744,
GPIO_GPIOB_DBEN=1342193748,
GPIO_GPIOB_IMD=1342193752,
GPIO_GPIOB_IEN=1342193756,
GPIO_GPIOB_ISRC=1342193760,
GPIO_GPIOC_PMD=1342193792,
GPIO_GPIOC_OFFD=1342193796,
GPIO_GPIOC_DOUT=1342193800,
GPIO_GPIOC_DMASK=1342193804,
GPIO_GPIOC_PIN=1342193808,
GPIO_GPIOC_DBEN=1342193812,
GPIO_GPIOC_IMD=1342193816,
GPIO_GPIOC_IEN=1342193820,
GPIO_GPIOC_ISRC=1342193824,
GPIO_GPIOD_PMD=1342193856,
GPIO_GPIOD_OFFD=1342193860,
GPIO_GPIOD_DOUT=1342193864,
GPIO_GPIOD_DMASK=1342193868,
GPIO_GPIOD_PIN=1342193872,
GPIO_GPIOD_DBEN=1342193876,
GPIO_GPIOD_IMD=1342193880,
GPIO_GPIOD_IEN=1342193884,
GPIO_GPIOD_ISRC=1342193888,
GPIO_GPIOE_PMD=1342193920,
GPIO_GPIOE_OFFD=1342193924,
GPIO_GPIOE_DOUT=1342193928,
GPIO_GPIOE_DMASK=1342193932,
GPIO_GPIOE_PIN=1342193936,
GPIO_GPIOE_DBEN=1342193940,
GPIO_GPIOE_IMD=1342193944,
GPIO_GPIOE_IEN=1342193948,
GPIO_GPIOE_ISRC=1342193952,
GPIO_GPIOF_PMD=1342193984,
GPIO_GPIOF_OFFD=1342193988,
GPIO_GPIOF_DOUT=1342193992,
GPIO_GPIOF_DMASK=1342193996,
GPIO_GPIOF_PIN=1342194000,
GPIO_GPIOF_DBEN=1342194004,
GPIO_GPIOF_IMD=1342194008,
GPIO_GPIOF_IEN=1342194012,
GPIO_GPIOF_ISRC=1342194016,
GPIO_DBNCECON=1342194048,
CLK_PWRCON=1342177792,
CLK_AHBCLK=1342177796,
CLK_APBCLK=1342177800,
CLK_CLKSTATUS=1342177804,
CLK_CLKSEL0=1342177808,
CLK_CLKSEL1=1342177812,
CLK_CLKDIV=1342177816,
CLK_CLKSEL2=1342177820,
CLK_PLLCON=1342177824,
CLK_FRQDIV=1342177828,
CLK_APBCLK1=1342177840,
CLK_CLKSEL3=1342177844,
CLK_CLKDCTL=1342177904,
CLK_CLKDSTS=1342177908,
CLK_CDUPB=1342177912,
CLK_CDLOWB=1342177916,
UART0_UA_RBR=1074069504,
UART0_UA_THR=1074069504,
UART0_UA_IER=1074069508,
UART0_UA_FCR=1074069512,
UART0_UA_LCR=1074069516,
UART0_UA_MCR=1074069520,
UART0_UA_MSR=1074069524,
UART0_UA_FSR=1074069528,
UART0_UA_ISR=1074069532,
UART0_UA_TOR=1074069536,
UART0_UA_BAUD=1074069540,
UART0_UA_IRCR=1074069544,
UART0_UA_ALT_CSR=1074069548,
UART0_UA_FUN_SEL=1074069552,
UART0_UA_LIN_CTL=1074069556,
UART0_UA_LIN_SR=1074069560,
UART1_UA_RBR=1075118080,
UART1_UA_THR=1075118080,
UART1_UA_IER=1075118084,
UART1_UA_FCR=1075118088,
UART1_UA_LCR=1075118092,
UART1_UA_MCR=1075118096,
UART1_UA_MSR=1075118100,
UART1_UA_FSR=1075118104,
UART1_UA_ISR=1075118108,
UART1_UA_TOR=1075118112,
UART1_UA_BAUD=1075118116,
UART1_UA_IRCR=1075118120,
UART1_UA_ALT_CSR=1075118124,
UART1_UA_FUN_SEL=1075118128,
UART1_UA_LIN_CTL=1075118132,
UART1_UA_LIN_SR=1075118136,
UART2_UA_RBR=1075134464,
UART2_UA_THR=1075134464,
UART2_UA_IER=1075134468,
UART2_UA_FCR=1075134472,
UART2_UA_LCR=1075134476,
UART2_UA_MCR=1075134480,
UART2_UA_MSR=1075134484,
UART2_UA_FSR=1075134488,
UART2_UA_ISR=1075134492,
UART2_UA_TOR=1075134496,
UART2_UA_BAUD=1075134500,
UART2_UA_IRCR=1075134504,
UART2_UA_ALT_CSR=1075134508,
UART2_UA_FUN_SEL=1075134512,
UART2_UA_LIN_CTL=1075134516,
UART2_UA_LIN_SR=1075134520,
UART3_UA_RBR=1074085888,
UART3_UA_THR=1074085888,
UART3_UA_IER=1074085892,
UART3_UA_FCR=1074085896,
UART3_UA_LCR=1074085900,
UART3_UA_MCR=1074085904,
UART3_UA_MSR=1074085908,
UART3_UA_FSR=1074085912,
UART3_UA_ISR=1074085916,
UART3_UA_TOR=1074085920,
UART3_UA_BAUD=1074085924,
UART3_UA_IRCR=1074085928,
UART3_UA_ALT_CSR=1074085932,
UART3_UA_FUN_SEL=1074085936,
UART3_UA_LIN_CTL=1074085940,
UART3_UA_LIN_SR=1074085944,
UART4_UA_RBR=1074102272,
UART4_UA_THR=1074102272,
UART4_UA_IER=1074102276,
UART4_UA_FCR=1074102280,
UART4_UA_LCR=1074102284,
UART4_UA_MCR=1074102288,
UART4_UA_MSR=1074102292,
UART4_UA_FSR=1074102296,
UART4_UA_ISR=1074102300,
UART4_UA_TOR=1074102304,
UART4_UA_BAUD=1074102308,
UART4_UA_IRCR=1074102312,
UART4_UA_ALT_CSR=1074102316,
UART4_UA_FUN_SEL=1074102320,
UART4_UA_LIN_CTL=1074102324,
UART4_UA_LIN_SR=1074102328,
UART5_UA_RBR=1075150848,
UART5_UA_THR=1075150848,
UART5_UA_IER=1075150852,
UART5_UA_FCR=1075150856,
UART5_UA_LCR=1075150860,
UART5_UA_MCR=1075150864,
UART5_UA_MSR=1075150868,
UART5_UA_FSR=1075150872,
UART5_UA_ISR=1075150876,
UART5_UA_TOR=1075150880,
UART5_UA_BAUD=1075150884,
UART5_UA_IRCR=1075150888,
UART5_UA_ALT_CSR=1075150892,
UART5_UA_FUN_SEL=1075150896,
UART5_UA_LIN_CTL=1075150900,
UART5_UA_LIN_SR=1075150904,
SPI0_SPI_CNTRL=1073938432,
SPI0_SPI_DIVIDER=1073938436,
SPI0_SPI_SSR=1073938440,
SPI0_SPI_RX0=1073938448,
SPI0_SPI_RX1=1073938452,
SPI0_SPI_TX0=1073938464,
SPI0_SPI_TX1=1073938468,
SPI0_SPI_VARCLK=1073938484,
SPI0_SPI_CNTRL2=1073938492,
SPI0_SPI_FIFO_CTL=1073938496,
SPI0_SPI_STATUS=1073938500,
I2C0_I2CON=1073872896,
I2C0_I2CADDR0=1073872900,
I2C0_I2CDAT=1073872904,
I2C0_I2CSTATUS=1073872908,
I2C0_I2CLK=1073872912,
I2C0_I2CTOC=1073872916,
I2C0_I2CADDR1=1073872920,
I2C0_I2CADDR2=1073872924,
I2C0_I2CADDR3=1073872928,
I2C0_I2CADM0=1073872932,
I2C0_I2CADM1=1073872936,
I2C0_I2CADM2=1073872940,
I2C0_I2CADM3=1073872944,
I2C0_I2CWKUPCON=1073872956,
I2C0_I2CWKUPSTS=1073872960,
I2C1_I2CON=1074921472,
I2C1_I2CADDR0=1074921476,
I2C1_I2CDAT=1074921480,
I2C1_I2CSTATUS=1074921484,
I2C1_I2CLK=1074921488,
I2C1_I2CTOC=1074921492,
I2C1_I2CADDR1=1074921496,
I2C1_I2CADDR2=1074921500,
I2C1_I2CADDR3=1074921504,
I2C1_I2CADM0=1074921508,
I2C1_I2CADM1=1074921512,
I2C1_I2CADM2=1074921516,
I2C1_I2CADM3=1074921520,
I2C1_I2CWKUPCON=1074921532,
I2C1_I2CWKUPSTS=1074921536,
TMR01_TCSR0=1073807360,
TMR01_TCMPR0=1073807364,
TMR01_TISR0=1073807368,
TMR01_TDR0=1073807372,
TMR01_TCAP0=1073807376,
TMR01_TEXCON0=1073807380,
TMR01_TEXISR0=1073807384,
TMR01_TCSR1=1073807392,
TMR01_TCMPR1=1073807396,
TMR01_TISR1=1073807400,
TMR01_TDR1=1073807404,
TMR01_TCAP1=1073807408,
TMR01_TEXCON1=1073807412,
TMR01_TEXISR1=1073807416,
TMR23_TCSR2=1074855936,
TMR23_TCMPR2=1074855940,
TMR23_TISR2=1074855944,
TMR23_TDR2=1074855948,
TMR23_TCAP2=1074855952,
TMR23_TEXCON2=1074855956,
TMR23_TEXISR2=1074855960,
TMR23_TCSR3=1074855968,
TMR23_TCMPR3=1074855972,
TMR23_TISR3=1074855976,
TMR23_TDR3=1074855980,
TMR23_TCAP3=1074855984,
TMR23_TEXCON3=1074855988,
TMR23_TEXISR3=1074855992,
BPWM0_BPWM_CTL0=1074020352,
BPWM0_BPWM_CTL1=1074020356,
BPWM0_BPWM_CLKSRC=1074020368,
BPWM0_BPWM_CLKPSC=1074020372,
BPWM0_BPWM_CNTEN=1074020384,
BPWM0_BPWM_CNTCLR=1074020388,
BPWM0_BPWM_PERIOD=1074020400,
BPWM0_BPWM_CMPDAT0=1074020432,
BPWM0_BPWM_CMPDAT1=1074020436,
BPWM0_BPWM_CMPDAT2=1074020440,
BPWM0_BPWM_CMPDAT3=1074020444,
BPWM0_BPWM_CMPDAT4=1074020448,
BPWM0_BPWM_CMPDAT5=1074020452,
BPWM0_BPWM_CNT0=1074020496,
BPWM0_BPWM_WGCTL0=1074020528,
BPWM0_BPWM_WGCTL1=1074020532,
BPWM0_BPWM_MSKEN=1074020536,
BPWM0_BPWM_MSK=1074020540,
BPWM0_BPWM_POLCTL=1074020564,
BPWM0_BPWM_POEN=1074020568,
BPWM0_BPWM_INTEN=1074020576,
BPWM0_BPWM_INTSTS=1074020584,
BPWM0_BPWM_ADCTS0=1074020600,
BPWM0_BPWM_ADCTS1=1074020604,
BPWM0_BPWM_SSCTL=1074020624,
BPWM0_BPWM_SSTRG=1074020628,
BPWM0_BPWM_STATUS=1074020640,
BPWM0_BPWM_CAPINEN=1074020864,
BPWM0_BPWM_CAPCTL=1074020868,
BPWM0_BPWM_CAPSTS=1074020872,
BPWM0_BPWM_RCAPDAT0=1074020876,
BPWM0_BPWM_FCAPDAT0=1074020880,
BPWM0_BPWM_RCAPDAT1=1074020884,
BPWM0_BPWM_FCAPDAT1=1074020888,
BPWM0_BPWM_RCAPDAT2=1074020892,
BPWM0_BPWM_FCAPDAT2=1074020896,
BPWM0_BPWM_RCAPDAT3=1074020900,
BPWM0_BPWM_FCAPDAT3=1074020904,
BPWM0_BPWM_RCAPDAT4=1074020908,
BPWM0_BPWM_FCAPDAT4=1074020912,
BPWM0_BPWM_RCAPDAT5=1074020916,
BPWM0_BPWM_FCAPDAT5=1074020920,
BPWM0_BPWM_CAPIEN=1074020944,
BPWM0_BPWM_CAPIF=1074020948,
BPWM0_BPWM_PBUF=1074021124,
BPWM0_BPWM_CMPBUF0=1074021148,
BPWM0_BPWM_CMPBUF1=1074021152,
BPWM0_BPWM_CMPBUF2=1074021156,
BPWM0_BPWM_CMPBUF3=1074021160,
BPWM0_BPWM_CMPBUF4=1074021164,
BPWM0_BPWM_CMPBUF5=1074021168,
BPWM1_BPWM_CTL0=1075068928,
BPWM1_BPWM_CTL1=1075068932,
BPWM1_BPWM_CLKSRC=1075068944,
BPWM1_BPWM_CLKPSC=1075068948,
BPWM1_BPWM_CNTEN=1075068960,
BPWM1_BPWM_CNTCLR=1075068964,
BPWM1_BPWM_PERIOD=1075068976,
BPWM1_BPWM_CMPDAT0=1075069008,
BPWM1_BPWM_CMPDAT1=1075069012,
BPWM1_BPWM_CMPDAT2=1075069016,
BPWM1_BPWM_CMPDAT3=1075069020,
BPWM1_BPWM_CMPDAT4=1075069024,
BPWM1_BPWM_CMPDAT5=1075069028,
BPWM1_BPWM_CNT0=1075069072,
BPWM1_BPWM_WGCTL0=1075069104,
BPWM1_BPWM_WGCTL1=1075069108,
BPWM1_BPWM_MSKEN=1075069112,
BPWM1_BPWM_MSK=1075069116,
BPWM1_BPWM_POLCTL=1075069140,
BPWM1_BPWM_POEN=1075069144,
BPWM1_BPWM_INTEN=1075069152,
BPWM1_BPWM_INTSTS=1075069160,
BPWM1_BPWM_ADCTS0=1075069176,
BPWM1_BPWM_ADCTS1=1075069180,
BPWM1_BPWM_SSCTL=1075069200,
BPWM1_BPWM_SSTRG=1075069204,
BPWM1_BPWM_STATUS=1075069216,
BPWM1_BPWM_CAPINEN=1075069440,
BPWM1_BPWM_CAPCTL=1075069444,
BPWM1_BPWM_CAPSTS=1075069448,
BPWM1_BPWM_RCAPDAT0=1075069452,
BPWM1_BPWM_FCAPDAT0=1075069456,
BPWM1_BPWM_RCAPDAT1=1075069460,
BPWM1_BPWM_FCAPDAT1=1075069464,
BPWM1_BPWM_RCAPDAT2=1075069468,
BPWM1_BPWM_FCAPDAT2=1075069472,
BPWM1_BPWM_RCAPDAT3=1075069476,
BPWM1_BPWM_FCAPDAT3=1075069480,
BPWM1_BPWM_RCAPDAT4=1075069484,
BPWM1_BPWM_FCAPDAT4=1075069488,
BPWM1_BPWM_RCAPDAT5=1075069492,
BPWM1_BPWM_FCAPDAT5=1075069496,
BPWM1_BPWM_CAPIEN=1075069520,
BPWM1_BPWM_CAPIF=1075069524,
BPWM1_BPWM_PBUF=1075069700,
BPWM1_BPWM_CMPBUF0=1075069724,
BPWM1_BPWM_CMPBUF1=1075069728,
BPWM1_BPWM_CMPBUF2=1075069732,
BPWM1_BPWM_CMPBUF3=1075069736,
BPWM1_BPWM_CMPBUF4=1075069740,
BPWM1_BPWM_CMPBUF5=1075069744,
PWM0_PWM_CTL0=1074003968,
PWM0_PWM_CTL1=1074003972,
PWM0_PWM_CLKSRC=1074003984,
PWM0_PWM_CLKPSC0_1=1074003988,
PWM0_PWM_CLKPSC2_3=1074003992,
PWM0_PWM_CLKPSC4_5=1074003996,
PWM0_PWM_CNTEN=1074004000,
PWM0_PWM_CNTCLR=1074004004,
PWM0_PWM_PERIOD0=1074004016,
PWM0_PWM_PERIOD2=1074004024,
PWM0_PWM_PERIOD4=1074004032,
PWM0_PWM_CMPDAT0=1074004048,
PWM0_PWM_CMPDAT1=1074004052,
PWM0_PWM_CMPDAT2=1074004056,
PWM0_PWM_CMPDAT3=1074004060,
PWM0_PWM_CMPDAT4=1074004064,
PWM0_PWM_CMPDAT5=1074004068,
PWM0_PWM_DTCTL0_1=1074004080,
PWM0_PWM_DTCTL2_3=1074004084,
PWM0_PWM_DTCTL4_5=1074004088,
PWM0_PWM_CNT0=1074004112,
PWM0_PWM_CNT2=1074004120,
PWM0_PWM_CNT4=1074004128,
PWM0_PWM_WGCTL0=1074004144,
PWM0_PWM_WGCTL1=1074004148,
PWM0_PWM_MSKEN=1074004152,
PWM0_PWM_MSK=1074004156,
PWM0_PWM_BNF=1074004160,
PWM0_PWM_FAILBRK=1074004164,
PWM0_PWM_BRKCTL0_1=1074004168,
PWM0_PWM_BRKCTL2_3=1074004172,
PWM0_PWM_BRKCTL4_5=1074004176,
PWM0_PWM_POLCTL=1074004180,
PWM0_PWM_POEN=1074004184,
PWM0_PWM_SWBRK=1074004188,
PWM0_PWM_INTEN0=1074004192,
PWM0_PWM_INTEN1=1074004196,
PWM0_PWM_INTSTS0=1074004200,
PWM0_PWM_INTSTS1=1074004204,
PWM0_PWM_ADCTS0=1074004216,
PWM0_PWM_ADCTS1=1074004220,
PWM0_PWM_SSCTL=1074004240,
PWM0_PWM_SSTRG=1074004244,
PWM0_PWM_STATUS=1074004256,
PWM0_PWM_CAPINEN=1074004480,
PWM0_PWM_CAPCTL=1074004484,
PWM0_PWM_CAPSTS=1074004488,
PWM0_PWM_RCAPDAT0=1074004492,
PWM0_PWM_FCAPDAT0=1074004496,
PWM0_PWM_RCAPDAT1=1074004500,
PWM0_PWM_FCAPDAT1=1074004504,
PWM0_PWM_RCAPDAT2=1074004508,
PWM0_PWM_FCAPDAT2=1074004512,
PWM0_PWM_RCAPDAT3=1074004516,
PWM0_PWM_FCAPDAT3=1074004520,
PWM0_PWM_RCAPDAT4=1074004524,
PWM0_PWM_FCAPDAT4=1074004528,
PWM0_PWM_RCAPDAT5=1074004532,
PWM0_PWM_FCAPDAT5=1074004536,
PWM0_PWM_CAPIEN=1074004560,
PWM0_PWM_CAPIF=1074004564,
PWM0_PWM_PBUF0=1074004740,
PWM0_PWM_PBUF2=1074004748,
PWM0_PWM_PBUF4=1074004756,
PWM0_PWM_CMPBUF0=1074004764,
PWM0_PWM_CMPBUF1=1074004768,
PWM0_PWM_CMPBUF2=1074004772,
PWM0_PWM_CMPBUF3=1074004776,
PWM0_PWM_CMPBUF4=1074004780,
PWM0_PWM_CMPBUF5=1074004784,
PWM1_PWM_CTL0=1075052544,
PWM1_PWM_CTL1=1075052548,
PWM1_PWM_CLKSRC=1075052560,
PWM1_PWM_CLKPSC0_1=1075052564,
PWM1_PWM_CLKPSC2_3=1075052568,
PWM1_PWM_CLKPSC4_5=1075052572,
PWM1_PWM_CNTEN=1075052576,
PWM1_PWM_CNTCLR=1075052580,
PWM1_PWM_PERIOD0=1075052592,
PWM1_PWM_PERIOD2=1075052600,
PWM1_PWM_PERIOD4=1075052608,
PWM1_PWM_CMPDAT0=1075052624,
PWM1_PWM_CMPDAT1=1075052628,
PWM1_PWM_CMPDAT2=1075052632,
PWM1_PWM_CMPDAT3=1075052636,
PWM1_PWM_CMPDAT4=1075052640,
PWM1_PWM_CMPDAT5=1075052644,
PWM1_PWM_DTCTL0_1=1075052656,
PWM1_PWM_DTCTL2_3=1075052660,
PWM1_PWM_DTCTL4_5=1075052664,
PWM1_PWM_CNT0=1075052688,
PWM1_PWM_CNT2=1075052696,
PWM1_PWM_CNT4=1075052704,
PWM1_PWM_WGCTL0=1075052720,
PWM1_PWM_WGCTL1=1075052724,
PWM1_PWM_MSKEN=1075052728,
PWM1_PWM_MSK=1075052732,
PWM1_PWM_BNF=1075052736,
PWM1_PWM_FAILBRK=1075052740,
PWM1_PWM_BRKCTL0_1=1075052744,
PWM1_PWM_BRKCTL2_3=1075052748,
PWM1_PWM_BRKCTL4_5=1075052752,
PWM1_PWM_POLCTL=1075052756,
PWM1_PWM_POEN=1075052760,
PWM1_PWM_SWBRK=1075052764,
PWM1_PWM_INTEN0=1075052768,
PWM1_PWM_INTEN1=1075052772,
PWM1_PWM_INTSTS0=1075052776,
PWM1_PWM_INTSTS1=1075052780,
PWM1_PWM_ADCTS0=1075052792,
PWM1_PWM_ADCTS1=1075052796,
PWM1_PWM_SSCTL=1075052816,
PWM1_PWM_SSTRG=1075052820,
PWM1_PWM_STATUS=1075052832,
PWM1_PWM_CAPINEN=1075053056,
PWM1_PWM_CAPCTL=1075053060,
PWM1_PWM_CAPSTS=1075053064,
PWM1_PWM_RCAPDAT0=1075053068,
PWM1_PWM_FCAPDAT0=1075053072,
PWM1_PWM_RCAPDAT1=1075053076,
PWM1_PWM_FCAPDAT1=1075053080,
PWM1_PWM_RCAPDAT2=1075053084,
PWM1_PWM_FCAPDAT2=1075053088,
PWM1_PWM_RCAPDAT3=1075053092,
PWM1_PWM_FCAPDAT3=1075053096,
PWM1_PWM_RCAPDAT4=1075053100,
PWM1_PWM_FCAPDAT4=1075053104,
PWM1_PWM_RCAPDAT5=1075053108,
PWM1_PWM_FCAPDAT5=1075053112,
PWM1_PWM_CAPIEN=1075053136,
PWM1_PWM_CAPIF=1075053140,
PWM1_PWM_PBUF0=1075053316,
PWM1_PWM_PBUF2=1075053324,
PWM1_PWM_PBUF4=1075053332,
PWM1_PWM_CMPBUF0=1075053340,
PWM1_PWM_CMPBUF1=1075053344,
PWM1_PWM_CMPBUF2=1075053348,
PWM1_PWM_CMPBUF3=1075053352,
PWM1_PWM_CMPBUF4=1075053356,
PWM1_PWM_CMPBUF5=1075053360,
CAN0_CAN_CON=1075314688,
CAN0_CAN_STATUS=1075314692,
CAN0_CAN_ERR=1075314696,
CAN0_CAN_BTIME=1075314700,
CAN0_CAN_IIDR=1075314704,
CAN0_CAN_TEST=1075314708,
CAN0_CAN_BRPE=1075314712,
CAN0_CAN_IF1_CREQ=1075314720,
CAN0_CAN_IF1_CMASK=1075314724,
CAN0_CAN_IF1_MASK1=1075314728,
CAN0_CAN_IF1_MASK2=1075314732,
CAN0_CAN_IF1_ARB1=1075314736,
CAN0_CAN_IF1_ARB2=1075314740,
CAN0_CAN_IF1_MCON=1075314744,
CAN0_CAN_IF1_DAT_A1=1075314748,
CAN0_CAN_IF1_DAT_A2=1075314752,
CAN0_CAN_IF1_DAT_B1=1075314756,
CAN0_CAN_IF1_DAT_B2=1075314760,
CAN0_CAN_IF2_CREQ=1075314816,
CAN0_CAN_IF2_CMASK=1075314820,
CAN0_CAN_IF2_MASK1=1075314824,
CAN0_CAN_IF2_MASK2=1075314828,
CAN0_CAN_IF2_ARB1=1075314832,
CAN0_CAN_IF2_ARB2=1075314836,
CAN0_CAN_IF2_MCON=1075314840,
CAN0_CAN_IF2_DAT_A1=1075314844,
CAN0_CAN_IF2_DAT_A2=1075314848,
CAN0_CAN_IF2_DAT_B1=1075314852,
CAN0_CAN_IF2_DAT_B2=1075314856,
CAN0_CAN_TXREQ1=1075314944,
CAN0_CAN_TXREQ2=1075314948,
CAN0_CAN_NDAT1=1075314976,
CAN0_CAN_NDAT2=1075314980,
CAN0_CAN_IPND1=1075315008,
CAN0_CAN_IPND2=1075315012,
CAN0_CAN_MVLD1=1075315040,
CAN0_CAN_MVLD2=1075315044,
CAN0_CAN_WU_EN=1075315048,
CAN0_CAN_WU_STATUS=1075315052,
ADC_ADDR0=1074659328,
ADC_ADDR1=1074659332,
ADC_ADDR2=1074659336,
ADC_ADDR3=1074659340,
ADC_ADDR4=1074659344,
ADC_ADDR5=1074659348,
ADC_ADDR6=1074659352,
ADC_ADDR7=1074659356,
ADC_ADCR=1074659360,
ADC_ADCHER=1074659364,
ADC_ADCMPR0=1074659368,
ADC_ADCMPR1=1074659372,
ADC_ADSR=1074659376,
}
g_NUC131_regs=REG
function read_NUC131_Registers(t,t,t,e)
local t=true
local a={
M0518_AE_LQFP48=1,
M0518_AE_LQFP64=1}
if a[e]~=nil then t=false end
local e={}
e["GCR_GPA_MFP"],
e["GCR_GPB_MFP"],
e["GCR_GPC_MFP"],
e["GCR_GPD_MFP"],
e["GCR_GPE_MFP"],
e["GCR_GPF_MFP"]=ice:ReadMem32(g_NUC131_regs.GCR_GPA_MFP,6)
e["GCR_ALT_MFP"],
e["GCR_ALT_MFP2"],
e["GCR_ALT_MFP3"],
e["GCR_ALT_MFP4"]=ice:ReadMemMulti(g_NUC131_regs.GCR_ALT_MFP,
g_NUC131_regs.GCR_ALT_MFP2,
g_NUC131_regs.GCR_ALT_MFP3,
g_NUC131_regs.GCR_ALT_MFP4)
e["GPIO_GPIOA_PMD"],
e["GPIO_GPIOA_OFFD"],
e["GPIO_GPIOA_DOUT"],
e["GPIO_GPIOA_DMASK"],
e["GPIO_GPIOA_PIN"]=ice:ReadMem32(g_NUC131_regs.GPIO_GPIOA_PMD,5)
e["GPIO_GPIOB_PMD"],
e["GPIO_GPIOB_OFFD"],
e["GPIO_GPIOB_DOUT"],
e["GPIO_GPIOB_DMASK"],
e["GPIO_GPIOB_PIN"]=ice:ReadMem32(g_NUC131_regs.GPIO_GPIOB_PMD,5)
e["GPIO_GPIOC_PMD"],
e["GPIO_GPIOC_OFFD"],
e["GPIO_GPIOC_DOUT"],
e["GPIO_GPIOC_DMASK"],
e["GPIO_GPIOC_PIN"]=ice:ReadMem32(g_NUC131_regs.GPIO_GPIOC_PMD,5)
e["GPIO_GPIOD_PMD"],
e["GPIO_GPIOD_OFFD"],
e["GPIO_GPIOD_DOUT"],
e["GPIO_GPIOD_DMASK"],
e["GPIO_GPIOD_PIN"]=ice:ReadMem32(g_NUC131_regs.GPIO_GPIOD_PMD,5)
e["GPIO_GPIOE_PMD"],
e["GPIO_GPIOE_OFFD"],
e["GPIO_GPIOE_DOUT"],
e["GPIO_GPIOE_DMASK"],
e["GPIO_GPIOE_PIN"]=ice:ReadMem32(g_NUC131_regs.GPIO_GPIOE_PMD,5)
e["GPIO_GPIOF_PMD"],
e["GPIO_GPIOF_OFFD"],
e["GPIO_GPIOF_DOUT"],
e["GPIO_GPIOF_DMASK"],
e["GPIO_GPIOF_PIN"]=ice:ReadMem32(g_NUC131_regs.GPIO_GPIOF_PMD,5)
e["CLK_PWRCON"],
e["CLK_AHBCLK"],
e["CLK_APBCLK"],
e["CLK_CLKSTATUS"],
e["CLK_CLKSEL0"],
e["CLK_CLKSEL1"],
e["CLK_CLKDIV"],
e["CLK_CLKSEL2"],
e["CLK_PLLCON"],
e["CLK_FRQDIV"]=ice:ReadMem32(g_NUC131_regs.CLK_PWRCON,10)
e["CLK_APBCLK1"],
e["CLK_CLKSEL3"]=ice:ReadMem32(g_NUC131_regs.CLK_APBCLK1,2)
e["UART0_UA_BAUD"],
e["UART1_UA_BAUD"],
e["UART2_UA_BAUD"],
e["UART3_UA_BAUD"]=ice:ReadMemMulti(g_NUC131_regs.UART0_UA_BAUD,
g_NUC131_regs.UART1_UA_BAUD,
g_NUC131_regs.UART2_UA_BAUD,
g_NUC131_regs.UART3_UA_BAUD)
e["UART4_UA_BAUD"],
e["UART5_UA_BAUD"]=ice:ReadMemMulti(g_NUC131_regs.UART4_UA_BAUD,
g_NUC131_regs.UART5_UA_BAUD)
e["SPI0_SPI_CNTRL"],
e["SPI0_SPI_DIVIDER"],
e["SPI0_SPI_CNTRL2"]=ice:ReadMemMulti(g_NUC131_regs.SPI0_SPI_CNTRL,
g_NUC131_regs.SPI0_SPI_DIVIDER,
g_NUC131_regs.SPI0_SPI_CNTRL2)
e["I2C0_I2CON"],
e["I2C0_I2CLK"],
e["I2C1_I2CON"],
e["I2C1_I2CLK"]=ice:ReadMemMulti(g_NUC131_regs.I2C0_I2CON,
g_NUC131_regs.I2C0_I2CLK,
g_NUC131_regs.I2C1_I2CON,
g_NUC131_regs.I2C1_I2CLK)
e["TMR01_TCSR0"],
e["TMR01_TCSR1"],
e["TMR23_TCSR2"],
e["TMR23_TCSR3"]=ice:ReadMemMulti(g_NUC131_regs.TMR01_TCSR0,
g_NUC131_regs.TMR01_TCSR1,
g_NUC131_regs.TMR23_TCSR2,
g_NUC131_regs.TMR23_TCSR3)
e["BPWM0_BPWM_CLKPSC"],
e["BPWM1_BPWM_CLKPSC"],
e["BPWM0_BPWM_CLKSRC"],
e["BPWM1_BPWM_CLKSRC"]=ice:ReadMemMulti(g_NUC131_regs.BPWM0_BPWM_CLKPSC,
g_NUC131_regs.BPWM1_BPWM_CLKPSC,
g_NUC131_regs.BPWM0_BPWM_CLKSRC,
g_NUC131_regs.BPWM1_BPWM_CLKSRC)
e["BPWM0_BPWM_CNTEN"],
e["BPWM1_BPWM_CNTEN"]=ice:ReadMemMulti(g_NUC131_regs.BPWM0_BPWM_CNTEN,
g_NUC131_regs.BPWM1_BPWM_CNTEN)
e["PWM0_PWM_CLKSRC"],
e["PWM1_PWM_CLKSRC"]=ice:ReadMemMulti(g_NUC131_regs.PWM0_PWM_CLKSRC,
g_NUC131_regs.PWM1_PWM_CLKSRC)
e["PWM0_PWM_CLKPSC0_1"],
e["PWM0_PWM_CLKPSC2_3"],
e["PWM0_PWM_CLKPSC4_5"]=ice:ReadMemMulti(g_NUC131_regs.PWM0_PWM_CLKPSC0_1,
g_NUC131_regs.PWM0_PWM_CLKPSC2_3,
g_NUC131_regs.PWM0_PWM_CLKPSC4_5)
e["PWM1_PWM_CLKPSC0_1"],
e["PWM1_PWM_CLKPSC2_3"],
e["PWM1_PWM_CLKPSC4_5"]=ice:ReadMemMulti(g_NUC131_regs.PWM1_PWM_CLKPSC0_1,
g_NUC131_regs.PWM1_PWM_CLKPSC2_3,
g_NUC131_regs.PWM1_PWM_CLKPSC4_5)
e["PWM0_PWM_CNTEN"],
e["PWM1_PWM_CNTEN"]=ice:ReadMemMulti(g_NUC131_regs.PWM0_PWM_CNTEN,
g_NUC131_regs.PWM1_PWM_CNTEN)
e["ADC_ADCR"]=ice:ReadMem32(g_NUC131_regs.ADC_ADCR)
if t then
e["CAN0_CAN_BTIME"],
e["CAN0_CAN_BRPE"]=ice:ReadMemMulti(g_NUC131_regs.CAN0_CAN_BTIME,
g_NUC131_regs.CAN0_CAN_BRPE)
end
return e
end
local n={
[0]=kPinDirection_In,
[1]=kPinDirection_PushPullOut,
[2]=kPinDirection_OpenDrainOut,
[3]=kPinDirection_Bi,
}
local w={
[0]="INPUT",
[1]="OUTPUT",
[2]="Open-Drain",
[3]="Quasi-bidirectional",
}
function get_mfp_regs(t,e,i,a,o)
local e={"GCR_GP"..e.."_MFP"}
if i~=nil then table.insert(e,i)end
if a~=nil then table.insert(e,a)end
if o~=nil then table.insert(e,o)end
if#e>1 then
return reg2str("Multi-Function registers",g_NUC131_regs,t,e)
else
return reg2str("Multi-Function register",g_NUC131_regs,t,e)
end
end
function fill_NUC131_GPIO(o,s,t,e,l,c,u,m)
if l==nil then l=string.format("P%s.%d",t,e)end
local a=s["GPIO_GPIO"..t.."_PMD"]
local f=s["GPIO_GPIO"..t.."_OFFD"]
local r=s["GPIO_GPIO"..t.."_DOUT"]
local h=s["GPIO_GPIO"..t.."_DMASK"]
local d=s["GPIO_GPIO"..t.."_PIN"]
local i=ext.band(ext.rshift(a,e*2),3)
o["highlight_text"]=string.format("P%s.%d",t,e)
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_GPIO
o["pin_bg_color"]=kBgColor_GPIO
o["direction"]=n[i]
if n[i]==kPinDirection_In
or n[i]==kPinDirection_Bi then
if ext.band(d,ext.lshift(1,e))==0 then
o["status"]=kPinStatus_Low
else
o["status"]=kPinStatus_High
end
else
if ext.band(h,ext.lshift(1,e))~=0 then
o["status"]=kPinStatus_Unknown
elseif ext.band(r,ext.lshift(1,e))==0 then
o["status"]=kPinStatus_Low
else
o["status"]=kPinStatus_High
end
end
local a=string.format("P%s.%d is in <b>%s</b> mode<br>",
t,e,w[i])
if n[i]==kPinDirection_In
or n[i]==kPinDirection_Bi then
if ext.band(d,ext.lshift(1,e))==0 then
a=a.."Pin input <b>low</b><br>"
else
a=a.."Pin input <b>high</b><br>"
end
end
if n[i]==kPinDirection_PushPullOut
or n[i]==kPinDirection_OpenDrainOut
or n[i]==kPinDirection_Bi then
if ext.band(h,ext.lshift(1,e))~=0 then
a=a.."Pin output <b>masked</b><br>"
elseif ext.band(r,ext.lshift(1,e))==0 then
a=a.."Pin output <b>low</b><br>"
else
a=a.."Pin output <b>high</b><br>"
end
end
if ext.band(f,ext.lshift(1,e+16))==0 then
a=a.."IO digital input path <b>enabled</b><br>"
else
a=a.."IO digital input path <b>disabled</b>(digital input tied to low)<br>"
end
local h=""
if n[i]==kPinDirection_PushPullOut
or n[i]==kPinDirection_Bi then
if ext.band(r,ext.lshift(1,e))==0 and ext.band(d,ext.lshift(1,e))~=0 then
h=string.format("Leakage warning: GPIO%s_DOUT[%d] = 0, GPIO%s_PIN[%d] = 1<br>",t,e,t,e)
elseif ext.band(r,ext.lshift(1,e))~=0 and ext.band(d,ext.lshift(1,e))==0 then
h=string.format("Leakage warning: GPIO%s_DOUT[%d] = 1, GPIO%s_PIN[%d] = 0<br>",t,e,t,e)
end
end
if h~=""then
o["pin_no_color"]=kBgColor_Error
h="<font color=red>"..h.."</font>"
end
local e={
"GPIO_GPIO"..t.."_PMD",
"GPIO_GPIO"..t.."_OFFD",
"GPIO_GPIO"..t.."_DOUT",
"GPIO_GPIO"..t.."_DMASK",
"GPIO_GPIO"..t.."_PIN"}
local e=reg2str("GPIO setting registers",g_NUC131_regs,s,e)
o["information"]=string.format("<b>%s</b><br>%s<br>"..
"%s%s"..
"<b>Information</b><br>"..
"%s",
l,
h,
get_mfp_regs(s,t,c,u,m),
e,
a)
end
function fill_invalid_GPIO(e,h,t,a,s,o,i)
e["highlight_text"]=string.format("P%s.%d",t,a)
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Invalid
e["pin_bg_color"]=kBgColor_Invalid
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
e["pin_no_color"]=kBgColor_Error
local n="<font color=red>Undefined setting in Multi-Function registers for this pin</font><br>"
e["information"]=string.format("<b>P%s.%d</b><br>%s<br>"..
"%s",
t,a,
n,
get_mfp_regs(h,t,s,o,i))
end
function get_XTL12M_clock(a,o)
local e
local t
table.insert(o,"CLK_PWRCON")
local a=ext.band(a["CLK_PWRCON"],1)
if a==0 then
e=0
t="invalid external <b>4~24M</b> high speed crystal clock (see PWRCON[0].XTL12M_EN)"
else
e=12000000
t="external <b>4~24M</b> high speed crystal clock, <font color=blue>when</font> external input clock is <font color=blue>12M</font>"
end
return e,t
end
function get_OSC22M_clock(o,a)
local e
local t
table.insert(a,"CLK_PWRCON")
local a=ext.band(o["CLK_PWRCON"],4)
if a==0 then
e=0
t="invalid internal <b>22.1184MHz</b> high speed oscillator clock (see PWRCON[2].OSC22M_EN)"
else
e=22118400
t="internal <b>22.1184MHz</b> high speed oscillator clock"
end
return e,t
end
function get_OSC10K_clock(o,a)
local t
local e
table.insert(a,"CLK_PWRCON")
local a=ext.band(o["CLK_PWRCON"],8)
if a==0 then
t=0
e="invalid internal <b>10kHz</b> low speed oscillator clock (see PWRCON[3].OSC10K_EN)"
else
t=10000
e="internal <b>10kHz</b> low speed oscillator clock"
end
return t,e
end
function get_PLL_clock(a,o)
local t
local e
table.insert(o,"CLK_PLLCON")
if ext.band(a["CLK_PLLCON"],65536)~=0 then
t=0
e="invalid <b>PLL</b> clock, PLL is in power down mode (see PLLCON[16].PD)"
else
if ext.band(a["CLK_PLLCON"],524288)~=0 then
t,e=get_OSC22M_clock(a,o)
else
t,e=get_XTL12M_clock(a,o)
end
if t~=0 then
if ext.band(a["CLK_PLLCON"],131072)~=0 then
e=string.format("<b>PLL</b> clock (<b>%sHz</b>), bypassed from %s",val2str(t),e)
else
local n={1,2,2,4}
local i=ext.band(a["CLK_PLLCON"],511)+2
local o=ext.rshift(ext.band(a["CLK_PLLCON"],15872),9)+2
local a=n[ext.rshift(ext.band(a["CLK_PLLCON"],49152),14)+1]
t=t*i/o/a
e=string.format("<b>PLL</b> clock (<b>%sHz</b>), from %s",val2str(t),e)
end
else
e="<b>PLL</b> clock from "..e
end
end
return t,e
end
function get_sys_clock(o,a,n)
table.insert(a,"CLK_CLKSEL0")
local i=ext.band(o["CLK_CLKSEL0"],7)
local e
local t
if i==0 then
e,t=get_XTL12M_clock(o,a)
elseif i==2 then
e,t=get_PLL_clock(o,a)
elseif i==3 then
e,t=get_OSC10K_clock(o,a)
elseif i==7 then
e,t=get_OSC22M_clock(o,a)
else
e=0
t="invalid <b>"..n.."</b> clock (see CLKSEL0[2:0].HCLK_S)"
return e,t
end
if e==0 then
t="<b>"..n.."</b> clock from "..t
else
table.insert(a,"CLK_CLKDIV")
local a=ext.band(o["CLK_CLKDIV"],15)
e=e/(a+1)
t=string.format("<b>%s</b> clock (<b>%sHz</b>), from %s",n,val2str(e),t)
end
return e,t
end
function get_HCLK_clock(t,e)
return get_sys_clock(t,e,"HCLK")
end
function get_PCLK_clock(e,t)
return get_sys_clock(e,t,"PCLK")
end
function get_clk_informnation(e,t)
return reg2str("Clock setting registers",g_NUC131_regs,e,t)
end
function fill_NUC131_UART(i,t,u,a,d,e,m,l,c)
local n=""
local a=""
local o={}
local h=0
i["highlight_text"]=d
i["normal_color"]=kColor_Invalid
i["highlight_color"]=kColor_UART
i["pin_bg_color"]=kBgColor_UART
i["direction"]=kPinDirection_Unknown
i["status"]=kPinStatus_Unknown
function get_uart_baudate(n)
local i=string.format("UART%d",e)
local e=string.format("UART%d_UA_BAUD",e)
table.insert(o,e)
local o=ext.band(t[e],536870912)
local s=ext.band(t[e],268435456)
local h=ext.rshift(ext.band(t[e],251658240),24)
local a=ext.band(t[e],65535)
local e=0
local t=""
if o==0 and s==0 then
e=n/(16*(a+2))
elseif o~=0 and s==0 then
if h>=8 then
e=n/((h+1)*(a+2))
else
t="invalid "..i.."'s UA_BAUD value, DIVIDER_X must >= 8"
end
elseif o~=0 and s~=0 then
if a>=3 then
e=n/(a+2)
else
t="invalid "..i.."'s UA_BAUD value, BRD must >= 3"
end
else
t="invalid "..i.."'s UA_BAUD value"
end
return e,t
end
local s=0
if e<3 then
table.insert(o,"CLK_APBCLK")
s=ext.band(ext.rshift(t["CLK_APBCLK"],16+e),1)
else
table.insert(o,"CLK_APBCLK1")
s=ext.band(ext.rshift(t["CLK_APBCLK1"],8+(e-3)),1)
end
if s~=0 then
table.insert(o,"CLK_CLKSEL1")
local r=ext.band(ext.rshift(t["CLK_CLKSEL1"],24),3)
local d=ext.band(ext.rshift(t["CLK_CLKDIV"],8),15)
local s
local i
if r==0 then
s,i=get_XTL12M_clock(t,o)
elseif r==1 then
s,i=get_PLL_clock(t,o)
elseif r==3 then
s,i=get_OSC22M_clock(t,o)
else
a=string.format("UART%d clock is not available (see CLKSEL1[25:24].UART_S).<br>",e)
end
if a==""then
h=s/(d+1)
if h~=0 then
table.insert(o,"CLK_CLKDIV")
n=string.format("UART%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(h),i)
else
a=string.format("UART%d clock is not available, %s.<br>",e,i)
end
end
else
if e<3 then
a=string.format("UART%d clock is not available (see APBCLK[%d].UART%d_EN).<br>",
e,16+e,e)
else
a=string.format("UART%d clock is not available (see APBCLK1[%d].UART%d_EN).<br>",
e,8+(e-3),e)
end
end
if a==""then
local e,t=get_uart_baudate(h)
if e~=0 then
n=n..string.format("UART baudrate: <b>%d</b><br>",e)
else
a=t..".<br>"
end
end
if a~=""then
a="<font color=red>"..a.."</font>"
i["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
i["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
d,
a,
get_mfp_regs(t,u,m,l,c),
get_clk_informnation(t,o),
n)
end
function fill_NUC131_SPI(o,t,l,a,r,e,c,u,m)
local a=""
local n=""
local i={}
o["highlight_text"]=r
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_SPI
o["pin_bg_color"]=kBgColor_SPI
o["direction"]=kPinDirection_Unknown
o["status"]=kPinStatus_Unknown
table.insert(i,"CLK_APBCLK")
if ext.band(t["CLK_APBCLK"],ext.lshift(4096,e))~=0 then
local o
local s
table.insert(i,"CLK_CLKSEL1")
local h=ext.band(ext.rshift(t["CLK_CLKSEL1"],e+4),1)
if h==0 then
o,s=get_PLL_clock(t,i)
else
o,s=get_HCLK_clock(t,i)
end
if o~=0 then
local n=string.format("SPI%d_SPI_CNTRL",e)
local r=string.format("SPI%d_SPI_CNTRL2",e)
local h=string.format("SPI%d_SPI_DIVIDER",e)
table.insert(i,n)
local d=ext.band(t[n],262144)
if d~=0 then
a=string.format("SPI%d is in <b>slave</b> mode.<br>",e)
else
a=string.format("SPI%d is in <b>master</b> mode.<br>",e)
table.insert(i,h)
table.insert(i,r)
local d=ext.band(t[h],255)
local l=ext.band(ext.rshift(t[h],16),255)
local h=ext.band(t[r],2147483648)
local i=0
if h~=0 then
i=o/(d+1)
else
i=o/((d+1)*2)
end
local o=o/((l+1)*2)
local t=ext.band(t[n],8388608)
if t~=0 then
a=a..string.format("SPI%d clock frequency is variable: <b>%sHz</b> or <b>%sHz</b>, from %s.<br>",
e,val2str(i),val2str(o),s)
else
a=a..string.format("SPI%d clock frequency: <b>%sHz</b>, from %s.<br>",
e,val2str(i),s)
end
end
else
n=string.format("SPI%d clock is not available, %s.<br>",e,s)
end
else
n=string.format("SPI%d clock is not available (see APBCLK[%d].SPI%d_EN).<br>",e,e+12,e)
end
if n~=""then
n="<font color=red>"..n.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if a~=""then
a="<b>Information</b><br>"..a
end
o["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
r,
n,
get_mfp_regs(t,l,c,u,m),
get_clk_informnation(t,i),
a)
end
function fill_NUC131_SPI_IO(e,o,a,t)
local a=string.format("SPI%d_SPI_CNTRL",a)
local a=ext.band(o[a],262144)
if a==0 then
if t then
e["direction"]=kPinDirection_In
else
e["direction"]=kPinDirection_PushPullOut
end
else
if t then
e["direction"]=kPinDirection_PushPullOut
else
e["direction"]=kPinDirection_In
end
end
end
function fill_NUC131_ADC(a,e,u,t,h,l,r,d)
local i=""
local o=""
local t={}
a["highlight_text"]=h
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_ADC
a["pin_bg_color"]=kBgColor_ADC
a["direction"]=kPinDirection_In
a["status"]=kPinStatus_Unknown
table.insert(t,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],268435456)~=0 then
table.insert(t,"CLK_CLKSEL1")
local s=ext.rshift(ext.band(e["CLK_CLKSEL1"],12),2)
local h=ext.rshift(ext.band(e["CLK_CLKDIV"],16711680),16)
local n
local a
if s==0 then
n,a=get_XTL12M_clock(e,t)
elseif s==1 then
n,a=get_PLL_clock(e,t)
elseif s==2 then
n,a=get_HCLK_clock(e,t)
elseif s==3 then
n,a=get_OSC22M_clock(e,t)
end
if o==""then
local e=n/(h+1)
if e~=0 then
table.insert(t,"CLK_CLKDIV")
i=string.format("ADC clock frequency: <b>%sHz</b>, from %s.<br>",val2str(e),a)
else
o="ADC clock is not available, "..a..".<br>"
end
end
else
o="ADC clock is not available (see APBCLK[28].ADC_EN).<br>"
end
if o~=""then
o="<font color=red>"..o.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
a["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
h,
o,
get_mfp_regs(e,u,l,r,d),
get_clk_informnation(e,t),
i)
end
function fill_NUC131_I2C(t,o,u,a,s,e,l,d,r)
local i=""
local a=""
local n={}
t["highlight_text"]=s
t["normal_color"]=kColor_Invalid
t["highlight_color"]=kColor_I2C
t["pin_bg_color"]=kBgColor_I2C
t["direction"]=kPinDirection_Unknown
t["status"]=kPinStatus_Unknown
table.insert(n,"CLK_APBCLK")
if ext.band(o["CLK_APBCLK"],ext.lshift(256,e))~=0 then
local t=string.format("I2C%d_I2CON",e)
local s=string.format("I2C%d_I2CLK",e)
table.insert(n,t)
local t=ext.band(o[t],64)
if t~=0 then
local t,h=get_PCLK_clock(o,n)
if t~=0 then
table.insert(n,s)
local a=ext.band(o[s],255)
local t=t/(4*(a+1))
i=string.format("I2C%d clock frequency: <b>%sHz</b>, from %s.<br>",e,val2str(t),h)
else
a=string.format("I2C%d clock is not available, %s.<br>",e,h)
end
else
a=string.format("I2C%d controller disabled (see I2C%d.I2CON[6].ENS1).<br>",e,e)
end
else
a=string.format("I2C%d clock is not available (see APBCLK[%d].I2C%d_EN).<br>",e,e+8,e)
end
if a~=""then
a="<font color=red>"..a.."</font>"
t["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
t["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
s,
a,
get_mfp_regs(o,u,l,d,r),
get_clk_informnation(o,n),
i)
end
function fill_NUC131_CLKO(a,e,d,t,h,r,l,u)
local i=""
local t=""
local o={}
a["highlight_text"]=h
a["normal_color"]=kColor_Invalid
a["highlight_color"]=kColor_CLK
a["pin_bg_color"]=kBgColor_CLK
a["direction"]=kPinDirection_PushPullOut
a["status"]=kPinStatus_Unknown
table.insert(o,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],64)~=0 then
table.insert(o,"CLK_FRQDIV")
if ext.band(e["CLK_FRQDIV"],16)~=0 then
table.insert(o,"CLK_CLKSEL2")
local s=ext.rshift(ext.band(e["CLK_CLKSEL2"],12),2)
local h=ext.band(e["CLK_FRQDIV"],15)
local a
local n
if s==0 then
a,n=get_XTL12M_clock(e,o)
elseif s==2 then
a,n=get_HCLK_clock(e,o)
elseif s==3 then
a,n=get_OSC22M_clock(e,o)
else
t="FRQDIV clock is not available (see CLKSEL2[3:2].FRQDIV_S).<br>"
end
if t==""then
local o=ext.band(e["CLK_FRQDIV"],32)
local e
if o==0 then
e=a/ext.lshift(1,(h+1))
else
e=a
end
if e~=0 then
i=string.format("FRQDIV output clock frequency: <b>%sHz</b>, from %s.<br>",val2str(e),n)
else
t="FRQDIV clock is not available, "..n..".<br>"
end
end
else
t="FRQDIV disabled (see FRQDIV[4].DIVIDER_EN).<br>"
end
else
t="FRQDIV clock is not available (see APBCLK[6].FDIV_EN).<br>"
end
if t~=""then
t="<font color=red>"..t.."</font>"
a["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
a["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
h,
t,
get_mfp_regs(e,d,r,l,u),
get_clk_informnation(e,o),
i)
end
function fill_NUC131_BPWM(n,t,c,a,r,e,a,u,l,d)
local i=""
local o=""
local a={}
n["highlight_text"]=r
n["normal_color"]=kColor_Invalid
n["highlight_color"]=kColor_PWM
n["pin_bg_color"]=kBgColor_PWM
n["direction"]=kPinDirection_Unknown
n["status"]=kPinStatus_Unknown
table.insert(a,"CLK_APBCLK1")
local s=ext.band(t["CLK_APBCLK1"],ext.lshift(262144,e))
if s~=0 then
local n
local s
table.insert(a,"CLK_CLKSEL3")
local h=ext.band(ext.rshift(t["CLK_CLKSEL3"],18+e),1)
if h==0 then
n,s=get_PLL_clock(t,a)
else
n,s=get_PCLK_clock(t,a)
end
local h=string.format("BPWM%d_BPWM_CNTEN",e)
table.insert(a,h)
local h=ext.band(t[h],1)
if h==0 then
o=string.format("BPWM%d counter0_1 stops running.<br>",e)
else
local h=string.format("BPWM%d_BPWM_CLKSRC",e)
local r=string.format("BPWM%d_BPWM_CLKPSC",e)
table.insert(a,h)
local h=ext.band(t[h],7)
if h==0 then
if n==0 then
o=string.format("BPWM%d clock is not available, %s.<br>",e,s)
else
table.insert(a,r)
local t=ext.band(t[r],4095)
local t=n/(t+1)
i=string.format("BPWM%d clock frequency: <b>%sHz</b>, from %s.<br>",
e,val2str(n),s)
i=i..string.format("BPWM%d counter0_1 frequency: <b>%sHz</b> (Pre-Scaled)<br>",
e,val2str(t))
end
elseif h<=4 then
i=string.format("BPWM%d_CH01 clock source is from TIMER%d.<br>",
e,h-1)
else
o=string.format("BPWM%d_CH01 clock source is undefined (see BPWM_CLKSRC[2:0].ECLKSRC0).<br>",
e)
end
end
else
o=string.format("BPWM%d clock is not available (see CLK_APBCLK1[%d].BPWM%d_EN).<br>",
e,18+e,e)
end
if o~=""then
o="<font color=red>"..o.."</font>"
n["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
n["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
r,
o,
get_mfp_regs(t,c,u,l,d),
get_clk_informnation(t,a),
i)
end
function fill_NUC131_PWM(n,a,l,o,d,t,e,c,m,u)
local i=""
local s=""
local o={}
n["highlight_text"]=d
n["normal_color"]=kColor_Invalid
n["highlight_color"]=kColor_PWM
n["pin_bg_color"]=kBgColor_PWM
n["direction"]=kPinDirection_Unknown
n["status"]=kPinStatus_Unknown
if e~=nil then
local e=ext.rshift(e,1)
table.insert(o,"CLK_APBCLK1")
local n=ext.band(a["CLK_APBCLK1"],ext.lshift(65536,t))
if n~=0 then
local n
local h
table.insert(o,"CLK_CLKSEL3")
local r=ext.band(ext.rshift(a["CLK_CLKSEL3"],16+t),1)
if r==0 then
n,h=get_PLL_clock(a,o)
else
n,h=get_PCLK_clock(a,o)
end
local r=string.format("PWM%d_PWM_CNTEN",t)
table.insert(o,r)
local r=ext.band(ext.rshift(a[r],2*e),1)
if r==0 then
s=string.format("PWM%d counter%d_%d stops running.<br>",t,2*e,2*e+1)
else
local r=string.format("PWM%d_PWM_CLKSRC",t)
table.insert(o,r)
local r=ext.band(ext.rshift(a[r],8*e),7)
if r==0 then
if n==0 then
s=string.format("PWM%d clock is not available, %s.<br>",t,h)
else
local s=string.format("PWM%d_PWM_CLKPSC%d_%d",t,2*e,2*e+1)
table.insert(o,s)
local a=ext.band(a[s],4095)
local a=n/(a+1)
i=string.format("PWM%d clock frequency: <b>%sHz</b>, from %s.<br>",
t,val2str(n),h)
i=i..string.format("PWM%d counter%d_%d frequency: <b>%sHz</b> (Pre-Scaled)<br>",
t,2*e,2*e+1,val2str(a))
end
elseif r<=4 then
i=string.format("PWM%d_CH%d%d clock source is from TIMER%d.<br>",
t,2*e,2*e+1,r-1)
else
s=string.format("PWM%d_CH%d%d clock source is undefined (see PWM_CLKSRC[%d:%d].ECLKSRC%d).<br>",
t,2*e,2*e+1,8*e+2,8*e,2*e)
end
end
else
s=string.format("PWM%d clock is not available (see CLK_APBCLK1[%d].PWM%d_EN).<br>",
t,16+t,t)
end
end
if s~=""then
s="<font color=red>"..s.."</font>"
n["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
n["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
d,
s,
get_mfp_regs(a,l,c,m,u),
get_clk_informnation(a,o),
i)
end
function fill_NUC131_TM(o,t,c,a,r,e,u,l,d)
local i=""
local n=""
local a={}
o["highlight_text"]=r
o["normal_color"]=kColor_Invalid
o["highlight_color"]=kColor_TM
o["pin_bg_color"]=kBgColor_TM
o["direction"]=kPinDirection_Unknown
o["status"]=kPinStatus_Unknown
table.insert(a,"CLK_APBCLK")
local h=ext.band(t["CLK_APBCLK"],ext.lshift(4,e))
local s
if h~=0 then
local o=string.format("TMR%d%d_TCSR%d",ext.rshift(e,1)*2,ext.rshift(e,1)*2+1,e)
table.insert(a,o)
local o=ext.band(t[o],16777216)
if o~=0 then
i=string.format("Timer%d external counter mode enabled.<br>",e)
else
table.insert(a,"CLK_CLKSEL1")
s=ext.band(ext.rshift(t["CLK_CLKSEL1"],8+e*4),7)
local h
local o
if s==0 then
h,o=get_XTL12M_clock(t,a)
elseif s==2 then
h,o=get_HCLK_clock(t,a)
elseif s==3 then
i=string.format("Timer%d clock source from external trigger.<br>",e)
elseif s==5 then
h,o=get_OSC10K_clock(t,a)
elseif s==7 then
h,o=get_OSC22M_clock(t,a)
else
n=string.format("Timer%d clock source is undefined (see CLKSEL1[%d:%d].TMR%d_S).<br>",
e,8+e*4+2,8+e*4,e)
end
if n==""and i==""then
if h~=0 then
i=string.format("Timer%d clock frequency: <b>%sHz</b>, from %s.<br>",
e,val2str(h),o)
else
n=string.format("Timer%d clock is not available, %s.<br>",e,o)
end
end
end
else
n=string.format("Timer%d clock is disabled (see APBCLK[%d].TMR%d_EN).<br>",e,e+2,e)
end
if n~=""then
n="<font color=red>"..n.."</font>"
o["pin_no_color"]=kBgColor_Error
end
if i~=""then
i="<b>Information</b><br>"..i
end
o["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
r,
n,
get_mfp_regs(t,c,u,l,d),
get_clk_informnation(t,a),
i)
end
function fill_NUC131_CAN(t,e,u,o,h,a,d,l,r)
local n=""
local o=""
local i={}
t["highlight_text"]=h
t["normal_color"]=kColor_Invalid
t["highlight_color"]=kColor_CAN
t["pin_bg_color"]=kBgColor_CAN
t["status"]=kPinStatus_Unknown
function get_can_bitrate(o,a)
local t=string.format("CAN%d_CAN_BTIME",a)
local a=string.format("CAN%d_CAN_BRPE",a)
table.insert(i,t)
table.insert(i,a)
local i=ext.band(ext.rshift(e[t],8),15)
local n=ext.band(ext.rshift(e[t],12),7)
local e=
ext.bor(ext.band(e[t],63),
ext.lshift(ext.band(e[a],15),6))
local e=o/(e+1)/(i+n+3)
return e
end
table.insert(i,"CLK_APBCLK")
if ext.band(e["CLK_APBCLK"],ext.lshift(16777216,a))~=0 then
local s
local t
s,t=get_PCLK_clock(e,i)
if s~=0 then
local e=get_can_bitrate(s,a)
n=string.format("CAN%d baudrate: <b>%s</b>, from %s.<br>",a,val2str(e),t)
else
o=string.format("CAN%d clock is not available, %s.<br>",a,t)
end
else
o=string.format("CAN%d clock is not available (see APBCLK[%d].CAN%d_EN).<br>",a,a+24,a)
end
if o~=""then
o="<font color=red>"..o.."</font>"
t["pin_no_color"]=kBgColor_Error
end
if n~=""then
n="<b>Information</b><br>"..n
end
t["information"]=string.format("<b>%s</b><br>%s<br>%s%s%s",
h,
o,
get_mfp_regs(e,u,d,l,r),
get_clk_informnation(e,i),
n)
end
function fill_NUC131_Normal(e,s,a,h,t,n,i,r)
local o=""
e["highlight_text"]=t
e["normal_color"]=kColor_Invalid
e["highlight_color"]=kColor_Normal
e["pin_bg_color"]=kBgColor_Normal
e["direction"]=kPinDirection_Unknown
e["status"]=kPinStatus_Unknown
o=t.."<br>"
if a==nil or h==nil then
e["information"]=string.format("<b>%s</b><br>",
t)
else
e["information"]=string.format("<b>%s</b><br><br>%s",
t,
get_mfp_regs(s,a,n,i,r))
end
end

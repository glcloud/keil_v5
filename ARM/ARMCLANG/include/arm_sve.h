/*===---- arm_sve.h - ARM SVE intrinsics ---------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __ARM_SVE_H
#define __ARM_SVE_H

#if !defined(__ARM_FEATURE_SVE)
#error "SVE support not enabled"
#endif

#include <stdint.h>

#ifndef  __cplusplus
#include <stdbool.h>
#endif

typedef __fp16 float16_t;
typedef float float32_t;
typedef double float64_t;
typedef bool bool_t;

typedef __SVInt8_t svint8_t;
typedef __SVInt16_t svint16_t;
typedef __SVInt32_t svint32_t;
typedef __SVInt64_t svint64_t;
typedef __SVUint8_t svuint8_t;
typedef __SVUint16_t svuint16_t;
typedef __SVUint32_t svuint32_t;
typedef __SVUint64_t svuint64_t;
typedef __SVFloat16_t svfloat16_t;
typedef __SVFloat32_t svfloat32_t;
typedef __SVFloat64_t svfloat64_t;
typedef __SVBool_t  svbool_t;

typedef __sizeless_struct svint8x2_t {
  svint8_t v0;
  svint8_t v1;
} svint8x2_t;

typedef __sizeless_struct svint16x2_t {
  svint16_t v0;
  svint16_t v1;
} svint16x2_t;

typedef __sizeless_struct svint32x2_t {
  svint32_t v0;
  svint32_t v1;
} svint32x2_t;

typedef __sizeless_struct svint64x2_t {
  svint64_t v0;
  svint64_t v1;
} svint64x2_t;

typedef __sizeless_struct svuint8x2_t {
  svuint8_t v0;
  svuint8_t v1;
} svuint8x2_t;

typedef __sizeless_struct svuint16x2_t {
  svuint16_t v0;
  svuint16_t v1;
} svuint16x2_t;

typedef __sizeless_struct svuint32x2_t {
  svuint32_t v0;
  svuint32_t v1;
} svuint32x2_t;

typedef __sizeless_struct svuint64x2_t {
  svuint64_t v0;
  svuint64_t v1;
} svuint64x2_t;

typedef __sizeless_struct svfloat16x2_t {
  svfloat16_t v0;
  svfloat16_t v1;
} svfloat16x2_t;

typedef __sizeless_struct svfloat32x2_t {
  svfloat32_t v0;
  svfloat32_t v1;
} svfloat32x2_t;

typedef __sizeless_struct svfloat64x2_t {
  svfloat64_t v0;
  svfloat64_t v1;
} svfloat64x2_t;

typedef __sizeless_struct svint8x3_t {
  svint8_t v0;
  svint8_t v1;
  svint8_t v2;
} svint8x3_t;

typedef __sizeless_struct svint16x3_t {
  svint16_t v0;
  svint16_t v1;
  svint16_t v2;
} svint16x3_t;

typedef __sizeless_struct svint32x3_t {
  svint32_t v0;
  svint32_t v1;
  svint32_t v2;
} svint32x3_t;

typedef __sizeless_struct svint64x3_t {
  svint64_t v0;
  svint64_t v1;
  svint64_t v2;
} svint64x3_t;

typedef __sizeless_struct svuint8x3_t {
  svuint8_t v0;
  svuint8_t v1;
  svuint8_t v2;
} svuint8x3_t;

typedef __sizeless_struct svuint16x3_t {
  svuint16_t v0;
  svuint16_t v1;
  svuint16_t v2;
} svuint16x3_t;

typedef __sizeless_struct svuint32x3_t {
  svuint32_t v0;
  svuint32_t v1;
  svuint32_t v2;
} svuint32x3_t;

typedef __sizeless_struct svuint64x3_t {
  svuint64_t v0;
  svuint64_t v1;
  svuint64_t v2;
} svuint64x3_t;

typedef __sizeless_struct svfloat16x3_t {
  svfloat16_t v0;
  svfloat16_t v1;
  svfloat16_t v2;
} svfloat16x3_t;

typedef __sizeless_struct svfloat32x3_t {
  svfloat32_t v0;
  svfloat32_t v1;
  svfloat32_t v2;
} svfloat32x3_t;

typedef __sizeless_struct svfloat64x3_t {
  svfloat64_t v0;
  svfloat64_t v1;
  svfloat64_t v2;
} svfloat64x3_t;

typedef __sizeless_struct svint8x4_t {
  svint8_t v0;
  svint8_t v1;
  svint8_t v2;
  svint8_t v3;
} svint8x4_t;

typedef __sizeless_struct svint16x4_t {
  svint16_t v0;
  svint16_t v1;
  svint16_t v2;
  svint16_t v3;
} svint16x4_t;

typedef __sizeless_struct svint32x4_t {
  svint32_t v0;
  svint32_t v1;
  svint32_t v2;
  svint32_t v3;
} svint32x4_t;

typedef __sizeless_struct svint64x4_t {
  svint64_t v0;
  svint64_t v1;
  svint64_t v2;
  svint64_t v3;
} svint64x4_t;

typedef __sizeless_struct svuint8x4_t {
  svuint8_t v0;
  svuint8_t v1;
  svuint8_t v2;
  svuint8_t v3;
} svuint8x4_t;

typedef __sizeless_struct svuint16x4_t {
  svuint16_t v0;
  svuint16_t v1;
  svuint16_t v2;
  svuint16_t v3;
} svuint16x4_t;

typedef __sizeless_struct svuint32x4_t {
  svuint32_t v0;
  svuint32_t v1;
  svuint32_t v2;
  svuint32_t v3;
} svuint32x4_t;

typedef __sizeless_struct svuint64x4_t {
  svuint64_t v0;
  svuint64_t v1;
  svuint64_t v2;
  svuint64_t v3;
} svuint64x4_t;

typedef __sizeless_struct svfloat16x4_t {
  svfloat16_t v0;
  svfloat16_t v1;
  svfloat16_t v2;
  svfloat16_t v3;
} svfloat16x4_t;

typedef __sizeless_struct svfloat32x4_t {
  svfloat32_t v0;
  svfloat32_t v1;
  svfloat32_t v2;
  svfloat32_t v3;
} svfloat32x4_t;

typedef __sizeless_struct svfloat64x4_t {
  svfloat64_t v0;
  svfloat64_t v1;
  svfloat64_t v2;
  svfloat64_t v3;
} svfloat64x4_t;

typedef enum
{
  SV_POW2 = 0,
  SV_VL1 = 1,
  SV_VL2 = 2,
  SV_VL3 = 3,
  SV_VL4 = 4,
  SV_VL5 = 5,
  SV_VL6 = 6,
  SV_VL7 = 7,
  SV_VL8 = 8,
  SV_VL16 = 9,
  SV_VL32 = 10,
  SV_VL64 = 11,
  SV_VL128 = 12,
  SV_VL256 = 13,
  SV_MUL4 = 29,
  SV_MUL3 = 30,
  SV_ALL = 31
} sv_pattern;

typedef enum
{
  SV_PLDL1KEEP = 0,
  SV_PLDL1STRM = 1,
  SV_PLDL2KEEP = 2,
  SV_PLDL2STRM = 3,
  SV_PLDL3KEEP = 4,
  SV_PLDL3STRM = 5,
  SV_PSTL1KEEP = 8,
  SV_PSTL1STRM = 9,
  SV_PSTL2KEEP = 10,
  SV_PSTL2STRM = 11,
  SV_PSTL3KEEP = 12,
  SV_PSTL3STRM = 13
} sv_prfop;

/* Intruction aliases */
#define svmov_z(pg, op) ({\
  __typeof((op)) __op = (op);\
  svand_b_z((pg), __op, __op);\
})
#define svmov_b_z(pg, op) svmov_z((pg), (op))
#define svnot_b_z(pg, op) ({\
  __typeof((pg)) __pg = (pg);\
  sveor_b_z(__pg, (op), __pg);\
})

#define __ai static inline __attribute__((__always_inline__, __nodebug__))

#define __aio static inline __attribute__((__always_inline__, __nodebug__, __overloadable__))

#define __svdup(x,y) _Generic((y),\
  default: \
    _Generic((x),\
      svint8_t: __builtin_sve_svdup_n_s8,\
      svint16_t: __builtin_sve_svdup_n_s16,\
      svint32_t: __builtin_sve_svdup_n_s32,\
      svint64_t: __builtin_sve_svdup_n_s64,\
      svuint8_t: __builtin_sve_svdup_n_u8,\
      svuint16_t: __builtin_sve_svdup_n_u16,\
      svuint32_t: __builtin_sve_svdup_n_u32,\
      svuint64_t: __builtin_sve_svdup_n_u64,\
      svfloat16_t: __builtin_sve_svdup_n_f16,\
      svfloat32_t: __builtin_sve_svdup_n_f32,\
      svfloat64_t: __builtin_sve_svdup_n_f64),\
  svint8_t: __svpassthrough_s8,\
  svint16_t: __svpassthrough_s16,\
  svint32_t: __svpassthrough_s32,\
  svint64_t: __svpassthrough_s64,\
  svuint8_t: __svpassthrough_u8,\
  svuint16_t: __svpassthrough_u16,\
  svuint32_t: __svpassthrough_u32,\
  svuint64_t: __svpassthrough_u64,\
  svfloat16_t: __svpassthrough_f16,\
  svfloat32_t: __svpassthrough_f32,\
  svfloat64_t: __svpassthrough_f64)(y)

#define __svdup_wide(x,y) _Generic((y),\
  default: \
    _Generic((x),\
      svint8_t: __builtin_sve_svdup_n_s64,\
      svint16_t: __builtin_sve_svdup_n_s64,\
      svint32_t: __builtin_sve_svdup_n_s64,\
      svint64_t: __builtin_sve_svdup_n_s64,\
      svuint8_t: __builtin_sve_svdup_n_u64,\
      svuint16_t: __builtin_sve_svdup_n_u64,\
      svuint32_t: __builtin_sve_svdup_n_u64,\
      svuint64_t: __builtin_sve_svdup_n_u64,\
      svfloat16_t: __builtin_sve_svdup_n_f16,\
      svfloat32_t: __builtin_sve_svdup_n_f32,\
      svfloat64_t: __builtin_sve_svdup_n_f64),\
  svint8_t: __svpassthrough_s8,\
  svint16_t: __svpassthrough_s16,\
  svint32_t: __svpassthrough_s32,\
  svint64_t: __svpassthrough_s64,\
  svuint8_t: __svpassthrough_u8,\
  svuint16_t: __svpassthrough_u16,\
  svuint32_t: __svpassthrough_u32,\
  svuint64_t: __svpassthrough_u64,\
  svfloat16_t: __svpassthrough_f16,\
  svfloat32_t: __svpassthrough_f32,\
  svfloat64_t: __svpassthrough_f64)(y)

__ai svint8_t __svpassthrough_s8(svint8_t a) { return a; }
__ai svint16_t __svpassthrough_s16(svint16_t a) { return a; }
__ai svint32_t __svpassthrough_s32(svint32_t a) { return a; }
__ai svint64_t __svpassthrough_s64(svint64_t a) { return a; }
__ai svuint8_t __svpassthrough_u8(svuint8_t a) { return a; }
__ai svuint16_t __svpassthrough_u16(svuint16_t a) { return a; }
__ai svuint32_t __svpassthrough_u32(svuint32_t a) { return a; }
__ai svuint64_t __svpassthrough_u64(svuint64_t a) { return a; }
__ai svfloat16_t __svpassthrough_f16(svfloat16_t a) { return a; }
__ai svfloat32_t __svpassthrough_f32(svfloat32_t a) { return a; }
__ai svfloat64_t __svpassthrough_f64(svfloat64_t a) { return a; }

#define __svsel(p,x,y) _Generic((y),\
  svint8_t: __builtin_sve_svsel_s8,\
  svint16_t: __builtin_sve_svsel_s16,\
  svint32_t: __builtin_sve_svsel_s32,\
  svint64_t: __builtin_sve_svsel_s64,\
  svuint8_t: __builtin_sve_svsel_u8,\
  svuint16_t: __builtin_sve_svsel_u16,\
  svuint32_t: __builtin_sve_svsel_u32,\
  svuint64_t: __builtin_sve_svsel_u64,\
  svfloat16_t: __builtin_sve_svsel_f16,\
  svfloat32_t: __builtin_sve_svsel_f32,\
  svfloat64_t: __builtin_sve_svsel_f64)(p,x,y)

#define __svundef(x) _Generic((x),\
  svint8_t: __builtin_sve_svundef_s8,\
  svint16_t: __builtin_sve_svundef_s16,\
  svint32_t: __builtin_sve_svundef_s32,\
  svint64_t: __builtin_sve_svundef_s64,\
  svuint8_t: __builtin_sve_svundef_u8,\
  svuint16_t: __builtin_sve_svundef_u16,\
  svuint32_t: __builtin_sve_svundef_u32,\
  svuint64_t: __builtin_sve_svundef_u64,\
  svfloat16_t: __builtin_sve_svundef_f16,\
  svfloat32_t: __builtin_sve_svundef_f32,\
  svfloat64_t: __builtin_sve_svundef_f64)()

#define __svzero(x) _Generic((x),\
  svint8_t: __builtin_sve_svdup_n_s8,\
  svint16_t: __builtin_sve_svdup_n_s16,\
  svint32_t: __builtin_sve_svdup_n_s32,\
  svint64_t: __builtin_sve_svdup_n_s64,\
  svuint8_t: __builtin_sve_svdup_n_u8,\
  svuint16_t: __builtin_sve_svdup_n_u16,\
  svuint32_t: __builtin_sve_svdup_n_u32,\
  svuint64_t: __builtin_sve_svdup_n_u64,\
  svfloat16_t: __builtin_sve_svdup_n_f16,\
  svfloat32_t: __builtin_sve_svdup_n_f32,\
  svfloat64_t: __builtin_sve_svdup_n_f64)(0)

__ai svint8_t svreinterpret_s8_s8(svint8_t op) {
  return __builtin_sve_reinterpret_s8_s8(op);
}

__ai svint8_t svreinterpret_s8_s16(svint16_t op) {
  return __builtin_sve_reinterpret_s8_s16(op);
}

__ai svint8_t svreinterpret_s8_s32(svint32_t op) {
  return __builtin_sve_reinterpret_s8_s32(op);
}

__ai svint8_t svreinterpret_s8_s64(svint64_t op) {
  return __builtin_sve_reinterpret_s8_s64(op);
}

__ai svint8_t svreinterpret_s8_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_s8_u8(op);
}

__ai svint8_t svreinterpret_s8_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_s8_u16(op);
}

__ai svint8_t svreinterpret_s8_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_s8_u32(op);
}

__ai svint8_t svreinterpret_s8_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_s8_u64(op);
}

__ai svint8_t svreinterpret_s8_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_s8_f16(op);
}

__ai svint8_t svreinterpret_s8_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_s8_f32(op);
}

__ai svint8_t svreinterpret_s8_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_s8_f64(op);
}

__ai svint16_t svreinterpret_s16_s8(svint8_t op) {
  return __builtin_sve_reinterpret_s16_s8(op);
}

__ai svint16_t svreinterpret_s16_s16(svint16_t op) {
  return __builtin_sve_reinterpret_s16_s16(op);
}

__ai svint16_t svreinterpret_s16_s32(svint32_t op) {
  return __builtin_sve_reinterpret_s16_s32(op);
}

__ai svint16_t svreinterpret_s16_s64(svint64_t op) {
  return __builtin_sve_reinterpret_s16_s64(op);
}

__ai svint16_t svreinterpret_s16_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_s16_u8(op);
}

__ai svint16_t svreinterpret_s16_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_s16_u16(op);
}

__ai svint16_t svreinterpret_s16_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_s16_u32(op);
}

__ai svint16_t svreinterpret_s16_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_s16_u64(op);
}

__ai svint16_t svreinterpret_s16_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_s16_f16(op);
}

__ai svint16_t svreinterpret_s16_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_s16_f32(op);
}

__ai svint16_t svreinterpret_s16_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_s16_f64(op);
}

__ai svint32_t svreinterpret_s32_s8(svint8_t op) {
  return __builtin_sve_reinterpret_s32_s8(op);
}

__ai svint32_t svreinterpret_s32_s16(svint16_t op) {
  return __builtin_sve_reinterpret_s32_s16(op);
}

__ai svint32_t svreinterpret_s32_s32(svint32_t op) {
  return __builtin_sve_reinterpret_s32_s32(op);
}

__ai svint32_t svreinterpret_s32_s64(svint64_t op) {
  return __builtin_sve_reinterpret_s32_s64(op);
}

__ai svint32_t svreinterpret_s32_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_s32_u8(op);
}

__ai svint32_t svreinterpret_s32_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_s32_u16(op);
}

__ai svint32_t svreinterpret_s32_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_s32_u32(op);
}

__ai svint32_t svreinterpret_s32_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_s32_u64(op);
}

__ai svint32_t svreinterpret_s32_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_s32_f16(op);
}

__ai svint32_t svreinterpret_s32_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_s32_f32(op);
}

__ai svint32_t svreinterpret_s32_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_s32_f64(op);
}

__ai svint64_t svreinterpret_s64_s8(svint8_t op) {
  return __builtin_sve_reinterpret_s64_s8(op);
}

__ai svint64_t svreinterpret_s64_s16(svint16_t op) {
  return __builtin_sve_reinterpret_s64_s16(op);
}

__ai svint64_t svreinterpret_s64_s32(svint32_t op) {
  return __builtin_sve_reinterpret_s64_s32(op);
}

__ai svint64_t svreinterpret_s64_s64(svint64_t op) {
  return __builtin_sve_reinterpret_s64_s64(op);
}

__ai svint64_t svreinterpret_s64_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_s64_u8(op);
}

__ai svint64_t svreinterpret_s64_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_s64_u16(op);
}

__ai svint64_t svreinterpret_s64_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_s64_u32(op);
}

__ai svint64_t svreinterpret_s64_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_s64_u64(op);
}

__ai svint64_t svreinterpret_s64_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_s64_f16(op);
}

__ai svint64_t svreinterpret_s64_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_s64_f32(op);
}

__ai svint64_t svreinterpret_s64_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_s64_f64(op);
}

__ai svuint8_t svreinterpret_u8_s8(svint8_t op) {
  return __builtin_sve_reinterpret_u8_s8(op);
}

__ai svuint8_t svreinterpret_u8_s16(svint16_t op) {
  return __builtin_sve_reinterpret_u8_s16(op);
}

__ai svuint8_t svreinterpret_u8_s32(svint32_t op) {
  return __builtin_sve_reinterpret_u8_s32(op);
}

__ai svuint8_t svreinterpret_u8_s64(svint64_t op) {
  return __builtin_sve_reinterpret_u8_s64(op);
}

__ai svuint8_t svreinterpret_u8_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_u8_u8(op);
}

__ai svuint8_t svreinterpret_u8_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_u8_u16(op);
}

__ai svuint8_t svreinterpret_u8_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_u8_u32(op);
}

__ai svuint8_t svreinterpret_u8_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_u8_u64(op);
}

__ai svuint8_t svreinterpret_u8_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_u8_f16(op);
}

__ai svuint8_t svreinterpret_u8_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_u8_f32(op);
}

__ai svuint8_t svreinterpret_u8_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_u8_f64(op);
}

__ai svuint16_t svreinterpret_u16_s8(svint8_t op) {
  return __builtin_sve_reinterpret_u16_s8(op);
}

__ai svuint16_t svreinterpret_u16_s16(svint16_t op) {
  return __builtin_sve_reinterpret_u16_s16(op);
}

__ai svuint16_t svreinterpret_u16_s32(svint32_t op) {
  return __builtin_sve_reinterpret_u16_s32(op);
}

__ai svuint16_t svreinterpret_u16_s64(svint64_t op) {
  return __builtin_sve_reinterpret_u16_s64(op);
}

__ai svuint16_t svreinterpret_u16_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_u16_u8(op);
}

__ai svuint16_t svreinterpret_u16_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_u16_u16(op);
}

__ai svuint16_t svreinterpret_u16_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_u16_u32(op);
}

__ai svuint16_t svreinterpret_u16_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_u16_u64(op);
}

__ai svuint16_t svreinterpret_u16_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_u16_f16(op);
}

__ai svuint16_t svreinterpret_u16_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_u16_f32(op);
}

__ai svuint16_t svreinterpret_u16_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_u16_f64(op);
}

__ai svuint32_t svreinterpret_u32_s8(svint8_t op) {
  return __builtin_sve_reinterpret_u32_s8(op);
}

__ai svuint32_t svreinterpret_u32_s16(svint16_t op) {
  return __builtin_sve_reinterpret_u32_s16(op);
}

__ai svuint32_t svreinterpret_u32_s32(svint32_t op) {
  return __builtin_sve_reinterpret_u32_s32(op);
}

__ai svuint32_t svreinterpret_u32_s64(svint64_t op) {
  return __builtin_sve_reinterpret_u32_s64(op);
}

__ai svuint32_t svreinterpret_u32_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_u32_u8(op);
}

__ai svuint32_t svreinterpret_u32_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_u32_u16(op);
}

__ai svuint32_t svreinterpret_u32_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_u32_u32(op);
}

__ai svuint32_t svreinterpret_u32_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_u32_u64(op);
}

__ai svuint32_t svreinterpret_u32_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_u32_f16(op);
}

__ai svuint32_t svreinterpret_u32_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_u32_f32(op);
}

__ai svuint32_t svreinterpret_u32_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_u32_f64(op);
}

__ai svuint64_t svreinterpret_u64_s8(svint8_t op) {
  return __builtin_sve_reinterpret_u64_s8(op);
}

__ai svuint64_t svreinterpret_u64_s16(svint16_t op) {
  return __builtin_sve_reinterpret_u64_s16(op);
}

__ai svuint64_t svreinterpret_u64_s32(svint32_t op) {
  return __builtin_sve_reinterpret_u64_s32(op);
}

__ai svuint64_t svreinterpret_u64_s64(svint64_t op) {
  return __builtin_sve_reinterpret_u64_s64(op);
}

__ai svuint64_t svreinterpret_u64_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_u64_u8(op);
}

__ai svuint64_t svreinterpret_u64_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_u64_u16(op);
}

__ai svuint64_t svreinterpret_u64_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_u64_u32(op);
}

__ai svuint64_t svreinterpret_u64_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_u64_u64(op);
}

__ai svuint64_t svreinterpret_u64_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_u64_f16(op);
}

__ai svuint64_t svreinterpret_u64_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_u64_f32(op);
}

__ai svuint64_t svreinterpret_u64_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_u64_f64(op);
}

__ai svfloat16_t svreinterpret_f16_s8(svint8_t op) {
  return __builtin_sve_reinterpret_f16_s8(op);
}

__ai svfloat16_t svreinterpret_f16_s16(svint16_t op) {
  return __builtin_sve_reinterpret_f16_s16(op);
}

__ai svfloat16_t svreinterpret_f16_s32(svint32_t op) {
  return __builtin_sve_reinterpret_f16_s32(op);
}

__ai svfloat16_t svreinterpret_f16_s64(svint64_t op) {
  return __builtin_sve_reinterpret_f16_s64(op);
}

__ai svfloat16_t svreinterpret_f16_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_f16_u8(op);
}

__ai svfloat16_t svreinterpret_f16_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_f16_u16(op);
}

__ai svfloat16_t svreinterpret_f16_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_f16_u32(op);
}

__ai svfloat16_t svreinterpret_f16_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_f16_u64(op);
}

__ai svfloat16_t svreinterpret_f16_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_f16_f16(op);
}

__ai svfloat16_t svreinterpret_f16_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_f16_f32(op);
}

__ai svfloat16_t svreinterpret_f16_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_f16_f64(op);
}

__ai svfloat32_t svreinterpret_f32_s8(svint8_t op) {
  return __builtin_sve_reinterpret_f32_s8(op);
}

__ai svfloat32_t svreinterpret_f32_s16(svint16_t op) {
  return __builtin_sve_reinterpret_f32_s16(op);
}

__ai svfloat32_t svreinterpret_f32_s32(svint32_t op) {
  return __builtin_sve_reinterpret_f32_s32(op);
}

__ai svfloat32_t svreinterpret_f32_s64(svint64_t op) {
  return __builtin_sve_reinterpret_f32_s64(op);
}

__ai svfloat32_t svreinterpret_f32_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_f32_u8(op);
}

__ai svfloat32_t svreinterpret_f32_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_f32_u16(op);
}

__ai svfloat32_t svreinterpret_f32_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_f32_u32(op);
}

__ai svfloat32_t svreinterpret_f32_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_f32_u64(op);
}

__ai svfloat32_t svreinterpret_f32_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_f32_f16(op);
}

__ai svfloat32_t svreinterpret_f32_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_f32_f32(op);
}

__ai svfloat32_t svreinterpret_f32_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_f32_f64(op);
}

__ai svfloat64_t svreinterpret_f64_s8(svint8_t op) {
  return __builtin_sve_reinterpret_f64_s8(op);
}

__ai svfloat64_t svreinterpret_f64_s16(svint16_t op) {
  return __builtin_sve_reinterpret_f64_s16(op);
}

__ai svfloat64_t svreinterpret_f64_s32(svint32_t op) {
  return __builtin_sve_reinterpret_f64_s32(op);
}

__ai svfloat64_t svreinterpret_f64_s64(svint64_t op) {
  return __builtin_sve_reinterpret_f64_s64(op);
}

__ai svfloat64_t svreinterpret_f64_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_f64_u8(op);
}

__ai svfloat64_t svreinterpret_f64_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_f64_u16(op);
}

__ai svfloat64_t svreinterpret_f64_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_f64_u32(op);
}

__ai svfloat64_t svreinterpret_f64_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_f64_u64(op);
}

__ai svfloat64_t svreinterpret_f64_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_f64_f16(op);
}

__ai svfloat64_t svreinterpret_f64_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_f64_f32(op);
}

__ai svfloat64_t svreinterpret_f64_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_f64_f64(op);
}

__aio svint8_t svreinterpret_s8(svint8_t op) {
  return __builtin_sve_reinterpret_s8_s8(op);
}

__aio svint8_t svreinterpret_s8(svint16_t op) {
  return __builtin_sve_reinterpret_s8_s16(op);
}

__aio svint8_t svreinterpret_s8(svint32_t op) {
  return __builtin_sve_reinterpret_s8_s32(op);
}

__aio svint8_t svreinterpret_s8(svint64_t op) {
  return __builtin_sve_reinterpret_s8_s64(op);
}

__aio svint8_t svreinterpret_s8(svuint8_t op) {
  return __builtin_sve_reinterpret_s8_u8(op);
}

__aio svint8_t svreinterpret_s8(svuint16_t op) {
  return __builtin_sve_reinterpret_s8_u16(op);
}

__aio svint8_t svreinterpret_s8(svuint32_t op) {
  return __builtin_sve_reinterpret_s8_u32(op);
}

__aio svint8_t svreinterpret_s8(svuint64_t op) {
  return __builtin_sve_reinterpret_s8_u64(op);
}

__aio svint8_t svreinterpret_s8(svfloat16_t op) {
  return __builtin_sve_reinterpret_s8_f16(op);
}

__aio svint8_t svreinterpret_s8(svfloat32_t op) {
  return __builtin_sve_reinterpret_s8_f32(op);
}

__aio svint8_t svreinterpret_s8(svfloat64_t op) {
  return __builtin_sve_reinterpret_s8_f64(op);
}

__aio svint16_t svreinterpret_s16(svint8_t op) {
  return __builtin_sve_reinterpret_s16_s8(op);
}

__aio svint16_t svreinterpret_s16(svint16_t op) {
  return __builtin_sve_reinterpret_s16_s16(op);
}

__aio svint16_t svreinterpret_s16(svint32_t op) {
  return __builtin_sve_reinterpret_s16_s32(op);
}

__aio svint16_t svreinterpret_s16(svint64_t op) {
  return __builtin_sve_reinterpret_s16_s64(op);
}

__aio svint16_t svreinterpret_s16(svuint8_t op) {
  return __builtin_sve_reinterpret_s16_u8(op);
}

__aio svint16_t svreinterpret_s16(svuint16_t op) {
  return __builtin_sve_reinterpret_s16_u16(op);
}

__aio svint16_t svreinterpret_s16(svuint32_t op) {
  return __builtin_sve_reinterpret_s16_u32(op);
}

__aio svint16_t svreinterpret_s16(svuint64_t op) {
  return __builtin_sve_reinterpret_s16_u64(op);
}

__aio svint16_t svreinterpret_s16(svfloat16_t op) {
  return __builtin_sve_reinterpret_s16_f16(op);
}

__aio svint16_t svreinterpret_s16(svfloat32_t op) {
  return __builtin_sve_reinterpret_s16_f32(op);
}

__aio svint16_t svreinterpret_s16(svfloat64_t op) {
  return __builtin_sve_reinterpret_s16_f64(op);
}

__aio svint32_t svreinterpret_s32(svint8_t op) {
  return __builtin_sve_reinterpret_s32_s8(op);
}

__aio svint32_t svreinterpret_s32(svint16_t op) {
  return __builtin_sve_reinterpret_s32_s16(op);
}

__aio svint32_t svreinterpret_s32(svint32_t op) {
  return __builtin_sve_reinterpret_s32_s32(op);
}

__aio svint32_t svreinterpret_s32(svint64_t op) {
  return __builtin_sve_reinterpret_s32_s64(op);
}

__aio svint32_t svreinterpret_s32(svuint8_t op) {
  return __builtin_sve_reinterpret_s32_u8(op);
}

__aio svint32_t svreinterpret_s32(svuint16_t op) {
  return __builtin_sve_reinterpret_s32_u16(op);
}

__aio svint32_t svreinterpret_s32(svuint32_t op) {
  return __builtin_sve_reinterpret_s32_u32(op);
}

__aio svint32_t svreinterpret_s32(svuint64_t op) {
  return __builtin_sve_reinterpret_s32_u64(op);
}

__aio svint32_t svreinterpret_s32(svfloat16_t op) {
  return __builtin_sve_reinterpret_s32_f16(op);
}

__aio svint32_t svreinterpret_s32(svfloat32_t op) {
  return __builtin_sve_reinterpret_s32_f32(op);
}

__aio svint32_t svreinterpret_s32(svfloat64_t op) {
  return __builtin_sve_reinterpret_s32_f64(op);
}

__aio svint64_t svreinterpret_s64(svint8_t op) {
  return __builtin_sve_reinterpret_s64_s8(op);
}

__aio svint64_t svreinterpret_s64(svint16_t op) {
  return __builtin_sve_reinterpret_s64_s16(op);
}

__aio svint64_t svreinterpret_s64(svint32_t op) {
  return __builtin_sve_reinterpret_s64_s32(op);
}

__aio svint64_t svreinterpret_s64(svint64_t op) {
  return __builtin_sve_reinterpret_s64_s64(op);
}

__aio svint64_t svreinterpret_s64(svuint8_t op) {
  return __builtin_sve_reinterpret_s64_u8(op);
}

__aio svint64_t svreinterpret_s64(svuint16_t op) {
  return __builtin_sve_reinterpret_s64_u16(op);
}

__aio svint64_t svreinterpret_s64(svuint32_t op) {
  return __builtin_sve_reinterpret_s64_u32(op);
}

__aio svint64_t svreinterpret_s64(svuint64_t op) {
  return __builtin_sve_reinterpret_s64_u64(op);
}

__aio svint64_t svreinterpret_s64(svfloat16_t op) {
  return __builtin_sve_reinterpret_s64_f16(op);
}

__aio svint64_t svreinterpret_s64(svfloat32_t op) {
  return __builtin_sve_reinterpret_s64_f32(op);
}

__aio svint64_t svreinterpret_s64(svfloat64_t op) {
  return __builtin_sve_reinterpret_s64_f64(op);
}

__aio svuint8_t svreinterpret_u8(svint8_t op) {
  return __builtin_sve_reinterpret_u8_s8(op);
}

__aio svuint8_t svreinterpret_u8(svint16_t op) {
  return __builtin_sve_reinterpret_u8_s16(op);
}

__aio svuint8_t svreinterpret_u8(svint32_t op) {
  return __builtin_sve_reinterpret_u8_s32(op);
}

__aio svuint8_t svreinterpret_u8(svint64_t op) {
  return __builtin_sve_reinterpret_u8_s64(op);
}

__aio svuint8_t svreinterpret_u8(svuint8_t op) {
  return __builtin_sve_reinterpret_u8_u8(op);
}

__aio svuint8_t svreinterpret_u8(svuint16_t op) {
  return __builtin_sve_reinterpret_u8_u16(op);
}

__aio svuint8_t svreinterpret_u8(svuint32_t op) {
  return __builtin_sve_reinterpret_u8_u32(op);
}

__aio svuint8_t svreinterpret_u8(svuint64_t op) {
  return __builtin_sve_reinterpret_u8_u64(op);
}

__aio svuint8_t svreinterpret_u8(svfloat16_t op) {
  return __builtin_sve_reinterpret_u8_f16(op);
}

__aio svuint8_t svreinterpret_u8(svfloat32_t op) {
  return __builtin_sve_reinterpret_u8_f32(op);
}

__aio svuint8_t svreinterpret_u8(svfloat64_t op) {
  return __builtin_sve_reinterpret_u8_f64(op);
}

__aio svuint16_t svreinterpret_u16(svint8_t op) {
  return __builtin_sve_reinterpret_u16_s8(op);
}

__aio svuint16_t svreinterpret_u16(svint16_t op) {
  return __builtin_sve_reinterpret_u16_s16(op);
}

__aio svuint16_t svreinterpret_u16(svint32_t op) {
  return __builtin_sve_reinterpret_u16_s32(op);
}

__aio svuint16_t svreinterpret_u16(svint64_t op) {
  return __builtin_sve_reinterpret_u16_s64(op);
}

__aio svuint16_t svreinterpret_u16(svuint8_t op) {
  return __builtin_sve_reinterpret_u16_u8(op);
}

__aio svuint16_t svreinterpret_u16(svuint16_t op) {
  return __builtin_sve_reinterpret_u16_u16(op);
}

__aio svuint16_t svreinterpret_u16(svuint32_t op) {
  return __builtin_sve_reinterpret_u16_u32(op);
}

__aio svuint16_t svreinterpret_u16(svuint64_t op) {
  return __builtin_sve_reinterpret_u16_u64(op);
}

__aio svuint16_t svreinterpret_u16(svfloat16_t op) {
  return __builtin_sve_reinterpret_u16_f16(op);
}

__aio svuint16_t svreinterpret_u16(svfloat32_t op) {
  return __builtin_sve_reinterpret_u16_f32(op);
}

__aio svuint16_t svreinterpret_u16(svfloat64_t op) {
  return __builtin_sve_reinterpret_u16_f64(op);
}

__aio svuint32_t svreinterpret_u32(svint8_t op) {
  return __builtin_sve_reinterpret_u32_s8(op);
}

__aio svuint32_t svreinterpret_u32(svint16_t op) {
  return __builtin_sve_reinterpret_u32_s16(op);
}

__aio svuint32_t svreinterpret_u32(svint32_t op) {
  return __builtin_sve_reinterpret_u32_s32(op);
}

__aio svuint32_t svreinterpret_u32(svint64_t op) {
  return __builtin_sve_reinterpret_u32_s64(op);
}

__aio svuint32_t svreinterpret_u32(svuint8_t op) {
  return __builtin_sve_reinterpret_u32_u8(op);
}

__aio svuint32_t svreinterpret_u32(svuint16_t op) {
  return __builtin_sve_reinterpret_u32_u16(op);
}

__aio svuint32_t svreinterpret_u32(svuint32_t op) {
  return __builtin_sve_reinterpret_u32_u32(op);
}

__aio svuint32_t svreinterpret_u32(svuint64_t op) {
  return __builtin_sve_reinterpret_u32_u64(op);
}

__aio svuint32_t svreinterpret_u32(svfloat16_t op) {
  return __builtin_sve_reinterpret_u32_f16(op);
}

__aio svuint32_t svreinterpret_u32(svfloat32_t op) {
  return __builtin_sve_reinterpret_u32_f32(op);
}

__aio svuint32_t svreinterpret_u32(svfloat64_t op) {
  return __builtin_sve_reinterpret_u32_f64(op);
}

__aio svuint64_t svreinterpret_u64(svint8_t op) {
  return __builtin_sve_reinterpret_u64_s8(op);
}

__aio svuint64_t svreinterpret_u64(svint16_t op) {
  return __builtin_sve_reinterpret_u64_s16(op);
}

__aio svuint64_t svreinterpret_u64(svint32_t op) {
  return __builtin_sve_reinterpret_u64_s32(op);
}

__aio svuint64_t svreinterpret_u64(svint64_t op) {
  return __builtin_sve_reinterpret_u64_s64(op);
}

__aio svuint64_t svreinterpret_u64(svuint8_t op) {
  return __builtin_sve_reinterpret_u64_u8(op);
}

__aio svuint64_t svreinterpret_u64(svuint16_t op) {
  return __builtin_sve_reinterpret_u64_u16(op);
}

__aio svuint64_t svreinterpret_u64(svuint32_t op) {
  return __builtin_sve_reinterpret_u64_u32(op);
}

__aio svuint64_t svreinterpret_u64(svuint64_t op) {
  return __builtin_sve_reinterpret_u64_u64(op);
}

__aio svuint64_t svreinterpret_u64(svfloat16_t op) {
  return __builtin_sve_reinterpret_u64_f16(op);
}

__aio svuint64_t svreinterpret_u64(svfloat32_t op) {
  return __builtin_sve_reinterpret_u64_f32(op);
}

__aio svuint64_t svreinterpret_u64(svfloat64_t op) {
  return __builtin_sve_reinterpret_u64_f64(op);
}

__aio svfloat16_t svreinterpret_f16(svint8_t op) {
  return __builtin_sve_reinterpret_f16_s8(op);
}

__aio svfloat16_t svreinterpret_f16(svint16_t op) {
  return __builtin_sve_reinterpret_f16_s16(op);
}

__aio svfloat16_t svreinterpret_f16(svint32_t op) {
  return __builtin_sve_reinterpret_f16_s32(op);
}

__aio svfloat16_t svreinterpret_f16(svint64_t op) {
  return __builtin_sve_reinterpret_f16_s64(op);
}

__aio svfloat16_t svreinterpret_f16(svuint8_t op) {
  return __builtin_sve_reinterpret_f16_u8(op);
}

__aio svfloat16_t svreinterpret_f16(svuint16_t op) {
  return __builtin_sve_reinterpret_f16_u16(op);
}

__aio svfloat16_t svreinterpret_f16(svuint32_t op) {
  return __builtin_sve_reinterpret_f16_u32(op);
}

__aio svfloat16_t svreinterpret_f16(svuint64_t op) {
  return __builtin_sve_reinterpret_f16_u64(op);
}

__aio svfloat16_t svreinterpret_f16(svfloat16_t op) {
  return __builtin_sve_reinterpret_f16_f16(op);
}

__aio svfloat16_t svreinterpret_f16(svfloat32_t op) {
  return __builtin_sve_reinterpret_f16_f32(op);
}

__aio svfloat16_t svreinterpret_f16(svfloat64_t op) {
  return __builtin_sve_reinterpret_f16_f64(op);
}

__aio svfloat32_t svreinterpret_f32(svint8_t op) {
  return __builtin_sve_reinterpret_f32_s8(op);
}

__aio svfloat32_t svreinterpret_f32(svint16_t op) {
  return __builtin_sve_reinterpret_f32_s16(op);
}

__aio svfloat32_t svreinterpret_f32(svint32_t op) {
  return __builtin_sve_reinterpret_f32_s32(op);
}

__aio svfloat32_t svreinterpret_f32(svint64_t op) {
  return __builtin_sve_reinterpret_f32_s64(op);
}

__aio svfloat32_t svreinterpret_f32(svuint8_t op) {
  return __builtin_sve_reinterpret_f32_u8(op);
}

__aio svfloat32_t svreinterpret_f32(svuint16_t op) {
  return __builtin_sve_reinterpret_f32_u16(op);
}

__aio svfloat32_t svreinterpret_f32(svuint32_t op) {
  return __builtin_sve_reinterpret_f32_u32(op);
}

__aio svfloat32_t svreinterpret_f32(svuint64_t op) {
  return __builtin_sve_reinterpret_f32_u64(op);
}

__aio svfloat32_t svreinterpret_f32(svfloat16_t op) {
  return __builtin_sve_reinterpret_f32_f16(op);
}

__aio svfloat32_t svreinterpret_f32(svfloat32_t op) {
  return __builtin_sve_reinterpret_f32_f32(op);
}

__aio svfloat32_t svreinterpret_f32(svfloat64_t op) {
  return __builtin_sve_reinterpret_f32_f64(op);
}

__aio svfloat64_t svreinterpret_f64(svint8_t op) {
  return __builtin_sve_reinterpret_f64_s8(op);
}

__aio svfloat64_t svreinterpret_f64(svint16_t op) {
  return __builtin_sve_reinterpret_f64_s16(op);
}

__aio svfloat64_t svreinterpret_f64(svint32_t op) {
  return __builtin_sve_reinterpret_f64_s32(op);
}

__aio svfloat64_t svreinterpret_f64(svint64_t op) {
  return __builtin_sve_reinterpret_f64_s64(op);
}

__aio svfloat64_t svreinterpret_f64(svuint8_t op) {
  return __builtin_sve_reinterpret_f64_u8(op);
}

__aio svfloat64_t svreinterpret_f64(svuint16_t op) {
  return __builtin_sve_reinterpret_f64_u16(op);
}

__aio svfloat64_t svreinterpret_f64(svuint32_t op) {
  return __builtin_sve_reinterpret_f64_u32(op);
}

__aio svfloat64_t svreinterpret_f64(svuint64_t op) {
  return __builtin_sve_reinterpret_f64_u64(op);
}

__aio svfloat64_t svreinterpret_f64(svfloat16_t op) {
  return __builtin_sve_reinterpret_f64_f16(op);
}

__aio svfloat64_t svreinterpret_f64(svfloat32_t op) {
  return __builtin_sve_reinterpret_f64_f32(op);
}

__aio svfloat64_t svreinterpret_f64(svfloat64_t op) {
  return __builtin_sve_reinterpret_f64_f64(op);
}

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabd_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svabd_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabd_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svabd_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svabd_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svabd_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabd_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svabd_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabd_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svabd_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svabd_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svabd_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabd_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabd_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svabd_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svabd_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabd_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svabd_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabd_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svabd_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabd_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svabd_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabd_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svabd_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabd_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svabd_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabd_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svabd_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabd_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svabd_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabd_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svabd_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabd_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabd_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabd_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabd_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svabd_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svabd_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svabd_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svabd_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svabd_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svabd_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svabd_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svabd_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svabd_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svabd_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svabd_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svabd_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svabd_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svabd_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svabd_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svabd_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svabd_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svabd_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svabd_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svabd_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabd_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svabd_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabd_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svabd_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svabd_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svabd_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabd_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svabd_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabd_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svabd_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svabd_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svabd_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabd_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabd_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svabd_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabd_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svabd_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabd_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svabd_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabd_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svabd_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabd_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svabd_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabd_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svabd_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabd_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svabd_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabd_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svabd_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabd_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svabd_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabd_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabd_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabd_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabd_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svabd_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svabd_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svabd_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svabd_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svabd_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svabd_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svabd_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svabd_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svabd_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svabd_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svabd_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svabd_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svabd_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svabd_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svabd_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svabd_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svabd_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svabd_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svabd_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svabd_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svabd_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabs_s8_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svabs_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabs_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svabs_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabs_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svabs_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svabs_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svabs_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabs_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svabs_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabs_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svabs_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabs_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svabs_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabs_s8_x(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svabs_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabs_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svabs_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabs_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svabs_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svabs_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svabs_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabs_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svabs_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabs_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svabs_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabs_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svabs_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svabs_s8_z(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svabs_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svabs_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svabs_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svabs_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svabs_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svabs_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svabs_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svabs_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svabs_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svabs_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svabs_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svabs_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svabs_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacge_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svacge_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacge_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svacge_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svacge_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svacge_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacge_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacge_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacge_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacge_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacge_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacge_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacgt_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svacgt_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacgt_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svacgt_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svacgt_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svacgt_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacgt_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacgt_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacgt_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacgt_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacgt_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacgt_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacle_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svacle_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacle_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svacle_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svacle_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svacle_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacle_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacle_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacle_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacle_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svacle_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svacle_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svaclt_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svaclt_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svaclt_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svaclt_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svaclt_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svaclt_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svaclt_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svaclt_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svaclt_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svaclt_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svaclt_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svaclt_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svadd_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svadd_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadd_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svadd_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadd_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svadd_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svadd_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svadd_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svadd_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svadd_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svadd_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svadd_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svadd_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svadd_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadd_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svadd_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svadd_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svadd_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svadd_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svadd_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svadd_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svadd_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svadd_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svadd_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadd_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svadd_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadd_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svadd_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svadd_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svadd_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svadd_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svadd_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svadd_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svadd_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svadd_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svadd_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadd_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svadd_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svadd_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svadd_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svadd_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svadd_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svadd_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svadd_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svadd_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadd_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadd_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svadd_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svadd_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svadd_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svadd_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadd_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svadd_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svadd_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svadd_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svadd_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svadd_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svadd_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadd_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadd_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadd_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadd_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svadd_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svadd_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svadd_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svadd_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svadd_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svadd_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svadd_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svadd_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svadd_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svadd_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svadd_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svadd_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svadd_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svadd_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svadd_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svadd_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svadd_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svadd_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadd_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadd_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadd_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadd_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svadd_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svadd_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svadd_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svadd_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svadd_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svadd_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svadd_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svadd_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svadd_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svadd_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svadd_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svadd_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svadd_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svadd_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svadd_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svadd_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svadd_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadd_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadd_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svadd_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svadd_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svadd_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svadd_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svadd_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svadd_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svadd_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svadd_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svadd_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svadda_f64(svbool_t __p0, float64_t __p1, svfloat64_t __p2) {
  float64_t __ret;
  __ret = __builtin_sve_svadda_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svadda_f32(svbool_t __p0, float32_t __p1, svfloat32_t __p2) {
  float32_t __ret;
  __ret = __builtin_sve_svadda_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadda_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __ret; \
  __ret = __builtin_sve_svadda_f16(__s0, __s1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svaddv_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svaddv_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svaddv_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svaddv_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svaddv_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svaddv_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svaddv_s8(svbool_t __p0, svint8_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svaddv_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svaddv_s32(svbool_t __p0, svint32_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svaddv_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svaddv_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svaddv_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svaddv_s16(svbool_t __p0, svint16_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svaddv_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svaddv_u8(svbool_t __p0, svuint8_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svaddv_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svaddv_u32(svbool_t __p0, svuint32_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svaddv_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svaddv_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svaddv_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svaddv_u16(svbool_t __p0, svuint16_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svaddv_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrb_u32base_u32offset(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrb_u32base_u32offset(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrb_u64base_u64offset(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrb_u64base_u64offset(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrb_u32base_s32offset(svuint32_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrb_u32base_s32offset(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrb_u64base_s64offset(svuint64_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrb_u64base_s64offset(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrd_u32base_u32index(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrd_u32base_u32index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrd_u64base_u64index(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrd_u64base_u64index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrd_u32base_s32index(svuint32_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrd_u32base_s32index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrd_u64base_s64index(svuint64_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrd_u64base_s64index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrh_u32base_u32index(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrh_u32base_u32index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrh_u64base_u64index(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrh_u64base_u64index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrh_u32base_s32index(svuint32_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrh_u32base_s32index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrh_u64base_s64index(svuint64_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrh_u64base_s64index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrw_u32base_u32index(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrw_u32base_u32index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrw_u64base_u64index(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrw_u64base_u64index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svadrw_u32base_s32index(svuint32_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svadrw_u32base_s32index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svadrw_u64base_s64index(svuint64_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svadrw_u64base_s64index(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svand_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svand_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svand_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svand_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svand_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svand_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svand_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svand_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svand_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svand_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svand_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svand_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svand_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svand_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svand_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svand_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svand_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svand_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svand_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svand_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svand_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svand_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svand_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svand_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svand_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svand_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svand_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svand_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svand_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svand_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svand_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svand_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svand_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svand_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svand_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svand_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svand_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svand_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svand_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svand_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svand_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svand_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svand_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svand_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svand_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svand_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svand_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svand_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svand_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svand_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svand_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svand_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svand_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svand_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svand_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svand_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svand_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svand_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svand_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svand_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svand_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svand_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svand_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svand_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svand_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svand_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svand_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svand_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svand_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svand_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svand_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svand_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svand_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svand_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svand_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svand_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svand_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svand_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svand_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svand_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svand_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svand_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svand_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svandv_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_svandv_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svandv_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svandv_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svandv_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svandv_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svandv_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_svandv_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svandv_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_svandv_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svandv_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svandv_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svandv_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svandv_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svandv_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_svandv_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svasr_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svasr_n_s64_m(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svasr_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svasr_n_s64_x(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svasr_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svasr_n_s64_z(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_n_u8_m(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_n_u32_m(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_n_u16_m(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_n_s8_m(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_n_s32_m(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_n_s16_m(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_n_u8_x(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_n_u32_x(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_n_u16_x(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_n_s8_x(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_n_s32_x(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_n_s16_x(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svasr_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_n_u8_z(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_n_u32_z(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_n_u16_z(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_n_s8_z(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_n_s32_z(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_n_s16_z(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svasr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svasr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svasr_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svasr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svasr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_s8_m(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svasr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_s32_m(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svasr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svasr_s64_m(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svasr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_s16_m(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svasr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svasr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svasr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svasr_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svasr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svasr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_s8_x(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svasr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_s32_x(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svasr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svasr_s64_x(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svasr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_s16_x(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svasr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svasr_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_s8_z(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_s32_z(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svasr_s64_z(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_s16_z(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_wide_u8_m(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svasr_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_wide_u32_m(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svasr_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_wide_u16_m(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svasr_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_wide_s8_m(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svasr_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_wide_s32_m(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svasr_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_wide_s16_m(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svasr_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_wide_u8_x(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svasr_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_wide_u32_x(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svasr_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_wide_u16_x(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svasr_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_wide_s8_x(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svasr_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_wide_s32_x(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svasr_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_wide_s16_x(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svasr_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svasr_wide_u8_z(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svasr_wide_u32_z(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svasr_wide_u16_z(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svasr_wide_s8_z(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svasr_wide_s32_z(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svasr_wide_s16_z(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svasr_wide_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s8_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint8_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svasrd_n_s8(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s32_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svasrd_n_s32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s64_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svasrd_n_s64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svasrd_n_s16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s8_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint8_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svasrd_n_s8(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s32_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svasrd_n_s32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s64_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svasrd_n_s64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svasrd_n_s16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s8_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint8_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint8_t __ret; \
  svint8_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svasrd_n_s8(__s0, __s1_z, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s32_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint32_t __ret; \
  svint32_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svasrd_n_s32(__s0, __s1_z, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s64_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint64_t __ret; \
  svint64_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svasrd_n_s64(__s0, __s1_z, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_n_s16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint16_t __ret; \
  svint16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svasrd_n_s16(__s0, __s1_z, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbic_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svbic_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svbic_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svbic_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svbic_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svbic_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svbic_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svbic_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svbic_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svbic_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svbic_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svbic_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svbic_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svbic_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svbic_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svbic_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svbic_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svbic_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svbic_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svbic_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svbic_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svbic_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svbic_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svbic_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svbic_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svbic_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svbic_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svbic_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svbic_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svbic_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svbic_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svbic_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svbic_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svbic_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svbic_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svbic_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svbic_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svbic_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svbic_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svbic_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svbic_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svbic_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svbic_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svbic_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svbic_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svbic_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svbic_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svbic_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svbic_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svbic_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svbic_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svbic_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svbic_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svbic_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svbic_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svbic_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svbic_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svbic_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svbic_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svbic_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svbic_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svbic_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svbic_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svbic_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svbic_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svbic_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svbic_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svbic_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svbic_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svbic_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svbic_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svbic_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svbic_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svbic_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svbic_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svbic_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svbic_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svbic_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svbic_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svbic_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svbic_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svbic_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svbic_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrka_b_m(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrka_b_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrka_b_z(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrka_b_z(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrkb_b_m(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrkb_b_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrkb_b_z(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrkb_b_z(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrkn_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrkn_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrkpa_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrkpa_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svbrkpb_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svbrkpb_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f64_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svcadd_f64(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f32_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svcadd_f32(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svcadd_f16(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f64_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svcadd_f64(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f32_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svcadd_f32(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svcadd_f16(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f64_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat64_t __ret; \
  svfloat64_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svcadd_f64(__s0, __s1_z, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f32_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat32_t __ret; \
  svfloat32_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svcadd_f32(__s0, __s1_z, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svcadd_f16(__s0, __s1_z, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svclasta_n_u8(svbool_t __p0, uint8_t __p1, svuint8_t __p2) {
  uint8_t __ret;
  __ret = __builtin_sve_svclasta_n_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svclasta_n_u32(svbool_t __p0, uint32_t __p1, svuint32_t __p2) {
  uint32_t __ret;
  __ret = __builtin_sve_svclasta_n_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svclasta_n_u64(svbool_t __p0, uint64_t __p1, svuint64_t __p2) {
  uint64_t __ret;
  __ret = __builtin_sve_svclasta_n_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svclasta_n_u16(svbool_t __p0, uint16_t __p1, svuint16_t __p2) {
  uint16_t __ret;
  __ret = __builtin_sve_svclasta_n_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svclasta_n_s8(svbool_t __p0, int8_t __p1, svint8_t __p2) {
  int8_t __ret;
  __ret = __builtin_sve_svclasta_n_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svclasta_n_f64(svbool_t __p0, float64_t __p1, svfloat64_t __p2) {
  float64_t __ret;
  __ret = __builtin_sve_svclasta_n_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svclasta_n_f32(svbool_t __p0, float32_t __p1, svfloat32_t __p2) {
  float32_t __ret;
  __ret = __builtin_sve_svclasta_n_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svclasta_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __ret; \
  __ret = __builtin_sve_svclasta_n_f16(__s0, __s1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svclasta_n_s32(svbool_t __p0, int32_t __p1, svint32_t __p2) {
  int32_t __ret;
  __ret = __builtin_sve_svclasta_n_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svclasta_n_s64(svbool_t __p0, int64_t __p1, svint64_t __p2) {
  int64_t __ret;
  __ret = __builtin_sve_svclasta_n_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svclasta_n_s16(svbool_t __p0, int16_t __p1, svint16_t __p2) {
  int16_t __ret;
  __ret = __builtin_sve_svclasta_n_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclasta_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclasta_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclasta_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclasta_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclasta_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclasta_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclasta_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclasta_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svclasta_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svclasta_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svclasta_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svclasta_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svclasta_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svclasta_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svclasta_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svclasta_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svclasta_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svclasta_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svclasta_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svclasta_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svclasta_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svclasta_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svclastb_n_u8(svbool_t __p0, uint8_t __p1, svuint8_t __p2) {
  uint8_t __ret;
  __ret = __builtin_sve_svclastb_n_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svclastb_n_u32(svbool_t __p0, uint32_t __p1, svuint32_t __p2) {
  uint32_t __ret;
  __ret = __builtin_sve_svclastb_n_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svclastb_n_u64(svbool_t __p0, uint64_t __p1, svuint64_t __p2) {
  uint64_t __ret;
  __ret = __builtin_sve_svclastb_n_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svclastb_n_u16(svbool_t __p0, uint16_t __p1, svuint16_t __p2) {
  uint16_t __ret;
  __ret = __builtin_sve_svclastb_n_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svclastb_n_s8(svbool_t __p0, int8_t __p1, svint8_t __p2) {
  int8_t __ret;
  __ret = __builtin_sve_svclastb_n_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svclastb_n_f64(svbool_t __p0, float64_t __p1, svfloat64_t __p2) {
  float64_t __ret;
  __ret = __builtin_sve_svclastb_n_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svclastb_n_f32(svbool_t __p0, float32_t __p1, svfloat32_t __p2) {
  float32_t __ret;
  __ret = __builtin_sve_svclastb_n_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svclastb_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __ret; \
  __ret = __builtin_sve_svclastb_n_f16(__s0, __s1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svclastb_n_s32(svbool_t __p0, int32_t __p1, svint32_t __p2) {
  int32_t __ret;
  __ret = __builtin_sve_svclastb_n_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svclastb_n_s64(svbool_t __p0, int64_t __p1, svint64_t __p2) {
  int64_t __ret;
  __ret = __builtin_sve_svclastb_n_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svclastb_n_s16(svbool_t __p0, int16_t __p1, svint16_t __p2) {
  int16_t __ret;
  __ret = __builtin_sve_svclastb_n_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclastb_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclastb_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclastb_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclastb_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclastb_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclastb_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclastb_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclastb_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svclastb_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svclastb_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svclastb_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svclastb_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svclastb_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svclastb_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svclastb_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svclastb_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svclastb_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svclastb_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svclastb_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svclastb_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svclastb_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svclastb_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcls_s8_m(svuint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcls_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcls_s32_m(svuint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcls_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcls_s64_m(svuint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcls_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcls_s16_m(svuint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcls_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcls_s8_x(svbool_t __p0, svint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcls_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcls_s32_x(svbool_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcls_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcls_s64_x(svbool_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcls_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcls_s16_x(svbool_t __p0, svint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcls_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcls_s8_z(svbool_t __p0, svint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcls_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcls_s32_z(svbool_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcls_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcls_s64_z(svbool_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcls_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcls_s16_z(svbool_t __p0, svint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcls_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclz_u8_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclz_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclz_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclz_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclz_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclz_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclz_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclz_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclz_s8_m(svuint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclz_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclz_s32_m(svuint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclz_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclz_s64_m(svuint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclz_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclz_s16_m(svuint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclz_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclz_u8_x(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclz_u8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclz_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclz_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclz_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclz_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclz_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclz_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclz_s8_x(svbool_t __p0, svint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclz_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclz_s32_x(svbool_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclz_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclz_s64_x(svbool_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclz_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclz_s16_x(svbool_t __p0, svint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclz_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclz_u8_z(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclz_u8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclz_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclz_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclz_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclz_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclz_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclz_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svclz_s8_z(svbool_t __p0, svint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svclz_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svclz_s32_z(svbool_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svclz_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svclz_s64_z(svbool_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svclz_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svclz_s16_z(svbool_t __p0, svint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svclz_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f64_m(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svcmla_f64(__s0, __s1, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f32_m(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svcmla_f32(__s0, __s1, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f16_m(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  svfloat16_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svcmla_f16(__s0, __s1, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f64_x(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svcmla_f64(__s0, __s1, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f32_x(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svcmla_f32(__s0, __s1, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f16_x(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  svfloat16_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svcmla_f16(__s0, __s1, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f64_z(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat64_t __ret; \
  svfloat64_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svcmla_f64(__s0, __s1_z, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f32_z(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat32_t __ret; \
  svfloat32_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svcmla_f32(__s0, __s1_z, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_f16_z(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  svfloat16_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat16_t __ret; \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svcmla_f16(__s0, __s1_z, __s2, __s3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_lane_f32(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svfloat32_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svcmla_lane_f32(__s0, __s1, __s2, __p3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_lane_f16(__p0, __p1, __p2, __p3, __p4) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  __attribute__((unused)) uint64_t __s4 = __p4; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svcmla_lane_f16(__s0, __s1, __s2, __p3, __p4); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_u64(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpeq_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmpeq_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmpeq_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpeq_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmpeq_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_s64(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpeq_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_u8(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpeq_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_u32(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpeq_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_u16(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpeq_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_s8(svbool_t __p0, svint8_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpeq_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_s32(svbool_t __p0, svint32_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpeq_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_n_s16(svbool_t __p0, svint16_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpeq_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_wide_u8(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_wide_u32(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_wide_u16(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_wide_s8(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_wide_s32(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpeq_wide_s16(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpeq_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmpge_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmpge_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpge_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmpge_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_s64(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpge_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_s8(svbool_t __p0, svint8_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpge_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_s32(svbool_t __p0, svint32_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpge_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_s16(svbool_t __p0, svint16_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpge_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_u64(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpge_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_u8(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpge_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_u32(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpge_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_n_u16(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpge_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_wide_s8(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_wide_s32(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_wide_s16(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_wide_u8(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_wide_u32(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpge_wide_u16(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpge_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmpgt_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmpgt_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpgt_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmpgt_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_s64(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpgt_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_s8(svbool_t __p0, svint8_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpgt_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_s32(svbool_t __p0, svint32_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpgt_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_s16(svbool_t __p0, svint16_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpgt_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_u64(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpgt_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_u8(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpgt_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_u32(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpgt_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_n_u16(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpgt_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_wide_s8(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_wide_s32(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_wide_s16(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_wide_u8(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_wide_u32(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpgt_wide_u16(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpgt_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmple_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmple_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmple_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmple_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_s64(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmple_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_s8(svbool_t __p0, svint8_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmple_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_s32(svbool_t __p0, svint32_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmple_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_s16(svbool_t __p0, svint16_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmple_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_u64(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmple_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_u8(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmple_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_u32(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmple_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_n_u16(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmple_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_wide_s8(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_wide_s32(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_wide_s16(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_wide_u8(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_wide_u32(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmple_wide_u16(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmple_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_u64(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmplt_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_u8(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmplt_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_u32(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmplt_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_u16(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmplt_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmplt_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmplt_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmplt_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmplt_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_s64(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmplt_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_s8(svbool_t __p0, svint8_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmplt_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_s32(svbool_t __p0, svint32_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmplt_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_n_s16(svbool_t __p0, svint16_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmplt_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_wide_u8(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_wide_u32(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_wide_u16(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_wide_s8(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_wide_s32(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmplt_wide_s16(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmplt_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_u64(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpne_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmpne_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmpne_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpne_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmpne_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_s64(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpne_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_u8(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpne_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_u32(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpne_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_u16(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svbool_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svcmpne_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_s8(svbool_t __p0, svint8_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpne_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_s32(svbool_t __p0, svint32_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpne_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_n_s16(svbool_t __p0, svint16_t __p1, int64_t __p2) {
  svbool_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svcmpne_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_wide_u8(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_wide_u32(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_wide_u16(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_wide_s8(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_wide_s32(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpne_wide_s16(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpne_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpuo_n_f64(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svbool_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svcmpuo_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpuo_n_f32(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svbool_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svcmpuo_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpuo_n_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svbool_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svcmpuo_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpuo_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpuo_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpuo_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpuo_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svcmpuo_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svcmpuo_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnot_u8_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnot_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnot_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnot_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnot_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnot_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnot_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnot_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svcnot_s8_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svcnot_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcnot_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svcnot_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcnot_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svcnot_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svcnot_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svcnot_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnot_u8_x(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnot_u8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnot_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnot_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnot_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnot_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnot_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnot_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svcnot_s8_x(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svcnot_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcnot_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcnot_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcnot_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcnot_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svcnot_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svcnot_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnot_u8_z(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnot_u8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnot_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnot_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnot_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnot_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnot_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnot_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svcnot_s8_z(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svcnot_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcnot_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcnot_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcnot_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcnot_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svcnot_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svcnot_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnt_u8_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnt_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnt_s8_m(svuint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnt_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_f64_m(svuint64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_f32_m(svuint32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_f16_m(svuint16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_s32_m(svuint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_s64_m(svuint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_s16_m(svuint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnt_u8_x(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnt_u8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnt_s8_x(svbool_t __p0, svint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnt_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_s32_x(svbool_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_s64_x(svbool_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_s16_x(svbool_t __p0, svint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnt_u8_z(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnt_u8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svcnt_s8_z(svbool_t __p0, svint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svcnt_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcnt_s32_z(svbool_t __p0, svint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcnt_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcnt_s64_z(svbool_t __p0, svint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcnt_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcnt_s16_z(svbool_t __p0, svint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcnt_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcntb_pat(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  uint64_t __ret; \
  __ret = __builtin_sve_svcntb_pat(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntb() {
  uint64_t __ret;
  __ret = __builtin_sve_svcntb_pat(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcntd_pat(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  uint64_t __ret; \
  __ret = __builtin_sve_svcntd_pat(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntd() {
  uint64_t __ret;
  __ret = __builtin_sve_svcntd_pat(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcnth_pat(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  uint64_t __ret; \
  __ret = __builtin_sve_svcnth_pat(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcnth() {
  uint64_t __ret;
  __ret = __builtin_sve_svcnth_pat(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntp_b8(svbool_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svcntp_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntp_b32(svbool_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svcntp_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntp_b64(svbool_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svcntp_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntp_b16(svbool_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svcntp_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcntw_pat(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  uint64_t __ret; \
  __ret = __builtin_sve_svcntw_pat(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svcntw() {
  uint64_t __ret;
  __ret = __builtin_sve_svcntw_pat(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcompact_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcompact_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcompact_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcompact_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcompact_f64(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcompact_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcompact_f32(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcompact_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcompact_s32(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcompact_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcompact_s64(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcompact_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_f64_m(svfloat16_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_f32_m(svfloat16_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_f64_m(svfloat32_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_f16_m(svfloat32_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_f32_m(svfloat64_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_f16_m(svfloat64_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_s32_m(svfloat64_t __p0, svbool_t __p1, svint32_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_s64_m(svfloat64_t __p0, svbool_t __p1, svint64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s32_x(svbool_t __p0, svint32_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s64_x(svbool_t __p0, svint64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s16_x(svbool_t __p0, svint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_s32_x(svbool_t __p0, svint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_s64_x(svbool_t __p0, svint64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_s32_x(svbool_t __p0, svint32_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_s64_x(svbool_t __p0, svint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s32_z(svbool_t __p0, svint32_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s64_z(svbool_t __p0, svint64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s16_z(svbool_t __p0, svint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_s32_z(svbool_t __p0, svint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_s64_z(svbool_t __p0, svint64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_s32_z(svbool_t __p0, svint32_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_s64_z(svbool_t __p0, svint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u32_m(svfloat16_t __p0, svbool_t __p1, svuint32_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u64_m(svfloat16_t __p0, svbool_t __p1, svuint64_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u16_m(svfloat16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_u32_m(svfloat32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_u64_m(svfloat32_t __p0, svbool_t __p1, svuint64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_u32_m(svfloat64_t __p0, svbool_t __p1, svuint32_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_u64_m(svfloat64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u32_x(svbool_t __p0, svuint32_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u64_x(svbool_t __p0, svuint64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u16_x(svbool_t __p0, svuint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_u32_x(svbool_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_u64_x(svbool_t __p0, svuint64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_u32_x(svbool_t __p0, svuint32_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_u64_x(svbool_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u32_z(svbool_t __p0, svuint32_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u64_z(svbool_t __p0, svuint64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_u16_z(svbool_t __p0, svuint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_u32_z(svbool_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_u64_z(svbool_t __p0, svuint64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_u32_z(svbool_t __p0, svuint32_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svcvt_f64_u64_z(svbool_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svcvt_f64_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s32_m(svfloat16_t __p0, svbool_t __p1, svint32_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s64_m(svfloat16_t __p0, svbool_t __p1, svint64_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svcvt_f16_s16_m(svfloat16_t __p0, svbool_t __p1, svint16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svcvt_f16_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_s32_m(svfloat32_t __p0, svbool_t __p1, svint32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svcvt_f32_s64_m(svfloat32_t __p0, svbool_t __p1, svint64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svcvt_f32_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svcvt_s16_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svcvt_s16_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svcvt_s16_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svcvt_s16_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcvt_u16_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcvt_u16_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcvt_u16_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcvt_u16_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f16_m(svint32_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f16_m(svint64_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svcvt_s16_f16_m(svint16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svcvt_s16_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f32_m(svint32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f32_m(svint64_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svcvt_s32_f64_m(svint32_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svcvt_s32_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svcvt_s64_f64_m(svint64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svcvt_s64_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f16_m(svuint32_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f16_m(svuint64_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svcvt_u16_f16_m(svuint16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svcvt_u16_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f32_m(svuint32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f32_m(svuint64_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svcvt_u32_f64_m(svuint32_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svcvt_u32_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svcvt_u64_f64_m(svuint64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svcvt_u64_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdiv_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svdiv_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdiv_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svdiv_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdiv_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svdiv_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdiv_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svdiv_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdiv_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svdiv_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdiv_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svdiv_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdiv_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdiv_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdiv_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svdiv_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdiv_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svdiv_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdiv_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svdiv_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdiv_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svdiv_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdiv_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svdiv_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdiv_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdiv_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdiv_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svdiv_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdiv_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svdiv_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdiv_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svdiv_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdiv_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svdiv_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdiv_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdiv_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdiv_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdiv_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdiv_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdiv_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdiv_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svdiv_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdiv_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdiv_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdiv_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdiv_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdiv_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svdiv_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdiv_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdiv_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdiv_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdiv_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdiv_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdiv_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdiv_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdiv_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdiv_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdiv_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdiv_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdiv_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdiv_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdiv_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdiv_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdiv_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdiv_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdiv_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdiv_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdiv_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdiv_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdiv_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdiv_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdiv_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdivr_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svdivr_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdivr_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svdivr_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdivr_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svdivr_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdivr_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svdivr_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdivr_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svdivr_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdivr_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svdivr_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdivr_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdivr_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdivr_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svdivr_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdivr_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svdivr_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdivr_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svdivr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdivr_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svdivr_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdivr_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svdivr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdivr_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdivr_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdivr_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svdivr_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdivr_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svdivr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdivr_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svdivr_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdivr_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svdivr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdivr_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdivr_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdivr_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdivr_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdivr_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdivr_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdivr_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svdivr_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdivr_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdivr_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdivr_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdivr_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdivr_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svdivr_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdivr_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdivr_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdivr_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdivr_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdivr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdivr_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdivr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdivr_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdivr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdivr_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdivr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdivr_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdivr_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdivr_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdivr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdivr_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdivr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdivr_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdivr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdivr_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdivr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdivr_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdivr_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svdivr_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdot_n_s32(svint32_t __p0, svint8_t __p1, int8_t __p2) {
  svint32_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svdot_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdot_n_s64(svint64_t __p0, svint16_t __p1, int16_t __p2) {
  svint64_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svdot_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdot_n_u32(svuint32_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint32_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svdot_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdot_n_u64(svuint64_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint64_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svdot_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdot_s32(svint32_t __p0, svint8_t __p1, svint8_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdot_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdot_s64(svint64_t __p0, svint16_t __p1, svint16_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdot_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdot_u32(svuint32_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdot_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdot_u64(svuint64_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdot_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdot_lane_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svint32_t __s0 = __p0; \
  svint8_t __s1 = __p1; \
  svint8_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svint32_t __ret; \
  __ret = __builtin_sve_svdot_lane_s32(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdot_lane_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svint64_t __s0 = __p0; \
  svint16_t __s1 = __p1; \
  svint16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svint64_t __ret; \
  __ret = __builtin_sve_svdot_lane_s64(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdot_lane_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svuint32_t __s0 = __p0; \
  svuint8_t __s1 = __p1; \
  svuint8_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svdot_lane_u32(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdot_lane_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svuint64_t __s0 = __p0; \
  svuint16_t __s1 = __p1; \
  svuint16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svdot_lane_u64(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_lane_u8(svuint8_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  svuint8_t __p1_dup = __builtin_sve_svdup_n_u8(__p1);
  __ret = __builtin_sve_svtbl_u8(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_lane_u32(svuint32_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  svuint32_t __p1_dup = __builtin_sve_svdup_n_u32(__p1);
  __ret = __builtin_sve_svtbl_u32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_lane_u64(svuint64_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  svuint64_t __p1_dup = __builtin_sve_svdup_n_u64(__p1);
  __ret = __builtin_sve_svtbl_u64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_lane_u16(svuint16_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  svuint16_t __p1_dup = __builtin_sve_svdup_n_u16(__p1);
  __ret = __builtin_sve_svtbl_u16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_lane_s8(svint8_t __p0, uint8_t __p1) {
  svint8_t __ret;
  svuint8_t __p1_dup = __builtin_sve_svdup_n_u8(__p1);
  __ret = __builtin_sve_svtbl_s8(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_lane_f64(svfloat64_t __p0, uint64_t __p1) {
  svfloat64_t __ret;
  svuint64_t __p1_dup = __builtin_sve_svdup_n_u64(__p1);
  __ret = __builtin_sve_svtbl_f64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_lane_f32(svfloat32_t __p0, uint32_t __p1) {
  svfloat32_t __ret;
  svuint32_t __p1_dup = __builtin_sve_svdup_n_u32(__p1);
  __ret = __builtin_sve_svtbl_f32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdup_lane_f16(svfloat16_t __p0, uint16_t __p1) {
  svfloat16_t __ret;
  svuint16_t __p1_dup = __builtin_sve_svdup_n_u16(__p1);
  __ret = __builtin_sve_svtbl_f16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_lane_s32(svint32_t __p0, uint32_t __p1) {
  svint32_t __ret;
  svuint32_t __p1_dup = __builtin_sve_svdup_n_u32(__p1);
  __ret = __builtin_sve_svtbl_s32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_lane_s64(svint64_t __p0, uint64_t __p1) {
  svint64_t __ret;
  svuint64_t __p1_dup = __builtin_sve_svdup_n_u64(__p1);
  __ret = __builtin_sve_svtbl_s64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_lane_s16(svint16_t __p0, uint16_t __p1) {
  svint16_t __ret;
  svuint16_t __p1_dup = __builtin_sve_svdup_n_u16(__p1);
  __ret = __builtin_sve_svtbl_s16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_n_u8(uint8_t __p0) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_n_u32(uint32_t __p0) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_n_u64(uint64_t __p0) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_n_u16(uint16_t __p0) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_n_s8(int8_t __p0) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_n_f64(float64_t __p0) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_n_f32(float32_t __p0) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_n_f16(__p0) __extension__ ({ \
  float16_t __s0 = __p0; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16(__s0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_n_s32(int32_t __p0) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_n_s64(int64_t __p0) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_n_s16(int16_t __p0) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_n_u8_m(svuint8_t __p0, svbool_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_n_u32_m(svuint32_t __p0, svbool_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_n_u64_m(svuint64_t __p0, svbool_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_n_u16_m(svuint16_t __p0, svbool_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_n_s8_m(svint8_t __p0, svbool_t __p1, int8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_n_f64_m(svfloat64_t __p0, svbool_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_n_f32_m(svfloat32_t __p0, svbool_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svbool_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16_m(__s0, __s1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_n_s32_m(svint32_t __p0, svbool_t __p1, int32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_n_s64_m(svint64_t __p0, svbool_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_n_s16_m(svint16_t __p0, svbool_t __p1, int16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_n_u8_x(svbool_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_n_u32_x(svbool_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_n_u64_x(svbool_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_n_u16_x(svbool_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_n_s8_x(svbool_t __p0, int8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_n_f64_x(svbool_t __p0, float64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_n_f32_x(svbool_t __p0, float32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_n_f16_x(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16_x(__svundef(__ret), __s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_n_s32_x(svbool_t __p0, int32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_n_s64_x(svbool_t __p0, int64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_n_s16_x(svbool_t __p0, int16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_n_u8_z(svbool_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_n_u32_z(svbool_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_n_u64_z(svbool_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_n_u16_z(svbool_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_n_s8_z(svbool_t __p0, int8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_n_f64_z(svbool_t __p0, float64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_n_f32_z(svbool_t __p0, float32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_n_f16_z(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16_z(__svzero(__ret), __s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_n_s32_z(svbool_t __p0, int32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_n_s64_z(svbool_t __p0, int64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_n_s16_z(svbool_t __p0, int16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_u8(uint8_t __p0) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_u32(uint32_t __p0) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_u64(uint64_t __p0) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_u16(uint16_t __p0) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_s8(int8_t __p0) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_f64(float64_t __p0) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_f32(float32_t __p0) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_f16(__p0) __extension__ ({ \
  float16_t __s0 = __p0; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16(__s0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_s32(int32_t __p0) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_s64(int64_t __p0) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_s16(int16_t __p0) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_u8_m(svuint8_t __p0, svbool_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_u32_m(svuint32_t __p0, svbool_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_u64_m(svuint64_t __p0, svbool_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_u16_m(svuint16_t __p0, svbool_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_s8_m(svint8_t __p0, svbool_t __p1, int8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_f64_m(svfloat64_t __p0, svbool_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_f32_m(svfloat32_t __p0, svbool_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svbool_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16_m(__s0, __s1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_s32_m(svint32_t __p0, svbool_t __p1, int32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_s64_m(svint64_t __p0, svbool_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_s16_m(svint16_t __p0, svbool_t __p1, int16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16_m(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_u8_x(svbool_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_u32_x(svbool_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_u64_x(svbool_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_u16_x(svbool_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_s8_x(svbool_t __p0, int8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_f64_x(svbool_t __p0, float64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_f32_x(svbool_t __p0, float32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_f16_x(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16_x(__svundef(__ret), __s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_s32_x(svbool_t __p0, int32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_s64_x(svbool_t __p0, int64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_s16_x(svbool_t __p0, int16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16_x(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdup_u8_z(svbool_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdup_n_u8_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdup_u32_z(svbool_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdup_n_u32_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdup_u64_z(svbool_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdup_n_u64_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdup_u16_z(svbool_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdup_n_u16_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdup_s8_z(svbool_t __p0, int8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svdup_n_s8_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdup_f64_z(svbool_t __p0, float64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdup_n_f64_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdup_f32_z(svbool_t __p0, float32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdup_n_f32_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdup_f16_z(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svdup_n_f16_z(__svzero(__ret), __s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdup_s32_z(svbool_t __p0, int32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svdup_n_s32_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdup_s64_z(svbool_t __p0, int64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svdup_n_s64_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdup_s16_z(svbool_t __p0, int16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svdup_n_s16_z(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svdupq_lane_u8(svuint8_t __p0, uint64_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svdupq_lane_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svdupq_lane_u32(svuint32_t __p0, uint64_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svdupq_lane_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svdupq_lane_u64(svuint64_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svdupq_lane_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svdupq_lane_u16(svuint16_t __p0, uint64_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svdupq_lane_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svdupq_lane_s8(svint8_t __p0, uint64_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svdupq_lane_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svdupq_lane_f64(svfloat64_t __p0, uint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svdupq_lane_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svdupq_lane_f32(svfloat32_t __p0, uint64_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svdupq_lane_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svdupq_lane_f16(svfloat16_t __p0, uint64_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svdupq_lane_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svdupq_lane_s32(svint32_t __p0, uint64_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svdupq_lane_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svdupq_lane_s64(svint64_t __p0, uint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svdupq_lane_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svdupq_lane_s16(svint16_t __p0, uint64_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svdupq_lane_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t sveor_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_sveor_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t sveor_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_sveor_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t sveor_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_sveor_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t sveor_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_sveor_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t sveor_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_sveor_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t sveor_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_sveor_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t sveor_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_sveor_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t sveor_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_sveor_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t sveor_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_sveor_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t sveor_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_sveor_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t sveor_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_sveor_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t sveor_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_sveor_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t sveor_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_sveor_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t sveor_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_sveor_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t sveor_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_sveor_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t sveor_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_sveor_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t sveor_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_sveor_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t sveor_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t sveor_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t sveor_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t sveor_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t sveor_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t sveor_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t sveor_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t sveor_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t sveor_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_sveor_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t sveor_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_sveor_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t sveor_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_sveor_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t sveor_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_sveor_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t sveor_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_sveor_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t sveor_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_sveor_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t sveor_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_sveor_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t sveor_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_sveor_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t sveor_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_sveor_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t sveor_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_sveor_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t sveor_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_sveor_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t sveor_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_sveor_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t sveor_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_sveor_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t sveor_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_sveor_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t sveor_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_sveor_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t sveor_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_sveor_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t sveor_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t sveor_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t sveor_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t sveor_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t sveor_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t sveor_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t sveor_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t sveor_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_sveor_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t sveorv_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_sveorv_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t sveorv_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_sveorv_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t sveorv_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_sveorv_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t sveorv_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_sveorv_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t sveorv_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_sveorv_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t sveorv_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_sveorv_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t sveorv_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_sveorv_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t sveorv_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_sveorv_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svexpa_f64(svuint64_t __p0) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svexpa_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svexpa_f32(svuint32_t __p0) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svexpa_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svexpa_f16(svuint16_t __p0) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svexpa_f16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_u8(__p0, __p1, __p2) __extension__ ({ \
  svuint8_t __s0 = __p0; \
  svuint8_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svext_u8(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_u32(__p0, __p1, __p2) __extension__ ({ \
  svuint32_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svext_u32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_u64(__p0, __p1, __p2) __extension__ ({ \
  svuint64_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svext_u64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_u16(__p0, __p1, __p2) __extension__ ({ \
  svuint16_t __s0 = __p0; \
  svuint16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svext_u16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_s8(__p0, __p1, __p2) __extension__ ({ \
  svint8_t __s0 = __p0; \
  svint8_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svext_s8(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_f64(__p0, __p1, __p2) __extension__ ({ \
  svfloat64_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svext_f64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_f32(__p0, __p1, __p2) __extension__ ({ \
  svfloat32_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svext_f32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_f16(__p0, __p1, __p2) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svext_f16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_s32(__p0, __p1, __p2) __extension__ ({ \
  svint32_t __s0 = __p0; \
  svint32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svext_s32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_s64(__p0, __p1, __p2) __extension__ ({ \
  svint64_t __s0 = __p0; \
  svint64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svext_s64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext_s16(__p0, __p1, __p2) __extension__ ({ \
  svint16_t __s0 = __p0; \
  svint16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svext_s16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svextb_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svextb_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svextb_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svextb_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svextb_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svextb_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svextb_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svextb_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svextb_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svextb_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svextb_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svextb_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svextb_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svextb_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svextb_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svextb_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svextb_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svextb_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svextb_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svextb_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svextb_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svextb_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svextb_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svextb_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svextb_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svextb_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svextb_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svextb_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svextb_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svextb_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svextb_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svextb_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svextb_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svextb_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svextb_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svextb_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svexth_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svexth_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svexth_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svexth_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svexth_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svexth_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svexth_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svexth_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svexth_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svexth_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svexth_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svexth_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svexth_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svexth_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svexth_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svexth_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svexth_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svexth_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svexth_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svexth_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svexth_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svexth_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svexth_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svexth_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svextw_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svextw_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svextw_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svextw_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svextw_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svextw_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svextw_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svextw_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svextw_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svextw_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svextw_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svextw_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svindex_u8(uint8_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svindex_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svindex_u32(uint32_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svindex_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svindex_u64(uint64_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svindex_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svindex_u16(uint16_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svindex_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svindex_s8(int8_t __p0, int8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svindex_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svindex_s32(int32_t __p0, int32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svindex_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svindex_s64(int64_t __p0, int64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svindex_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svindex_s16(int16_t __p0, int16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svindex_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svinsr_n_u8(svuint8_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svinsr_n_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svinsr_n_u32(svuint32_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svinsr_n_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svinsr_n_u64(svuint64_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svinsr_n_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svinsr_n_u16(svuint16_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svinsr_n_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svinsr_n_s8(svint8_t __p0, int8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svinsr_n_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svinsr_n_f64(svfloat64_t __p0, float64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svinsr_n_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svinsr_n_f32(svfloat32_t __p0, float32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svinsr_n_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svinsr_n_f16(__p0, __p1) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  float16_t __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svinsr_n_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svinsr_n_s32(svint32_t __p0, int32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svinsr_n_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svinsr_n_s64(svint64_t __p0, int64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svinsr_n_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svinsr_n_s16(svint16_t __p0, int16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svinsr_n_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svlasta_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_svlasta_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svlasta_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svlasta_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlasta_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svlasta_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svlasta_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_svlasta_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svlasta_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_svlasta_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svlasta_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svlasta_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svlasta_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svlasta_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svlasta_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svlasta_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svlasta_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svlasta_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svlasta_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svlasta_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svlasta_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_svlasta_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svlastb_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_svlastb_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svlastb_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svlastb_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlastb_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svlastb_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svlastb_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_svlastb_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svlastb_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_svlastb_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svlastb_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svlastb_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svlastb_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svlastb_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svlastb_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svlastb_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svlastb_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svlastb_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svlastb_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svlastb_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svlastb_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_svlastb_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svld1_u8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8_t __ret; \
  __ret = __builtin_sve_svld1_s8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1_f64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1_f32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svld1_f16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1_gather_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_index_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svld1_gather_u64base_index_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_index_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svld1_gather_u32base_index_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_index_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1_gather_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_index_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svld1_gather_u64base_offset_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_offset_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svld1_gather_u32base_offset_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_offset_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svld1_gather_u64base_f64(svbool_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svld1_gather_u32base_f32(svbool_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_s32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s64index_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1_gather_s64index_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s32index_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1_gather_s32index_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_s32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_u32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u64index_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1_gather_u64index_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u32index_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1_gather_u32index_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_u32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s64offset_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1_gather_s64offset_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s32offset_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1_gather_s32offset_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u64offset_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1_gather_u64offset_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u32offset_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1_gather_u32offset_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svld1_vnum_u8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svld1_vnum_s8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1_vnum_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1_vnum_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svld1_vnum_f16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svld1rq_u8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1rq_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1rq_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1rq_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8_t __ret; \
  __ret = __builtin_sve_svld1rq_s8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svld1rq_f64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svld1rq_f32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svld1rq_f16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1rq_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1rq_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1rq_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1sb_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sb_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1sb_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sb_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1sb_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sb_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1sb_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sb_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sb_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sb_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sb_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sb_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1sb_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sb_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sb_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1sb_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sb_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sb_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1sb_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sb_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sb_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1sb_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1sh_gather_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u32base_index_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sh_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1sh_gather_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u32base_index_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sh_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1sh_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sh_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1sh_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sh_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1sh_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sh_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1sh_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sh_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sh_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sh_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sh_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sh_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sh_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sh_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1sh_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sh_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1sh_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sh_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sw_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sw_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sw_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sw_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sw_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sw_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sw_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sw_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1sw_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1sw_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1sw_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1sw_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sw_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sw_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sw_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1sw_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1sw_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1ub_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1ub_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1ub_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1ub_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1ub_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1ub_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1ub_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1ub_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1ub_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1ub_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1ub_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1ub_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1ub_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1ub_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1ub_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1ub_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1ub_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1ub_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svld1ub_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1ub_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1ub_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svld1ub_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1uh_gather_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u32base_index_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1uh_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1uh_gather_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u32base_index_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1uh_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1uh_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1uh_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1uh_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1uh_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svld1uh_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1uh_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svld1uh_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1uh_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1uh_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uh_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1uh_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uh_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1uh_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uh_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svld1uh_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uh_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svld1uh_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uh_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1uw_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1uw_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1uw_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1uw_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1uw_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1uw_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1uw_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1uw_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svld1uw_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svld1uw_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svld1uw_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svld1uw_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uw_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uw_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uw_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svld1uw_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svld1uw_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8x2_t __ret; \
  __builtin_sve_svld2_u8(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32x2_t __ret; \
  __builtin_sve_svld2_u32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64x2_t __ret; \
  __builtin_sve_svld2_u64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16x2_t __ret; \
  __builtin_sve_svld2_u16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8x2_t __ret; \
  __builtin_sve_svld2_s8(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64x2_t __ret; \
  __builtin_sve_svld2_f64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32x2_t __ret; \
  __builtin_sve_svld2_f32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16x2_t __ret; \
  __builtin_sve_svld2_f16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32x2_t __ret; \
  __builtin_sve_svld2_s32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64x2_t __ret; \
  __builtin_sve_svld2_s64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16x2_t __ret; \
  __builtin_sve_svld2_s16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8x2_t __ret; \
  __builtin_sve_svld2_vnum_u8(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32x2_t __ret; \
  __builtin_sve_svld2_vnum_u32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64x2_t __ret; \
  __builtin_sve_svld2_vnum_u64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16x2_t __ret; \
  __builtin_sve_svld2_vnum_u16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8x2_t __ret; \
  __builtin_sve_svld2_vnum_s8(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64x2_t __ret; \
  __builtin_sve_svld2_vnum_f64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32x2_t __ret; \
  __builtin_sve_svld2_vnum_f32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16x2_t __ret; \
  __builtin_sve_svld2_vnum_f16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32x2_t __ret; \
  __builtin_sve_svld2_vnum_s32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64x2_t __ret; \
  __builtin_sve_svld2_vnum_s64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16x2_t __ret; \
  __builtin_sve_svld2_vnum_s16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8x3_t __ret; \
  __builtin_sve_svld3_u8(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32x3_t __ret; \
  __builtin_sve_svld3_u32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64x3_t __ret; \
  __builtin_sve_svld3_u64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16x3_t __ret; \
  __builtin_sve_svld3_u16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8x3_t __ret; \
  __builtin_sve_svld3_s8(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64x3_t __ret; \
  __builtin_sve_svld3_f64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32x3_t __ret; \
  __builtin_sve_svld3_f32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16x3_t __ret; \
  __builtin_sve_svld3_f16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32x3_t __ret; \
  __builtin_sve_svld3_s32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64x3_t __ret; \
  __builtin_sve_svld3_s64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16x3_t __ret; \
  __builtin_sve_svld3_s16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8x3_t __ret; \
  __builtin_sve_svld3_vnum_u8(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32x3_t __ret; \
  __builtin_sve_svld3_vnum_u32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64x3_t __ret; \
  __builtin_sve_svld3_vnum_u64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16x3_t __ret; \
  __builtin_sve_svld3_vnum_u16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8x3_t __ret; \
  __builtin_sve_svld3_vnum_s8(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64x3_t __ret; \
  __builtin_sve_svld3_vnum_f64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32x3_t __ret; \
  __builtin_sve_svld3_vnum_f32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16x3_t __ret; \
  __builtin_sve_svld3_vnum_f16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32x3_t __ret; \
  __builtin_sve_svld3_vnum_s32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64x3_t __ret; \
  __builtin_sve_svld3_vnum_s64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16x3_t __ret; \
  __builtin_sve_svld3_vnum_s16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8x4_t __ret; \
  __builtin_sve_svld4_u8(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32x4_t __ret; \
  __builtin_sve_svld4_u32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64x4_t __ret; \
  __builtin_sve_svld4_u64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16x4_t __ret; \
  __builtin_sve_svld4_u16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8x4_t __ret; \
  __builtin_sve_svld4_s8(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64x4_t __ret; \
  __builtin_sve_svld4_f64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32x4_t __ret; \
  __builtin_sve_svld4_f32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16x4_t __ret; \
  __builtin_sve_svld4_f16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32x4_t __ret; \
  __builtin_sve_svld4_s32(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64x4_t __ret; \
  __builtin_sve_svld4_s64(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16x4_t __ret; \
  __builtin_sve_svld4_s16(&__ret, __s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8x4_t __ret; \
  __builtin_sve_svld4_vnum_u8(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32x4_t __ret; \
  __builtin_sve_svld4_vnum_u32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64x4_t __ret; \
  __builtin_sve_svld4_vnum_u64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16x4_t __ret; \
  __builtin_sve_svld4_vnum_u16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8x4_t __ret; \
  __builtin_sve_svld4_vnum_s8(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64x4_t __ret; \
  __builtin_sve_svld4_vnum_f64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32x4_t __ret; \
  __builtin_sve_svld4_vnum_f32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16x4_t __ret; \
  __builtin_sve_svld4_vnum_f16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32x4_t __ret; \
  __builtin_sve_svld4_vnum_s32(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64x4_t __ret; \
  __builtin_sve_svld4_vnum_s64(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16x4_t __ret; \
  __builtin_sve_svld4_vnum_s16(&__ret, __s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svldff1_u8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldff1_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8_t __ret; \
  __ret = __builtin_sve_svldff1_s8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldff1_f64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldff1_f32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svldff1_f16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldff1_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1_gather_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_index_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svldff1_gather_u64base_index_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_index_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svldff1_gather_u32base_index_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_index_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1_gather_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_index_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svldff1_gather_u64base_offset_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_offset_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svldff1_gather_u32base_offset_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_offset_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svldff1_gather_u64base_f64(svbool_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svldff1_gather_u32base_f32(svbool_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s64index_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s64index_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s32index_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s32index_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u64index_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u64index_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u32index_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u32index_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s64offset_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s64offset_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s32offset_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s32offset_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u64offset_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u64offset_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u32offset_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u32offset_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_u8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_s8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_f16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldff1_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1sb_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sb_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1sb_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sb_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1sb_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sb_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1sb_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sb_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sb_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldff1sb_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldff1sb_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldff1sb_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sb_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sb_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldff1sb_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1sh_gather_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u32base_index_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sh_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1sh_gather_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u32base_index_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sh_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1sh_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sh_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1sh_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sh_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1sh_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sh_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1sh_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sh_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sh_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1sh_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sh_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sw_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sw_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sw_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sw_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sw_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sw_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sw_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sw_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1sw_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1sw_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1sw_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1sw_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1sw_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1ub_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1ub_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1ub_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1ub_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1ub_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1ub_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1ub_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1ub_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1ub_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldff1ub_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldff1ub_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldff1ub_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1ub_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1ub_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldff1ub_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1uh_gather_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u32base_index_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1uh_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1uh_gather_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u32base_index_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1uh_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1uh_gather_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u32base_offset_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1uh_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1uh_gather_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u32base_offset_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1uh_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svldff1uh_gather_u32base_u32(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u32base_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1uh_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svldff1uh_gather_u32base_s32(svbool_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u32base_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1uh_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1uh_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u32index_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u32index_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u32index_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u32index_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u32offset_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u32offset_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u32offset_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u32offset_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldff1uh_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uh_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1uw_gather_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1uw_gather_u64base_index_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1uw_gather_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1uw_gather_u64base_index_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1uw_gather_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1uw_gather_u64base_offset_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1uw_gather_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1uw_gather_u64base_offset_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svldff1uw_gather_u64base_u64(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svldff1uw_gather_u64base_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svldff1uw_gather_u64base_s64(svbool_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svldff1uw_gather_u64base_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_s64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_s64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_s64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_s64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_u64index_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_u64index_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_u64index_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_u64index_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_s64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_s64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_s64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_s64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_u64offset_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_u64offset_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_u64offset_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_gather_u64offset_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldff1uw_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svldnf1_u8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnf1_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8_t __ret; \
  __ret = __builtin_sve_svldnf1_s8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldnf1_f64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldnf1_f32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svldnf1_f16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnf1_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_u8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_s8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_f16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnf1_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1sb_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1sb_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnf1sb_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1sb_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1sb_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnf1sb_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1sb_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1sb_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnf1sb_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1sb_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1sb_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sb_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnf1sb_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1sh_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1sh_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1sh_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1sh_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1sh_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1sh_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1sh_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sh_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1sh_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sw_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1sw_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sw_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1sw_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sw_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1sw_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1sw_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1sw_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1ub_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1ub_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnf1ub_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1ub_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1ub_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnf1ub_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1ub_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1ub_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnf1ub_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1ub_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1ub_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1ub_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnf1ub_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1uh_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1uh_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1uh_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1uh_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnf1uh_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1uh_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnf1uh_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uh_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1uh_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uw_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1uw_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uw_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1uw_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uw_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnf1uw_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1uw_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnf1uw_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_u8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svldnt1_u8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_u32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnt1_u32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_u64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnt1_u64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_u16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnt1_u16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_s8(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  svint8_t __ret; \
  __ret = __builtin_sve_svldnt1_s8(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_f64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldnt1_f64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_f32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldnt1_f32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svldnt1_f16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_s32(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnt1_s32(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_s64(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnt1_s64(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_s16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnt1_s16(__s0, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_u8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_u32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_u64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_u16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_s8(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_f64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_f32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_f16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_s32(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_s64(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svldnt1_vnum_s16(__s0, __p1, __s2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_u8(svuint8_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_u8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_u32(svuint32_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_u32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_u64(svuint64_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_u64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_u16(svuint16_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_u16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_s8(svint8_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_s8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_f64(svfloat64_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_f32(svfloat32_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_f16(svfloat16_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_f16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_s32(svint32_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_s32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_s64(svint64_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_s64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svlen_s16(svint16_t __p0) {
  uint64_t __ret;
  __ret = __builtin_sve_svlen_s16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsl_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsl_n_s64_m(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsl_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsl_n_s64_x(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsl_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsl_n_s64_z(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_n_u8_m(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_n_u32_m(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_n_u16_m(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_n_s8_m(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_n_s32_m(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_n_s16_m(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_n_u8_x(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_n_u32_x(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_n_u16_x(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_n_s8_x(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_n_s32_x(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_n_s16_x(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsl_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_n_u8_z(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_n_u32_z(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_n_u16_z(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_n_s8_z(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_n_s32_z(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_n_s16_z(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsl_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsl_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsl_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svlsl_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsl_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_s8_m(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsl_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_s32_m(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsl_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsl_s64_m(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svlsl_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_s16_m(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsl_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsl_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsl_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsl_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svlsl_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsl_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_s8_x(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsl_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_s32_x(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsl_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsl_s64_x(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svlsl_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_s16_x(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsl_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsl_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_s8_z(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_s32_z(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsl_s64_z(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_s16_z(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_wide_u8_m(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsl_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_wide_u32_m(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsl_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_wide_u16_m(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsl_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_wide_s8_m(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsl_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_wide_s32_m(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsl_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_wide_s16_m(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsl_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_wide_u8_x(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsl_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_wide_u32_x(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsl_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_wide_u16_x(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsl_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_wide_s8_x(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsl_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_wide_s32_x(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsl_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_wide_s16_x(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsl_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsl_wide_u8_z(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsl_wide_u32_z(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsl_wide_u16_z(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsl_wide_s8_z(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsl_wide_s32_z(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsl_wide_s16_z(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsl_wide_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsr_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsr_n_s64_m(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsr_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsr_n_s64_x(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsr_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsr_n_s64_z(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  svint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_n_u8_m(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_n_u32_m(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_n_u16_m(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_n_s8_m(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_n_s32_m(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_n_s16_m(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_n_u8_x(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_n_u32_x(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_n_u16_x(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_n_s8_x(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_n_s32_x(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_n_s16_x(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svlsr_wide_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_n_u8_z(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  svuint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_n_u32_z(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  svuint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_n_u16_z(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  svuint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_n_s8_z(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  svint8_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_n_s32_z(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  svint32_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_n_s16_z(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  svint16_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsr_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svlsr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_s8_m(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_s32_m(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsr_s64_m(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svlsr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_s16_m(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsr_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svlsr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_s8_x(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_s32_x(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsr_s64_x(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svlsr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_s16_x(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svlsr_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_s8_z(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_s32_z(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svlsr_s64_z(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_s16_z(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_wide_u8_m(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsr_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_wide_u32_m(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsr_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_wide_u16_m(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsr_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_wide_s8_m(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsr_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_wide_s32_m(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsr_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_wide_s16_m(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsr_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_wide_u8_x(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svlsr_wide_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_wide_u32_x(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svlsr_wide_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_wide_u16_x(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svlsr_wide_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_wide_s8_x(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svlsr_wide_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_wide_s32_x(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svlsr_wide_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_wide_s16_x(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svlsr_wide_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svlsr_wide_u8_z(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svlsr_wide_u32_z(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svlsr_wide_u16_z(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svlsr_wide_s8_z(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svlsr_wide_s32_z(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svlsr_wide_s16_z(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svlsr_wide_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmad_n_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmad_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmad_n_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmad_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmad_n_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmad_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmad_n_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmad_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmad_n_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmad_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmad_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmad_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmad_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmad_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmad_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmad_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmad_n_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmad_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmad_n_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmad_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmad_n_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmad_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmad_n_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmad_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmad_n_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmad_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmad_n_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmad_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmad_n_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmad_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmad_n_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmad_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmad_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmad_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmad_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmad_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmad_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmad_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmad_n_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmad_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmad_n_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmad_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmad_n_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmad_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmad_n_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmad_n_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmad_n_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmad_n_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmad_n_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmad_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmad_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmad_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmad_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmad_n_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmad_n_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmad_n_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmad_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmad_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmad_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmad_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmad_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmad_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmad_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmad_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmad_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmad_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmad_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmad_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmad_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmad_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmad_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmad_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmad_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmad_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmad_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmad_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmad_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmad_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmad_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmad_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmad_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmad_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmad_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmad_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmad_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmad_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmad_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmad_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmad_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmad_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmad_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmad_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmad_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmad_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmad_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmad_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmad_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmad_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmad_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmad_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmad_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmad_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmad_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmad_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_u16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmad_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmad_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmad_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmad_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmad_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmad_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmad_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmad_s16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmax_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmax_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmax_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmax_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmax_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmax_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmax_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmax_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmax_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmax_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmax_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmax_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmax_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmax_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmax_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmax_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmax_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmax_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmax_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmax_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmax_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmax_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmax_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmax_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmax_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmax_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmax_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmax_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmax_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmax_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmax_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmax_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmax_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmax_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmax_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmax_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmax_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmax_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmax_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmax_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmax_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmax_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmax_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmax_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmax_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmax_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmax_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmax_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmax_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmax_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmax_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmax_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmax_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmax_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmax_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmax_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmax_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmax_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmax_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmax_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmax_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmax_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmax_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmax_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmax_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmax_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmax_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmax_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmax_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmax_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmax_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmax_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmax_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmax_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmax_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmax_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmax_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmax_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmax_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmax_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmax_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmax_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmax_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmax_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmax_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmax_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmax_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmax_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmax_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmax_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmax_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmax_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmax_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmax_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmax_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmax_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmax_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmax_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmax_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmax_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmax_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmax_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmax_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmax_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmax_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmax_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmax_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmax_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmax_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmax_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmax_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmax_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmaxnm_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmaxnm_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmaxnm_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmaxnm_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnm_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmaxnm_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmaxnm_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmaxnm_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmaxnm_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmaxnm_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnm_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmaxnm_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmaxnm_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmaxnm_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmaxnm_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmaxnm_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnm_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmaxnm_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmaxnm_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmaxnm_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmaxnm_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmaxnm_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmaxnm_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmaxnm_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmaxnm_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmaxnm_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmaxnm_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmaxnm_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmaxnm_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmaxnm_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmaxnm_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmaxnm_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmaxnm_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmaxnm_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmaxnm_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmaxnm_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svmaxnmv_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svmaxnmv_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svmaxnmv_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svmaxnmv_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnmv_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svmaxnmv_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svmaxv_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svmaxv_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svmaxv_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svmaxv_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxv_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svmaxv_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svmaxv_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_svmaxv_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svmaxv_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svmaxv_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svmaxv_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svmaxv_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svmaxv_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_svmaxv_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svmaxv_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_svmaxv_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svmaxv_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svmaxv_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svmaxv_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svmaxv_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svmaxv_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_svmaxv_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmin_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmin_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmin_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmin_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmin_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmin_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmin_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmin_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmin_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmin_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmin_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmin_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmin_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmin_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmin_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmin_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmin_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmin_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmin_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmin_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmin_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmin_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmin_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmin_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmin_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmin_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmin_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmin_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmin_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmin_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmin_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmin_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmin_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmin_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmin_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmin_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmin_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmin_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmin_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmin_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmin_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmin_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmin_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmin_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmin_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmin_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmin_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmin_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmin_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmin_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmin_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmin_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmin_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmin_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmin_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmin_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmin_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmin_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmin_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmin_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmin_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmin_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmin_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmin_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmin_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmin_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmin_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmin_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmin_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmin_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmin_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmin_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmin_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmin_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmin_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmin_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmin_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmin_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmin_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmin_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmin_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmin_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmin_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmin_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmin_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmin_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmin_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmin_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmin_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmin_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmin_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmin_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmin_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmin_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmin_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmin_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmin_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmin_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmin_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmin_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmin_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmin_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmin_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmin_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmin_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmin_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmin_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmin_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmin_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmin_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmin_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmin_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svminnm_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svminnm_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svminnm_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svminnm_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnm_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svminnm_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svminnm_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svminnm_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svminnm_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svminnm_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnm_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svminnm_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svminnm_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svminnm_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svminnm_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svminnm_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnm_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svminnm_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svminnm_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svminnm_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svminnm_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svminnm_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svminnm_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svminnm_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svminnm_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svminnm_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svminnm_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svminnm_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svminnm_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svminnm_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svminnm_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svminnm_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svminnm_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svminnm_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svminnm_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svminnm_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svminnmv_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svminnmv_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svminnmv_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svminnmv_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnmv_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svminnmv_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float64_t svminv_f64(svbool_t __p0, svfloat64_t __p1) {
  float64_t __ret;
  __ret = __builtin_sve_svminv_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai float32_t svminv_f32(svbool_t __p0, svfloat32_t __p1) {
  float32_t __ret;
  __ret = __builtin_sve_svminv_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminv_f16(__p0, __p1) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __ret; \
  __ret = __builtin_sve_svminv_f16(__s0, __s1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svminv_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_svminv_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svminv_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svminv_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svminv_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svminv_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svminv_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_svminv_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svminv_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_svminv_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svminv_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svminv_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svminv_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svminv_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svminv_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_svminv_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmla_n_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmla_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmla_n_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmla_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmla_n_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmla_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmla_n_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmla_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmla_n_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmla_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmla_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmla_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmla_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmla_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmla_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmla_n_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmla_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmla_n_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmla_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmla_n_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmla_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmla_n_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmla_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmla_n_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmla_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmla_n_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmla_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmla_n_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmla_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmla_n_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmla_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmla_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmla_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmla_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmla_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmla_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmla_n_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmla_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmla_n_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmla_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmla_n_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmla_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmla_n_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmla_n_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmla_n_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmla_n_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmla_n_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmla_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmla_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmla_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmla_n_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmla_n_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmla_n_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmla_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmla_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmla_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmla_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmla_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmla_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmla_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmla_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmla_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmla_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmla_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmla_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmla_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmla_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmla_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmla_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmla_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmla_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmla_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmla_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmla_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmla_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmla_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmla_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmla_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmla_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmla_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmla_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmla_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmla_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmla_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmla_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmla_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmla_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmla_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmla_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmla_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmla_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmla_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmla_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmla_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmla_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmla_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmla_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmla_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmla_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmla_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmla_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_u16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmla_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmla_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmla_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmla_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmla_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmla_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmla_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmla_s16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_lane_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svfloat64_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svmla_lane_f64(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_lane_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svfloat32_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svmla_lane_f32(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_lane_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svmla_lane_f16(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmls_n_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmls_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmls_n_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmls_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmls_n_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmls_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmls_n_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmls_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmls_n_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmls_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmls_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmls_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmls_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmls_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmls_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmls_n_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmls_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmls_n_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmls_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmls_n_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmls_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmls_n_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmls_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmls_n_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmls_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmls_n_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmls_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmls_n_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmls_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmls_n_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmls_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmls_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmls_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmls_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmls_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmls_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmls_n_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmls_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmls_n_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmls_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmls_n_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmls_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmls_n_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmls_n_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmls_n_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmls_n_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmls_n_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmls_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmls_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmls_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmls_n_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmls_n_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmls_n_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmls_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmls_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmls_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmls_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmls_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmls_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmls_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmls_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmls_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmls_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmls_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmls_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmls_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmls_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmls_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmls_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmls_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmls_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmls_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmls_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmls_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmls_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmls_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmls_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmls_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmls_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmls_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmls_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmls_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmls_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmls_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmls_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmls_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmls_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmls_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmls_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmls_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmls_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmls_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmls_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmls_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmls_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmls_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmls_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmls_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmls_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmls_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmls_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_u16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmls_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmls_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmls_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmls_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmls_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmls_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmls_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmls_s16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_lane_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svfloat64_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svmls_lane_f64(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_lane_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svfloat32_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svmls_lane_f32(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_lane_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __attribute__((unused)) uint64_t __s3 = __p3; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svmls_lane_f16(__s0, __s1, __s2, __p3); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmsb_n_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmsb_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmsb_n_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmsb_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmsb_n_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmsb_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmsb_n_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmsb_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmsb_n_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmsb_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmsb_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmsb_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmsb_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmsb_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmsb_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmsb_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmsb_n_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmsb_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmsb_n_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmsb_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmsb_n_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmsb_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmsb_n_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  __ret = __builtin_sve_svmsb_u8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmsb_n_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  __ret = __builtin_sve_svmsb_u32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmsb_n_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  __ret = __builtin_sve_svmsb_u64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmsb_n_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  __ret = __builtin_sve_svmsb_u16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmsb_n_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  __ret = __builtin_sve_svmsb_s8(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmsb_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svmsb_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmsb_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svmsb_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmsb_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svmsb_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmsb_n_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  __ret = __builtin_sve_svmsb_s32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmsb_n_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  __ret = __builtin_sve_svmsb_s64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmsb_n_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  __ret = __builtin_sve_svmsb_s16(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmsb_n_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, uint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p3_dup = __builtin_sve_svdup_n_u8(__p3);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmsb_n_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, uint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p3_dup = __builtin_sve_svdup_n_u32(__p3);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmsb_n_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, uint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p3_dup = __builtin_sve_svdup_n_u64(__p3);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmsb_n_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, uint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p3_dup = __builtin_sve_svdup_n_u16(__p3);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmsb_n_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, int8_t __p3) {
  svint8_t __ret;
  svint8_t __p3_dup = __builtin_sve_svdup_n_s8(__p3);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s8(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmsb_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmsb_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmsb_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmsb_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmsb_n_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, int32_t __p3) {
  svint32_t __ret;
  svint32_t __p3_dup = __builtin_sve_svdup_n_s32(__p3);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmsb_n_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, int64_t __p3) {
  svint64_t __ret;
  svint64_t __p3_dup = __builtin_sve_svdup_n_s64(__p3);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmsb_n_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, int16_t __p3) {
  svint16_t __ret;
  svint16_t __p3_dup = __builtin_sve_svdup_n_s16(__p3);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s16(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmsb_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmsb_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmsb_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmsb_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmsb_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmsb_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmsb_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmsb_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmsb_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmsb_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmsb_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmsb_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmsb_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmsb_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmsb_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmsb_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmsb_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmsb_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmsb_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmsb_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmsb_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmsb_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmsb_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmsb_u8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmsb_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmsb_u32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmsb_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmsb_u64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmsb_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmsb_u16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmsb_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  __ret = __builtin_sve_svmsb_s8(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmsb_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmsb_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmsb_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmsb_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmsb_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmsb_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmsb_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  __ret = __builtin_sve_svmsb_s32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmsb_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  __ret = __builtin_sve_svmsb_s64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmsb_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  __ret = __builtin_sve_svmsb_s16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmsb_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2, svuint8_t __p3) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmsb_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2, svuint32_t __p3) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmsb_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2, svuint64_t __p3) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmsb_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2, svuint16_t __p3) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_u16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmsb_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2, svint8_t __p3) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s8(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmsb_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmsb_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmsb_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmsb_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2, svint32_t __p3) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmsb_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2, svint64_t __p3) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmsb_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2, svint16_t __p3) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmsb_s16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmul_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmul_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmul_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmul_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmul_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmul_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmul_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmul_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmul_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmul_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmul_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmul_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmul_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmul_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmul_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmul_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmul_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmul_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmul_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmul_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmul_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmul_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmul_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmul_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmul_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmul_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmul_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmul_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmul_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmul_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmul_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmul_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmul_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmul_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmul_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmul_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmul_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmul_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmul_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmul_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmul_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmul_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmul_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmul_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmul_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmul_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmul_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmul_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmul_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmul_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmul_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmul_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmul_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmul_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmul_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmul_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmul_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmul_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmul_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmul_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmul_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmul_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmul_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmul_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmul_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmul_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmul_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmul_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmul_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmul_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmul_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmul_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmul_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmul_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmul_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmul_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmul_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmul_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmul_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmul_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmul_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmul_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmul_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmul_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmul_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmul_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmul_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmul_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmul_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmul_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmul_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmul_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmul_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmul_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmul_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmul_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmul_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmul_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmul_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmul_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmul_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmul_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmul_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmul_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmul_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmul_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmul_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmul_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmul_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_lane_f64(__p0, __p1, __p2) __extension__ ({ \
  svfloat64_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svmul_lane_f64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_lane_f32(__p0, __p1, __p2) __extension__ ({ \
  svfloat32_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svmul_lane_f32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_lane_f16(__p0, __p1, __p2) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svmul_lane_f16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmulh_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmulh_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmulh_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmulh_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmulh_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmulh_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmulh_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmulh_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmulh_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svmulh_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmulh_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svmulh_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmulh_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svmulh_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmulh_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svmulh_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmulh_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmulh_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmulh_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmulh_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmulh_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmulh_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmulh_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmulh_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmulh_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmulh_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmulh_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmulh_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmulh_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svmulh_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmulh_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svmulh_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmulh_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svmulh_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmulh_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svmulh_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmulh_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmulh_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmulh_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmulh_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmulh_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmulh_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmulh_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmulh_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmulh_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmulh_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmulh_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmulh_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmulh_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svmulh_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmulh_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svmulh_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmulh_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svmulh_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmulh_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svmulh_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svmulh_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svmulh_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svmulh_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svmulh_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmulh_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmulh_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmulh_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmulh_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmulh_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmulh_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmulh_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmulh_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmulh_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svmulh_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmulh_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svmulh_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmulh_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svmulh_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmulh_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svmulh_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svmulh_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svmulh_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svmulh_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svmulh_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulh_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmulx_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmulx_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmulx_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmulx_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmulx_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmulx_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmulx_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svmulx_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmulx_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svmulx_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmulx_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svmulx_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmulx_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulx_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmulx_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulx_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmulx_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svmulx_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmulx_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmulx_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmulx_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmulx_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmulx_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmulx_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmulx_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svmulx_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmulx_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svmulx_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmulx_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svmulx_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svmulx_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulx_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svmulx_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulx_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svmulx_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svmulx_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svnand_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svnand_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svneg_s8_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svneg_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svneg_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svneg_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svneg_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svneg_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svneg_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svneg_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svneg_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svneg_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svneg_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svneg_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svneg_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svneg_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svneg_s8_x(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svneg_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svneg_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svneg_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svneg_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svneg_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svneg_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svneg_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svneg_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svneg_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svneg_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svneg_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svneg_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svneg_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svneg_s8_z(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svneg_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svneg_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svneg_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svneg_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svneg_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svneg_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svneg_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svneg_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svneg_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svneg_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svneg_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svneg_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svneg_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmad_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmad_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmad_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmad_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmad_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmad_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmad_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmad_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmad_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmad_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmad_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmad_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmad_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmad_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmad_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmad_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmad_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svnmad_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmad_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmad_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmad_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmad_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmad_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmad_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmad_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmad_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmad_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmad_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmad_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmad_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmad_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmad_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmad_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmad_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmad_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmad_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmla_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmla_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmla_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmla_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmla_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmla_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmla_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmla_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmla_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmla_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmla_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmla_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmla_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmla_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmla_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmla_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmla_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svnmla_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmla_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmla_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmla_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmla_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmla_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmla_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmla_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmla_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmla_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmla_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmla_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmla_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmla_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmla_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmla_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmla_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmla_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmla_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmls_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmls_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmls_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmls_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmls_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmls_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmls_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmls_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmls_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmls_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmls_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmls_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmls_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmls_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmls_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmls_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmls_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svnmls_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmls_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmls_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmls_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmls_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmls_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmls_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmls_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmls_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmls_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmls_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmls_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmls_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmls_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmls_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmls_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmls_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmls_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmls_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmsb_n_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmsb_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmsb_n_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmsb_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmsb_n_f16_m(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmsb_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmsb_n_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  __ret = __builtin_sve_svnmsb_f64(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmsb_n_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  __ret = __builtin_sve_svnmsb_f32(__p0, __p1, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmsb_n_f16_x(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  __ret = __builtin_sve_svnmsb_f16(__s0, __s1, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmsb_n_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, float64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p3_dup = __builtin_sve_svdup_n_f64(__p3);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmsb_f64(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmsb_n_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, float32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p3_dup = __builtin_sve_svdup_n_f32(__p3);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmsb_f32(__p0, __p1_z, __p2, __p3_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmsb_n_f16_z(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  float16_t __s3 = __p3; \
  svfloat16_t __ret; \
  svfloat16_t __s3_dup = __builtin_sve_svdup_n_f16(__s3); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svnmsb_f16(__s0, __s1_z, __s2, __s3_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmsb_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmsb_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmsb_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmsb_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmsb_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmsb_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmsb_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svnmsb_f64(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmsb_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svnmsb_f32(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmsb_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svnmsb_f16(__p0, __p1, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svnmsb_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2, svfloat64_t __p3) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmsb_f64(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svnmsb_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2, svfloat32_t __p3) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmsb_f32(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svnmsb_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2, svfloat16_t __p3) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svnmsb_f16(__p0, __p1_z, __p2, __p3);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svnor_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svnor_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svnot_u8_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svnot_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svnot_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svnot_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svnot_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svnot_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svnot_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svnot_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svnot_s8_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svnot_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svnot_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svnot_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svnot_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svnot_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svnot_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svnot_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svnot_u8_x(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svnot_u8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svnot_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svnot_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svnot_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svnot_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svnot_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svnot_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svnot_s8_x(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svnot_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svnot_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svnot_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svnot_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svnot_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svnot_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svnot_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svnot_u8_z(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svnot_u8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svnot_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svnot_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svnot_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svnot_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svnot_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svnot_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svnot_s8_z(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svnot_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svnot_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svnot_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svnot_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svnot_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svnot_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svnot_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svorn_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svorn_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svorr_b_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svorr_b_z(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svorr_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svorr_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svorr_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svorr_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svorr_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svorr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svorr_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svorr_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svorr_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svorr_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svorr_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svorr_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svorr_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svorr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svorr_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svorr_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svorr_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svorr_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svorr_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svorr_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svorr_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svorr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svorr_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svorr_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svorr_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svorr_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svorr_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svorr_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svorr_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svorr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svorr_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svorr_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svorr_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svorr_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svorr_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svorr_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svorr_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svorr_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svorr_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svorr_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svorr_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svorr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svorr_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svorr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svorr_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svorr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svorr_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svorr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svorr_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svorr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svorr_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svorr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svorr_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svorr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svorr_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svorr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svorr_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svorr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svorr_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svorr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svorr_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svorr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svorr_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svorr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svorr_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svorr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svorr_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svorr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svorr_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svorr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svorr_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svorr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svorr_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svorr_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svorr_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svorr_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svorr_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svorr_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svorr_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svorr_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svorr_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint8_t svorv_u8(svbool_t __p0, svuint8_t __p1) {
  uint8_t __ret;
  __ret = __builtin_sve_svorv_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svorv_u32(svbool_t __p0, svuint32_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svorv_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svorv_u64(svbool_t __p0, svuint64_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svorv_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint16_t svorv_u16(svbool_t __p0, svuint16_t __p1) {
  uint16_t __ret;
  __ret = __builtin_sve_svorv_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int8_t svorv_s8(svbool_t __p0, svint8_t __p1) {
  int8_t __ret;
  __ret = __builtin_sve_svorv_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svorv_s32(svbool_t __p0, svint32_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svorv_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svorv_s64(svbool_t __p0, svint64_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svorv_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int16_t svorv_s16(svbool_t __p0, svint16_t __p1) {
  int16_t __ret;
  __ret = __builtin_sve_svorv_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpfalse_b() {
  svbool_t __ret;
  __ret = __builtin_sve_svpfalse_b();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpfirst_b(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svpfirst_b(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpnext_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svpnext_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpnext_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svpnext_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpnext_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svpnext_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpnext_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svpnext_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_u32base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfb_gather_u32base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_u64base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfb_gather_u64base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_u32base_offset(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_gather_u32base_offset(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_u64base_offset(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_gather_u64base_offset(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_s32offset(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_gather_s32offset(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_s64offset(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_gather_s64offset(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_u32offset(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_gather_u32offset(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_u64offset(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_gather_u64offset(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_vnum(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfb_vnum(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t const * __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfb(__s0, __p1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_u32base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfd_gather_u32base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_u64base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfd_gather_u64base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_u32base_index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_gather_u32base_index(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_u64base_index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_gather_u64base_index(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_s32index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_gather_s32index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_s64index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_gather_s64index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_u32index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_gather_u32index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_u64index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_gather_u64index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_vnum(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfd_vnum(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t const * __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfd(__s0, __p1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_u32base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfh_gather_u32base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_u64base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfh_gather_u64base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_u32base_index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_gather_u32base_index(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_u64base_index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_gather_u64base_index(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_s32index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_gather_s32index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_s64index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_gather_s64index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_u32index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_gather_u32index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_u64index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_gather_u64index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_vnum(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfh_vnum(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t const * __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfh(__s0, __p1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_u32base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfw_gather_u32base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_u64base(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfw_gather_u64base(__s0, __s1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_u32base_index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_gather_u32base_index(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_u64base_index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_gather_u64base_index(__s0, __s1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_s32index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_gather_s32index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_s64index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_gather_s64index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_u32index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint32_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_gather_u32index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_u64index(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svuint64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_gather_u64index(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_vnum(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  int64_t __s2 = __p2; \
  __attribute__((unused)) sv_prfop __s3 = __p3; \
  __builtin_sve_svprfw_vnum(__s0, __p1, __s2, __p3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t const * __s1 = __p1; \
  __attribute__((unused)) sv_prfop __s2 = __p2; \
  __builtin_sve_svprfw(__s0, __p1, __p2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai bool_t svptest_any(svbool_t __p0, svbool_t __p1) {
  bool_t __ret;
  __ret = __builtin_sve_svptest_any(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai bool_t svptest_first(svbool_t __p0, svbool_t __p1) {
  bool_t __ret;
  __ret = __builtin_sve_svptest_first(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai bool_t svptest_last(svbool_t __p0, svbool_t __p1) {
  bool_t __ret;
  __ret = __builtin_sve_svptest_last(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svptrue_pat_b8(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  svbool_t __ret; \
  __ret = __builtin_sve_svptrue_pat_b8(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svptrue_pat_b32(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  svbool_t __ret; \
  __ret = __builtin_sve_svptrue_pat_b32(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svptrue_pat_b64(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  svbool_t __ret; \
  __ret = __builtin_sve_svptrue_pat_b64(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svptrue_pat_b16(__p0) __extension__ ({ \
  __attribute__((unused)) sv_pattern __s0 = __p0; \
  svbool_t __ret; \
  __ret = __builtin_sve_svptrue_pat_b16(__p0); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svptrue_b8() {
  svbool_t __ret;
  __ret = __builtin_sve_svptrue_pat_b8(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svptrue_b32() {
  svbool_t __ret;
  __ret = __builtin_sve_svptrue_pat_b32(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svptrue_b64() {
  svbool_t __ret;
  __ret = __builtin_sve_svptrue_pat_b64(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svptrue_b16() {
  svbool_t __ret;
  __ret = __builtin_sve_svptrue_pat_b16(SV_ALL);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svqadd_n_s8(svint8_t __p0, int8_t __p1) {
  svint8_t __ret;
  svint8_t __p1_dup = __builtin_sve_svdup_n_s8(__p1);
  __ret = __builtin_sve_svqadd_s8(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svqadd_n_s32(svint32_t __p0, int32_t __p1) {
  svint32_t __ret;
  svint32_t __p1_dup = __builtin_sve_svdup_n_s32(__p1);
  __ret = __builtin_sve_svqadd_s32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svqadd_n_s64(svint64_t __p0, int64_t __p1) {
  svint64_t __ret;
  svint64_t __p1_dup = __builtin_sve_svdup_n_s64(__p1);
  __ret = __builtin_sve_svqadd_s64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svqadd_n_s16(svint16_t __p0, int16_t __p1) {
  svint16_t __ret;
  svint16_t __p1_dup = __builtin_sve_svdup_n_s16(__p1);
  __ret = __builtin_sve_svqadd_s16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svqadd_n_u8(svuint8_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  svuint8_t __p1_dup = __builtin_sve_svdup_n_u8(__p1);
  __ret = __builtin_sve_svqadd_u8(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svqadd_n_u32(svuint32_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  svuint32_t __p1_dup = __builtin_sve_svdup_n_u32(__p1);
  __ret = __builtin_sve_svqadd_u32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svqadd_n_u64(svuint64_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  svuint64_t __p1_dup = __builtin_sve_svdup_n_u64(__p1);
  __ret = __builtin_sve_svqadd_u64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svqadd_n_u16(svuint16_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  svuint16_t __p1_dup = __builtin_sve_svdup_n_u16(__p1);
  __ret = __builtin_sve_svqadd_u16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svqadd_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svqadd_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svqadd_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svqadd_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svqadd_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svqadd_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svqadd_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svqadd_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svqadd_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svqadd_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svqadd_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svqadd_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svqadd_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svqadd_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svqadd_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svqadd_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdecb_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_s64(__p0, __p1) __extension__ ({ \
  svint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_u64(__p0, __p1) __extension__ ({ \
  svuint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat_s64(__p0, __p1, __p2) __extension__ ({ \
  svint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat_u64(__p0, __p1, __p2) __extension__ ({ \
  svuint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svqdecd_pat_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_s16(__p0, __p1) __extension__ ({ \
  svint16_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svqdech_pat_s16(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_u16(__p0, __p1) __extension__ ({ \
  svuint16_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svqdech_pat_u16(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdech_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat_s16(__p0, __p1, __p2) __extension__ ({ \
  svint16_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svqdech_pat_s16(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat_u16(__p0, __p1, __p2) __extension__ ({ \
  svuint16_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svqdech_pat_u16(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqdecp_n_s32_b8(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqdecp_n_s32_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqdecp_n_s32_b32(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqdecp_n_s32_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqdecp_n_s32_b64(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqdecp_n_s32_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqdecp_n_s32_b16(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqdecp_n_s32_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqdecp_n_s64_b8(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqdecp_n_s64_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqdecp_n_s64_b32(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqdecp_n_s64_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqdecp_n_s64_b64(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqdecp_n_s64_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqdecp_n_s64_b16(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqdecp_n_s64_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqdecp_n_u32_b8(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqdecp_n_u32_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqdecp_n_u32_b32(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqdecp_n_u32_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqdecp_n_u32_b64(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqdecp_n_u32_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqdecp_n_u32_b16(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqdecp_n_u32_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqdecp_n_u64_b8(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqdecp_n_u64_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqdecp_n_u64_b32(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqdecp_n_u64_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqdecp_n_u64_b64(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqdecp_n_u64_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqdecp_n_u64_b16(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqdecp_n_u64_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svqdecp_s32(svint32_t __p0, svbool_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svqdecp_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svqdecp_s64(svint64_t __p0, svbool_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svqdecp_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svqdecp_s16(svint16_t __p0, svbool_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svqdecp_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svqdecp_u32(svuint32_t __p0, svbool_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svqdecp_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svqdecp_u64(svuint64_t __p0, svbool_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svqdecp_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svqdecp_u16(svuint16_t __p0, svbool_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svqdecp_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_s32(__p0, __p1) __extension__ ({ \
  svint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_u32(__p0, __p1) __extension__ ({ \
  svuint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat_s32(__p0, __p1, __p2) __extension__ ({ \
  svint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat_u32(__p0, __p1, __p2) __extension__ ({ \
  svuint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svqdecw_pat_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqincb_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_s64(__p0, __p1) __extension__ ({ \
  svint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svint64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_u64(__p0, __p1) __extension__ ({ \
  svuint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat_s64(__p0, __p1, __p2) __extension__ ({ \
  svint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat_u64(__p0, __p1, __p2) __extension__ ({ \
  svuint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint64_t __ret; \
  __ret = __builtin_sve_svqincd_pat_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_s16(__p0, __p1) __extension__ ({ \
  svint16_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svint16_t __ret; \
  __ret = __builtin_sve_svqinch_pat_s16(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_u16(__p0, __p1) __extension__ ({ \
  svuint16_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svqinch_pat_u16(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqinch_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat_s16(__p0, __p1, __p2) __extension__ ({ \
  svint16_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint16_t __ret; \
  __ret = __builtin_sve_svqinch_pat_s16(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat_u16(__p0, __p1, __p2) __extension__ ({ \
  svuint16_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint16_t __ret; \
  __ret = __builtin_sve_svqinch_pat_u16(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqincp_n_s32_b8(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqincp_n_s32_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqincp_n_s32_b32(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqincp_n_s32_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqincp_n_s32_b64(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqincp_n_s32_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int32_t svqincp_n_s32_b16(int32_t __p0, svbool_t __p1) {
  int32_t __ret;
  __ret = __builtin_sve_svqincp_n_s32_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqincp_n_s64_b8(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqincp_n_s64_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqincp_n_s64_b32(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqincp_n_s64_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqincp_n_s64_b64(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqincp_n_s64_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai int64_t svqincp_n_s64_b16(int64_t __p0, svbool_t __p1) {
  int64_t __ret;
  __ret = __builtin_sve_svqincp_n_s64_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqincp_n_u32_b8(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqincp_n_u32_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqincp_n_u32_b32(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqincp_n_u32_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqincp_n_u32_b64(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqincp_n_u32_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint32_t svqincp_n_u32_b16(uint32_t __p0, svbool_t __p1) {
  uint32_t __ret;
  __ret = __builtin_sve_svqincp_n_u32_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqincp_n_u64_b8(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqincp_n_u64_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqincp_n_u64_b32(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqincp_n_u64_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqincp_n_u64_b64(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqincp_n_u64_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai uint64_t svqincp_n_u64_b16(uint64_t __p0, svbool_t __p1) {
  uint64_t __ret;
  __ret = __builtin_sve_svqincp_n_u64_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svqincp_s32(svint32_t __p0, svbool_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svqincp_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svqincp_s64(svint64_t __p0, svbool_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svqincp_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svqincp_s16(svint16_t __p0, svbool_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svqincp_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svqincp_u32(svuint32_t __p0, svbool_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svqincp_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svqincp_u64(svuint64_t __p0, svbool_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svqincp_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svqincp_u16(svuint16_t __p0, svbool_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svqincp_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_n_s32(__p0, __p1) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_n_s64(__p0, __p1) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  int64_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_s64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_n_u32(__p0, __p1) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_n_u64(__p0, __p1) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_u64(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_s32(__p0, __p1) __extension__ ({ \
  svint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svint32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_s32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_u32(__p0, __p1) __extension__ ({ \
  svuint32_t __s0 = __p0; \
  __attribute__((unused)) uint64_t __s1 = __p1; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_u32(__s0, SV_ALL, __p1); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat_n_s32(__p0, __p1, __p2) __extension__ ({ \
  int32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat_n_s64(__p0, __p1, __p2) __extension__ ({ \
  int64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  int64_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_s64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat_n_u32(__p0, __p1, __p2) __extension__ ({ \
  uint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat_n_u64(__p0, __p1, __p2) __extension__ ({ \
  uint64_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  uint64_t __ret; \
  __ret = __builtin_sve_svqincw_pat_n_u64(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat_s32(__p0, __p1, __p2) __extension__ ({ \
  svint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svint32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_s32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat_u32(__p0, __p1, __p2) __extension__ ({ \
  svuint32_t __s0 = __p0; \
  __attribute__((unused)) sv_pattern __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svuint32_t __ret; \
  __ret = __builtin_sve_svqincw_pat_u32(__s0, __p1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svqsub_n_s8(svint8_t __p0, int8_t __p1) {
  svint8_t __ret;
  svint8_t __p1_dup = __builtin_sve_svdup_n_s8(__p1);
  __ret = __builtin_sve_svqsub_s8(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svqsub_n_s32(svint32_t __p0, int32_t __p1) {
  svint32_t __ret;
  svint32_t __p1_dup = __builtin_sve_svdup_n_s32(__p1);
  __ret = __builtin_sve_svqsub_s32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svqsub_n_s64(svint64_t __p0, int64_t __p1) {
  svint64_t __ret;
  svint64_t __p1_dup = __builtin_sve_svdup_n_s64(__p1);
  __ret = __builtin_sve_svqsub_s64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svqsub_n_s16(svint16_t __p0, int16_t __p1) {
  svint16_t __ret;
  svint16_t __p1_dup = __builtin_sve_svdup_n_s16(__p1);
  __ret = __builtin_sve_svqsub_s16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svqsub_n_u8(svuint8_t __p0, uint8_t __p1) {
  svuint8_t __ret;
  svuint8_t __p1_dup = __builtin_sve_svdup_n_u8(__p1);
  __ret = __builtin_sve_svqsub_u8(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svqsub_n_u32(svuint32_t __p0, uint32_t __p1) {
  svuint32_t __ret;
  svuint32_t __p1_dup = __builtin_sve_svdup_n_u32(__p1);
  __ret = __builtin_sve_svqsub_u32(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svqsub_n_u64(svuint64_t __p0, uint64_t __p1) {
  svuint64_t __ret;
  svuint64_t __p1_dup = __builtin_sve_svdup_n_u64(__p1);
  __ret = __builtin_sve_svqsub_u64(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svqsub_n_u16(svuint16_t __p0, uint16_t __p1) {
  svuint16_t __ret;
  svuint16_t __p1_dup = __builtin_sve_svdup_n_u16(__p1);
  __ret = __builtin_sve_svqsub_u16(__p0, __p1_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svqsub_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svqsub_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svqsub_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svqsub_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svqsub_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svqsub_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svqsub_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svqsub_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svqsub_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svqsub_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svqsub_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svqsub_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svqsub_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svqsub_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svqsub_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svqsub_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svrbit_u8_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svrbit_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrbit_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrbit_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrbit_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrbit_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrbit_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrbit_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svrbit_s8_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svrbit_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrbit_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svrbit_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrbit_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svrbit_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrbit_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svrbit_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svrbit_u8_x(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svrbit_u8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrbit_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrbit_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrbit_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrbit_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrbit_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrbit_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svrbit_s8_x(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svrbit_s8(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrbit_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svrbit_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrbit_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrbit_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrbit_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svrbit_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svrbit_u8_z(svbool_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svrbit_u8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrbit_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrbit_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrbit_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrbit_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrbit_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrbit_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svrbit_s8_z(svbool_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svrbit_s8(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrbit_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svrbit_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrbit_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrbit_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrbit_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svrbit_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svrdffr() {
  svbool_t __ret;
  __ret = __builtin_sve_svrdffr();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrecpe_f64(svfloat64_t __p0) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrecpe_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrecpe_f32(svfloat32_t __p0) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrecpe_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrecpe_f16(svfloat16_t __p0) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrecpe_f16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrecps_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrecps_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrecps_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrecps_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrecps_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrecps_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrecpx_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrecpx_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrecpx_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrecpx_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrecpx_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrecpx_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrecpx_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrecpx_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrecpx_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrecpx_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrecpx_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrecpx_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrecpx_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrecpx_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrecpx_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrecpx_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrecpx_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrecpx_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svrev_u8(svuint8_t __p0) {
  svuint8_t __ret;
  __ret = __builtin_sve_svrev_u8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrev_u32(svuint32_t __p0) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrev_u32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrev_u64(svuint64_t __p0) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrev_u64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrev_u16(svuint16_t __p0) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrev_u16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svrev_s8(svint8_t __p0) {
  svint8_t __ret;
  __ret = __builtin_sve_svrev_s8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrev_f64(svfloat64_t __p0) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrev_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrev_f32(svfloat32_t __p0) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrev_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrev_f16(svfloat16_t __p0) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrev_f16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrev_s32(svint32_t __p0) {
  svint32_t __ret;
  __ret = __builtin_sve_svrev_s32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrev_s64(svint64_t __p0) {
  svint64_t __ret;
  __ret = __builtin_sve_svrev_s64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrev_s16(svint16_t __p0) {
  svint16_t __ret;
  __ret = __builtin_sve_svrev_s16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svrev_b8(svbool_t __p0) {
  svbool_t __ret;
  __ret = __builtin_sve_svrev_b8(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svrev_b32(svbool_t __p0) {
  svbool_t __ret;
  __ret = __builtin_sve_svrev_b32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svrev_b64(svbool_t __p0) {
  svbool_t __ret;
  __ret = __builtin_sve_svrev_b64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svrev_b16(svbool_t __p0) {
  svbool_t __ret;
  __ret = __builtin_sve_svrev_b16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrevb_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrevb_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevb_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevb_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrevb_u16_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrevb_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrevb_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svrevb_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevb_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevb_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrevb_s16_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svrevb_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrevb_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrevb_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevb_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevb_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrevb_u16_x(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrevb_u16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrevb_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svrevb_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevb_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevb_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrevb_s16_x(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svrevb_s16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrevb_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrevb_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevb_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevb_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svrevb_u16_z(svbool_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svrevb_u16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrevb_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svrevb_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevb_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevb_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svrevb_s16_z(svbool_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svrevb_s16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrevh_u32_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrevh_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevh_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevh_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrevh_s32_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svrevh_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevh_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevh_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrevh_u32_x(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrevh_u32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevh_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevh_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrevh_s32_x(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svrevh_s32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevh_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevh_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svrevh_u32_z(svbool_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svrevh_u32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevh_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevh_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svrevh_s32_z(svbool_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svrevh_s32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevh_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevh_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevw_u64_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevw_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevw_s64_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevw_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevw_u64_x(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevw_u64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevw_s64_x(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevw_s64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svrevw_u64_z(svbool_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svrevw_u64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svrevw_s64_z(svbool_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svrevw_s64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrinta_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrinta_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrinta_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrinta_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrinta_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrinta_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrinta_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrinta_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrinta_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrinta_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrinta_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrinta_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrinta_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrinta_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrinta_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrinta_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrinta_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrinta_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrinti_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrinti_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrinti_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrinti_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrinti_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrinti_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrinti_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrinti_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrinti_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrinti_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrinti_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrinti_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrinti_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrinti_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrinti_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrinti_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrinti_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrinti_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintm_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintm_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintm_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintm_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintm_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintm_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintm_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintm_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintm_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintm_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintm_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintm_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintm_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintm_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintm_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintm_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintm_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintm_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintn_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintn_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintn_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintn_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintn_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintn_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintn_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintn_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintn_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintn_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintn_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintn_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintn_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintn_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintn_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintn_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintn_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintn_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintp_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintp_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintp_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintp_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintp_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintp_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintp_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintp_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintp_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintp_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintp_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintp_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintp_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintp_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintp_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintp_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintp_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintp_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintx_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintx_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintx_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintx_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintx_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintx_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintx_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintx_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintx_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintx_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintx_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintx_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintx_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintx_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintx_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintx_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintx_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintx_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintz_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintz_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintz_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintz_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintz_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintz_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintz_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintz_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintz_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintz_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintz_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintz_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrintz_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrintz_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrintz_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrintz_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrintz_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrintz_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrsqrte_f64(svfloat64_t __p0) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrsqrte_f64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrsqrte_f32(svfloat32_t __p0) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrsqrte_f32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrsqrte_f16(svfloat16_t __p0) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrsqrte_f16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svrsqrts_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svrsqrts_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svrsqrts_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svrsqrts_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svrsqrts_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svrsqrts_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svscale_n_f64_m(svbool_t __p0, svfloat64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svscale_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svscale_n_f32_m(svbool_t __p0, svfloat32_t __p1, int32_t __p2) {
  svfloat32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svscale_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svscale_n_f16_m(svbool_t __p0, svfloat16_t __p1, int16_t __p2) {
  svfloat16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svscale_f16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svscale_n_f64_x(svbool_t __p0, svfloat64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svscale_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svscale_n_f32_x(svbool_t __p0, svfloat32_t __p1, int32_t __p2) {
  svfloat32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svscale_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svscale_n_f16_x(svbool_t __p0, svfloat16_t __p1, int16_t __p2) {
  svfloat16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svscale_f16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svscale_n_f64_z(svbool_t __p0, svfloat64_t __p1, int64_t __p2) {
  svfloat64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svscale_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svscale_n_f32_z(svbool_t __p0, svfloat32_t __p1, int32_t __p2) {
  svfloat32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svscale_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svscale_n_f16_z(svbool_t __p0, svfloat16_t __p1, int16_t __p2) {
  svfloat16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svscale_f16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svscale_f64_m(svbool_t __p0, svfloat64_t __p1, svint64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svscale_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svscale_f32_m(svbool_t __p0, svfloat32_t __p1, svint32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svscale_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svscale_f16_m(svbool_t __p0, svfloat16_t __p1, svint16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svscale_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svscale_f64_x(svbool_t __p0, svfloat64_t __p1, svint64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svscale_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svscale_f32_x(svbool_t __p0, svfloat32_t __p1, svint32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svscale_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svscale_f16_x(svbool_t __p0, svfloat16_t __p1, svint16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svscale_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svscale_f64_z(svbool_t __p0, svfloat64_t __p1, svint64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svscale_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svscale_f32_z(svbool_t __p0, svfloat32_t __p1, svint32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svscale_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svscale_f16_z(svbool_t __p0, svfloat16_t __p1, svint16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svscale_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svsel_b(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  svbool_t __ret;
  __ret = __builtin_sve_svsel_b(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsel_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svsel_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsel_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svsel_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsel_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svsel_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsel_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svsel_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsel_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svsel_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsel_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsel_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsel_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsel_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsel_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsel_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsel_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svsel_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsel_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svsel_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsel_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svsel_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svsetffr() {
  __builtin_sve_svsetffr();
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsplice_u8(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svsplice_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsplice_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svsplice_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsplice_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svsplice_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsplice_u16(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svsplice_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsplice_s8(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svsplice_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsplice_f64(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsplice_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsplice_f32(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsplice_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsplice_f16(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsplice_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsplice_s32(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svsplice_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsplice_s64(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svsplice_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsplice_s16(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svsplice_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsqrt_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsqrt_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsqrt_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsqrt_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsqrt_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsqrt_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsqrt_f64_x(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsqrt_f64(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsqrt_f32_x(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsqrt_f32(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsqrt_f16_x(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsqrt_f16(__svundef(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsqrt_f64_z(svbool_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsqrt_f64(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsqrt_f32_z(svbool_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsqrt_f32(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsqrt_f16_z(svbool_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsqrt_f16(__svzero(__ret), __p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint8_t __s2 = __p2; \
  __builtin_sve_svst1_u8(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  __builtin_sve_svst1_u32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  __builtin_sve_svst1_u64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint16_t __s2 = __p2; \
  __builtin_sve_svst1_u16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint8_t __s2 = __p2; \
  __builtin_sve_svst1_s8(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __builtin_sve_svst1_f64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __builtin_sve_svst1_f32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __builtin_sve_svst1_f16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  __builtin_sve_svst1_s32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  __builtin_sve_svst1_s64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint16_t __s2 = __p2; \
  __builtin_sve_svst1_s16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svuint32_t __p3) {
  __builtin_sve_svst1_scatter_u32base_index_u32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1_scatter_u64base_index_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_index_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svfloat64_t __p3) {
  __builtin_sve_svst1_scatter_u64base_index_f64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_index_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svfloat32_t __p3) {
  __builtin_sve_svst1_scatter_u32base_index_f32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svint32_t __p3) {
  __builtin_sve_svst1_scatter_u32base_index_s32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1_scatter_u64base_index_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svuint32_t __p3) {
  __builtin_sve_svst1_scatter_u32base_offset_u32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1_scatter_u64base_offset_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_offset_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svfloat64_t __p3) {
  __builtin_sve_svst1_scatter_u64base_offset_f64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_offset_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svfloat32_t __p3) {
  __builtin_sve_svst1_scatter_u32base_offset_f32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svint32_t __p3) {
  __builtin_sve_svst1_scatter_u32base_offset_s32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1_scatter_u64base_offset_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  __builtin_sve_svst1_scatter_u32base_u32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  __builtin_sve_svst1_scatter_u64base_u64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_f64(svbool_t __p0, svuint64_t __p1, svfloat64_t __p2) {
  __builtin_sve_svst1_scatter_u64base_f64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_f32(svbool_t __p0, svuint32_t __p1, svfloat32_t __p2) {
  __builtin_sve_svst1_scatter_u32base_f32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u32base_s32(svbool_t __p0, svuint32_t __p1, svint32_t __p2) {
  __builtin_sve_svst1_scatter_u32base_s32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1_scatter_u64base_s64(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  __builtin_sve_svst1_scatter_u64base_s64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s32index_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s32index_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s64index_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s64index_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s64index_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s64index_f64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s32index_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s32index_f32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s32index_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s32index_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s64index_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s64index_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u32index_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u32index_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u64index_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u64index_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u64index_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u64index_f64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u32index_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u32index_f32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u32index_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u32index_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u64index_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u64index_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s32offset_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s32offset_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s64offset_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s64offset_f64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s32offset_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s32offset_f32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s32offset_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s32offset_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_s64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_s64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u32offset_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u32offset_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u64offset_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u64offset_f64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u32offset_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u32offset_f32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u32offset_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u32offset_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_u64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1_scatter_u64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_u8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_u8(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_u16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_u16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_s8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_s8(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_f64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_f32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_f16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum_s16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __s3 = __p3; \
  __builtin_sve_svst1_vnum_s16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  __builtin_sve_svst1b_s32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  __builtin_sve_svst1b_s64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint16_t __s2 = __p2; \
  __builtin_sve_svst1b_s16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  __builtin_sve_svst1b_u32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  __builtin_sve_svst1b_u64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint16_t __s2 = __p2; \
  __builtin_sve_svst1b_u16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svuint32_t __p3) {
  __builtin_sve_svst1b_scatter_u32base_offset_u32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1b_scatter_u64base_offset_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svint32_t __p3) {
  __builtin_sve_svst1b_scatter_u32base_offset_s32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1b_scatter_u64base_offset_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u32base_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  __builtin_sve_svst1b_scatter_u32base_u32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u64base_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  __builtin_sve_svst1b_scatter_u64base_u64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u32base_s32(svbool_t __p0, svuint32_t __p1, svint32_t __p2) {
  __builtin_sve_svst1b_scatter_u32base_s32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1b_scatter_u64base_s64(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  __builtin_sve_svst1b_scatter_u64base_s64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_s32offset_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_s32offset_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_s64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_s64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_s32offset_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_s32offset_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_s64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_s64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_u32offset_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_u32offset_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_u64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_u64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_u32offset_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_u32offset_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_u64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1b_scatter_u64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1b_vnum_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1b_vnum_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum_s16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __s3 = __p3; \
  __builtin_sve_svst1b_vnum_s16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1b_vnum_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1b_vnum_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum_u16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __s3 = __p3; \
  __builtin_sve_svst1b_vnum_u16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  __builtin_sve_svst1h_s32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  __builtin_sve_svst1h_s64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  __builtin_sve_svst1h_u32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  __builtin_sve_svst1h_u64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u32base_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svuint32_t __p3) {
  __builtin_sve_svst1h_scatter_u32base_index_u32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1h_scatter_u64base_index_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u32base_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svint32_t __p3) {
  __builtin_sve_svst1h_scatter_u32base_index_s32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1h_scatter_u64base_index_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u32base_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svuint32_t __p3) {
  __builtin_sve_svst1h_scatter_u32base_offset_u32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1h_scatter_u64base_offset_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u32base_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2, svint32_t __p3) {
  __builtin_sve_svst1h_scatter_u32base_offset_s32(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1h_scatter_u64base_offset_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u32base_u32(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  __builtin_sve_svst1h_scatter_u32base_u32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u64base_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  __builtin_sve_svst1h_scatter_u64base_u64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u32base_s32(svbool_t __p0, svuint32_t __p1, svint32_t __p2) {
  __builtin_sve_svst1h_scatter_u32base_s32(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1h_scatter_u64base_s64(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  __builtin_sve_svst1h_scatter_u64base_s64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s32index_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s32index_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s64index_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s64index_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s32index_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s32index_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s64index_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s64index_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u32index_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u32index_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u64index_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u64index_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u32index_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u32index_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u64index_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u64index_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s32offset_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s32offset_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s32offset_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s32offset_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_s64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_s64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u32offset_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u32offset_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u32offset_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u32offset_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_u64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1h_scatter_u64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svst1h_vnum_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1h_vnum_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svst1h_vnum_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1h_vnum_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  __builtin_sve_svst1w_s64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  __builtin_sve_svst1w_u64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1w_scatter_u64base_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1w_scatter_u64base_index_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1w_scatter_u64base_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1w_scatter_u64base_index_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1w_scatter_u64base_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svuint64_t __p3) {
  __builtin_sve_svst1w_scatter_u64base_offset_u64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1w_scatter_u64base_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2, svint64_t __p3) {
  __builtin_sve_svst1w_scatter_u64base_offset_s64(__p0, __p1, __p2, __p3);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1w_scatter_u64base_u64(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  __builtin_sve_svst1w_scatter_u64base_u64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svst1w_scatter_u64base_s64(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  __builtin_sve_svst1w_scatter_u64base_s64(__p0, __p1, __p2);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_s64index_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_s64index_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_s64index_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_s64index_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_u64index_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_u64index_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_u64index_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_u64index_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_s64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_s64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_s64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_s64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_u64offset_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_u64offset_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_u64offset_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1w_scatter_u64offset_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svst1w_vnum_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svst1w_vnum_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint8x2_t __s2 = __p2; \
  __builtin_sve_svst2_u8(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32x2_t __s2 = __p2; \
  __builtin_sve_svst2_u32(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64x2_t __s2 = __p2; \
  __builtin_sve_svst2_u64(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint16x2_t __s2 = __p2; \
  __builtin_sve_svst2_u16(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint8x2_t __s2 = __p2; \
  __builtin_sve_svst2_s8(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svfloat64x2_t __s2 = __p2; \
  __builtin_sve_svst2_f64(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svfloat32x2_t __s2 = __p2; \
  __builtin_sve_svst2_f32(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  svfloat16x2_t __s2 = __p2; \
  __builtin_sve_svst2_f16(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32x2_t __s2 = __p2; \
  __builtin_sve_svst2_s32(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64x2_t __s2 = __p2; \
  __builtin_sve_svst2_s64(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint16x2_t __s2 = __p2; \
  __builtin_sve_svst2_s16(__s0, __p1, __s2.v0, __s2.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_u8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_u8(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_u32(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_u64(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_u16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_u16(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_s8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_s8(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_f64(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_f32(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_f16(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_s32(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_s64(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum_s16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16x2_t __s3 = __p3; \
  __builtin_sve_svst2_vnum_s16(__s0, __p1, __s2, __s3.v0, __s3.v1); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint8x3_t __s2 = __p2; \
  __builtin_sve_svst3_u8(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32x3_t __s2 = __p2; \
  __builtin_sve_svst3_u32(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64x3_t __s2 = __p2; \
  __builtin_sve_svst3_u64(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint16x3_t __s2 = __p2; \
  __builtin_sve_svst3_u16(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint8x3_t __s2 = __p2; \
  __builtin_sve_svst3_s8(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svfloat64x3_t __s2 = __p2; \
  __builtin_sve_svst3_f64(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svfloat32x3_t __s2 = __p2; \
  __builtin_sve_svst3_f32(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  svfloat16x3_t __s2 = __p2; \
  __builtin_sve_svst3_f16(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32x3_t __s2 = __p2; \
  __builtin_sve_svst3_s32(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64x3_t __s2 = __p2; \
  __builtin_sve_svst3_s64(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint16x3_t __s2 = __p2; \
  __builtin_sve_svst3_s16(__s0, __p1, __s2.v0, __s2.v1, __s2.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_u8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_u8(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_u32(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_u64(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_u16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_u16(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_s8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_s8(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_f64(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_f32(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_f16(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_s32(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_s64(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum_s16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16x3_t __s3 = __p3; \
  __builtin_sve_svst3_vnum_s16(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint8x4_t __s2 = __p2; \
  __builtin_sve_svst4_u8(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32x4_t __s2 = __p2; \
  __builtin_sve_svst4_u32(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64x4_t __s2 = __p2; \
  __builtin_sve_svst4_u64(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint16x4_t __s2 = __p2; \
  __builtin_sve_svst4_u16(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint8x4_t __s2 = __p2; \
  __builtin_sve_svst4_s8(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svfloat64x4_t __s2 = __p2; \
  __builtin_sve_svst4_f64(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svfloat32x4_t __s2 = __p2; \
  __builtin_sve_svst4_f32(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  svfloat16x4_t __s2 = __p2; \
  __builtin_sve_svst4_f16(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32x4_t __s2 = __p2; \
  __builtin_sve_svst4_s32(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64x4_t __s2 = __p2; \
  __builtin_sve_svst4_s64(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint16x4_t __s2 = __p2; \
  __builtin_sve_svst4_s16(__s0, __p1, __s2.v0, __s2.v1, __s2.v2, __s2.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_u8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_u8(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_u32(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_u64(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_u16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_u16(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_s8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_s8(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_f64(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_f32(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_f16(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_s32(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_s64(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum_s16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16x4_t __s3 = __p3; \
  __builtin_sve_svst4_vnum_s16(__s0, __p1, __s2, __s3.v0, __s3.v1, __s3.v2, __s3.v3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_u8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  svuint8_t __s2 = __p2; \
  __builtin_sve_svstnt1_u8(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_u32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  svuint32_t __s2 = __p2; \
  __builtin_sve_svstnt1_u32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_u64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  svuint64_t __s2 = __p2; \
  __builtin_sve_svstnt1_u64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_u16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  svuint16_t __s2 = __p2; \
  __builtin_sve_svstnt1_u16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_s8(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  svint8_t __s2 = __p2; \
  __builtin_sve_svstnt1_s8(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_f64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  svfloat64_t __s2 = __p2; \
  __builtin_sve_svstnt1_f64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_f32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  svfloat32_t __s2 = __p2; \
  __builtin_sve_svstnt1_f32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_f16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  svfloat16_t __s2 = __p2; \
  __builtin_sve_svstnt1_f16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_s32(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  svint32_t __s2 = __p2; \
  __builtin_sve_svstnt1_s32(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_s64(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  svint64_t __s2 = __p2; \
  __builtin_sve_svstnt1_s64(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_s16(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  svint16_t __s2 = __p2; \
  __builtin_sve_svstnt1_s16(__s0, __p1, __s2); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_u8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint8_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_u8(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_u32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint32_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_u32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_u64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint64_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_u64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_u16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) uint16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svuint16_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_u16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_s8(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int8_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint8_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_s8(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_f64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat64_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_f64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_f32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat32_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_f32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_f16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) float16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svfloat16_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_f16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_s32(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int32_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint32_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_s32(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_s64(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int64_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint64_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_s64(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum_s16(__p0, __p1, __p2, __p3) __extension__ ({ \
  svbool_t __s0 = __p0; \
  __attribute__((unused)) int16_t * __s1 = __p1; \
  int64_t __s2 = __p2; \
  svint16_t __s3 = __p3; \
  __builtin_sve_svstnt1_vnum_s16(__s0, __p1, __s2, __s3); \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsub_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svsub_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsub_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svsub_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsub_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svsub_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsub_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svsub_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsub_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svsub_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsub_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svsub_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsub_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svsub_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsub_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svsub_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsub_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svsub_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsub_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svsub_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsub_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svsub_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsub_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svsub_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsub_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svsub_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsub_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svsub_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsub_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svsub_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsub_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svsub_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsub_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svsub_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsub_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svsub_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsub_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svsub_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsub_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svsub_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsub_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svsub_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsub_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svsub_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsub_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsub_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsub_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsub_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsub_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsub_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsub_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsub_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svsub_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsub_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsub_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsub_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsub_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svsub_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsub_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svsub_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsub_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svsub_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsub_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svsub_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsub_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svsub_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsub_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsub_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsub_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsub_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsub_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsub_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsub_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svsub_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsub_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svsub_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsub_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svsub_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsub_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svsub_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsub_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svsub_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsub_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svsub_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsub_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svsub_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsub_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svsub_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsub_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsub_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsub_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsub_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsub_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsub_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsub_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svsub_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsub_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svsub_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsub_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svsub_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsub_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsub_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsub_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsub_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsub_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsub_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsub_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsub_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsub_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsub_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsub_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsub_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsubr_n_u8_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svsubr_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsubr_n_u32_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svsubr_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsubr_n_u64_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svsubr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsubr_n_u16_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svsubr_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsubr_n_s8_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svsubr_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsubr_n_f64_m(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svsubr_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsubr_n_f32_m(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svsubr_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsubr_n_f16_m(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svsubr_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsubr_n_s32_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svsubr_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsubr_n_s64_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svsubr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsubr_n_s16_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svsubr_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsubr_n_u8_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  __ret = __builtin_sve_svsubr_u8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsubr_n_u32_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  __ret = __builtin_sve_svsubr_u32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsubr_n_u64_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  __ret = __builtin_sve_svsubr_u64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsubr_n_u16_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  __ret = __builtin_sve_svsubr_u16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsubr_n_s8_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  __ret = __builtin_sve_svsubr_s8(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsubr_n_f64_x(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  __ret = __builtin_sve_svsubr_f64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsubr_n_f32_x(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  __ret = __builtin_sve_svsubr_f32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsubr_n_f16_x(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  __ret = __builtin_sve_svsubr_f16(__s0, __s1, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsubr_n_s32_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  __ret = __builtin_sve_svsubr_s32(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsubr_n_s64_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  __ret = __builtin_sve_svsubr_s64(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsubr_n_s16_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  __ret = __builtin_sve_svsubr_s16(__p0, __p1, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsubr_n_u8_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p2_dup = __builtin_sve_svdup_n_u8(__p2);
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsubr_n_u32_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p2_dup = __builtin_sve_svdup_n_u32(__p2);
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsubr_n_u64_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p2_dup = __builtin_sve_svdup_n_u64(__p2);
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsubr_n_u16_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p2_dup = __builtin_sve_svdup_n_u16(__p2);
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsubr_n_s8_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  svint8_t __ret;
  svint8_t __p2_dup = __builtin_sve_svdup_n_s8(__p2);
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s8(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsubr_n_f64_z(svbool_t __p0, svfloat64_t __p1, float64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p2_dup = __builtin_sve_svdup_n_f64(__p2);
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_f64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsubr_n_f32_z(svbool_t __p0, svfloat32_t __p1, float32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p2_dup = __builtin_sve_svdup_n_f32(__p2);
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_f32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsubr_n_f16_z(__p0, __p1, __p2) __extension__ ({ \
  svbool_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  float16_t __s2 = __p2; \
  svfloat16_t __ret; \
  svfloat16_t __s2_dup = __builtin_sve_svdup_n_f16(__s2); \
  svfloat16_t __s1_z = __svsel(__s0, __s1, __svzero(__s1)); \
  __ret = __builtin_sve_svsubr_f16(__s0, __s1_z, __s2_dup); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsubr_n_s32_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  svint32_t __ret;
  svint32_t __p2_dup = __builtin_sve_svdup_n_s32(__p2);
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s32(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsubr_n_s64_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  svint64_t __ret;
  svint64_t __p2_dup = __builtin_sve_svdup_n_s64(__p2);
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s64(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsubr_n_s16_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  svint16_t __ret;
  svint16_t __p2_dup = __builtin_sve_svdup_n_s16(__p2);
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s16(__p0, __p1_z, __p2_dup);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsubr_u8_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svsubr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsubr_u32_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svsubr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsubr_u64_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svsubr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsubr_u16_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svsubr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsubr_s8_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svsubr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsubr_f64_m(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsubr_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsubr_f32_m(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsubr_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsubr_f16_m(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsubr_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsubr_s32_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svsubr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsubr_s64_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svsubr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsubr_s16_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svsubr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsubr_u8_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  __ret = __builtin_sve_svsubr_u8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsubr_u32_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  __ret = __builtin_sve_svsubr_u32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsubr_u64_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  __ret = __builtin_sve_svsubr_u64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsubr_u16_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  __ret = __builtin_sve_svsubr_u16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsubr_s8_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  __ret = __builtin_sve_svsubr_s8(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsubr_f64_x(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svsubr_f64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsubr_f32_x(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svsubr_f32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsubr_f16_x(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svsubr_f16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsubr_s32_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  __ret = __builtin_sve_svsubr_s32(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsubr_s64_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  __ret = __builtin_sve_svsubr_s64(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsubr_s16_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  __ret = __builtin_sve_svsubr_s16(__p0, __p1, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svsubr_u8_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  svuint8_t __ret;
  svuint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svsubr_u32_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svuint32_t __ret;
  svuint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svsubr_u64_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svuint64_t __ret;
  svuint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svsubr_u16_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  svuint16_t __ret;
  svuint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_u16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svsubr_s8_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  svint8_t __ret;
  svint8_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s8(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svsubr_f64_z(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  svfloat64_t __ret;
  svfloat64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_f64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svsubr_f32_z(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  svfloat32_t __ret;
  svfloat32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_f32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svsubr_f16_z(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  svfloat16_t __ret;
  svfloat16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_f16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svsubr_s32_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  svint32_t __ret;
  svint32_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s32(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svsubr_s64_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  svint64_t __ret;
  svint64_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s64(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svsubr_s16_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  svint16_t __ret;
  svint16_t __p1_z = __svsel(__p0, __p1, __svzero(__p1));
  __ret = __builtin_sve_svsubr_s16(__p0, __p1_z, __p2);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svtbl_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svtbl_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svtbl_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svtbl_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svtbl_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svtbl_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svtbl_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svtbl_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svtbl_s8(svint8_t __p0, svuint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svtbl_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svtbl_f64(svfloat64_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svtbl_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svtbl_f32(svfloat32_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svtbl_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svtbl_f16(svfloat16_t __p0, svuint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svtbl_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svtbl_s32(svint32_t __p0, svuint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svtbl_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svtbl_s64(svint64_t __p0, svuint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svtbl_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svtbl_s16(svint16_t __p0, svuint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svtbl_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svtmad_f64(__p0, __p1, __p2) __extension__ ({ \
  svfloat64_t __s0 = __p0; \
  svfloat64_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat64_t __ret; \
  __ret = __builtin_sve_svtmad_f64(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svtmad_f32(__p0, __p1, __p2) __extension__ ({ \
  svfloat32_t __s0 = __p0; \
  svfloat32_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat32_t __ret; \
  __ret = __builtin_sve_svtmad_f32(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svtmad_f16(__p0, __p1, __p2) __extension__ ({ \
  svfloat16_t __s0 = __p0; \
  svfloat16_t __s1 = __p1; \
  __attribute__((unused)) uint64_t __s2 = __p2; \
  svfloat16_t __ret; \
  __ret = __builtin_sve_svtmad_f16(__s0, __s1, __p2); \
  __ret; \
})
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svtrn1_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svtrn1_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svtrn1_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svtrn1_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svtrn1_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svtrn1_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svtrn1_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svtrn1_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svtrn1_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svtrn1_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svtrn1_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svtrn1_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svtrn1_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svtrn1_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svtrn1_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svtrn1_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svtrn1_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svtrn1_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svtrn1_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svtrn1_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svtrn1_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svtrn1_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn1_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn1_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn1_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn1_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn1_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn1_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn1_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn1_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svtrn2_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svtrn2_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svtrn2_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svtrn2_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svtrn2_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svtrn2_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svtrn2_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svtrn2_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svtrn2_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svtrn2_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svtrn2_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svtrn2_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svtrn2_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svtrn2_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svtrn2_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svtrn2_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svtrn2_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svtrn2_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svtrn2_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svtrn2_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svtrn2_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svtrn2_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn2_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn2_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn2_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn2_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn2_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn2_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svtrn2_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svtrn2_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svtsmul_f64(svfloat64_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svtsmul_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svtsmul_f32(svfloat32_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svtsmul_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svtsmul_f16(svfloat16_t __p0, svuint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svtsmul_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svtssel_f64(svfloat64_t __p0, svuint64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svtssel_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svtssel_f32(svfloat32_t __p0, svuint32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svtssel_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svtssel_f16(svfloat16_t __p0, svuint16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svtssel_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svundef_u8() {
  svuint8_t __ret;
  __ret = __builtin_sve_svundef_u8();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svundef_u32() {
  svuint32_t __ret;
  __ret = __builtin_sve_svundef_u32();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svundef_u64() {
  svuint64_t __ret;
  __ret = __builtin_sve_svundef_u64();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svundef_u16() {
  svuint16_t __ret;
  __ret = __builtin_sve_svundef_u16();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svundef_s8() {
  svint8_t __ret;
  __ret = __builtin_sve_svundef_s8();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svundef_f64() {
  svfloat64_t __ret;
  __ret = __builtin_sve_svundef_f64();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svundef_f32() {
  svfloat32_t __ret;
  __ret = __builtin_sve_svundef_f32();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svundef_f16() {
  svfloat16_t __ret;
  __ret = __builtin_sve_svundef_f16();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svundef_s32() {
  svint32_t __ret;
  __ret = __builtin_sve_svundef_s32();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svundef_s64() {
  svint64_t __ret;
  __ret = __builtin_sve_svundef_s64();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svundef_s16() {
  svint16_t __ret;
  __ret = __builtin_sve_svundef_s16();
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svunpkhi_b(svbool_t __p0) {
  svbool_t __ret;
  __ret = __builtin_sve_svunpkhi_b(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svunpkhi_s32(svint16_t __p0) {
  svint32_t __ret;
  __ret = __builtin_sve_svunpkhi_s32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svunpkhi_s64(svint32_t __p0) {
  svint64_t __ret;
  __ret = __builtin_sve_svunpkhi_s64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svunpkhi_s16(svint8_t __p0) {
  svint16_t __ret;
  __ret = __builtin_sve_svunpkhi_s16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svunpkhi_u32(svuint16_t __p0) {
  svuint32_t __ret;
  __ret = __builtin_sve_svunpkhi_u32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svunpkhi_u64(svuint32_t __p0) {
  svuint64_t __ret;
  __ret = __builtin_sve_svunpkhi_u64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svunpkhi_u16(svuint8_t __p0) {
  svuint16_t __ret;
  __ret = __builtin_sve_svunpkhi_u16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svunpklo_b(svbool_t __p0) {
  svbool_t __ret;
  __ret = __builtin_sve_svunpklo_b(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svunpklo_s32(svint16_t __p0) {
  svint32_t __ret;
  __ret = __builtin_sve_svunpklo_s32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svunpklo_s64(svint32_t __p0) {
  svint64_t __ret;
  __ret = __builtin_sve_svunpklo_s64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svunpklo_s16(svint8_t __p0) {
  svint16_t __ret;
  __ret = __builtin_sve_svunpklo_s16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svunpklo_u32(svuint16_t __p0) {
  svuint32_t __ret;
  __ret = __builtin_sve_svunpklo_u32(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svunpklo_u64(svuint32_t __p0) {
  svuint64_t __ret;
  __ret = __builtin_sve_svunpklo_u64(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svunpklo_u16(svuint8_t __p0) {
  svuint16_t __ret;
  __ret = __builtin_sve_svunpklo_u16(__p0);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svuzp1_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svuzp1_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svuzp1_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svuzp1_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svuzp1_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svuzp1_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svuzp1_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svuzp1_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svuzp1_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svuzp1_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svuzp1_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svuzp1_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svuzp1_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svuzp1_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svuzp1_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svuzp1_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svuzp1_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svuzp1_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svuzp1_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svuzp1_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svuzp1_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svuzp1_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp1_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp1_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp1_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp1_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp1_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp1_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp1_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp1_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svuzp2_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svuzp2_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svuzp2_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svuzp2_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svuzp2_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svuzp2_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svuzp2_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svuzp2_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svuzp2_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svuzp2_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svuzp2_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svuzp2_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svuzp2_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svuzp2_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svuzp2_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svuzp2_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svuzp2_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svuzp2_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svuzp2_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svuzp2_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svuzp2_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svuzp2_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp2_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp2_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp2_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp2_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp2_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp2_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svuzp2_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svuzp2_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b8_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b8_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b32_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b32_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b64_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b64_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b16_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b16_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b8_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b8_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b32_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b32_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b64_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b64_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b16_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b16_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b8_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b8_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b32_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b32_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b64_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b64_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b16_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b16_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b8_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b8_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b32_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b32_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b64_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b64_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilele_b16_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilele_b16_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b8_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b8_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b32_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b32_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b64_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b64_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b16_u32(uint32_t __p0, uint32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b16_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b8_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b8_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b32_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b32_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b64_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b64_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b16_u64(uint64_t __p0, uint64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b16_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b8_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b8_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b32_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b32_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b64_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b64_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b16_s32(int32_t __p0, int32_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b16_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b8_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b8_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b32_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b32_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b64_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b64_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svwhilelt_b16_s64(int64_t __p0, int64_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svwhilelt_b16_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai void svwrffr(svbool_t __p0) {
  __builtin_sve_svwrffr(__p0);
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svzip1_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svzip1_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svzip1_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svzip1_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svzip1_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svzip1_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svzip1_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svzip1_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svzip1_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svzip1_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svzip1_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svzip1_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svzip1_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svzip1_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svzip1_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svzip1_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svzip1_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svzip1_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svzip1_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svzip1_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svzip1_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svzip1_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip1_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip1_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip1_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip1_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip1_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip1_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip1_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip1_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint8_t svzip2_u8(svuint8_t __p0, svuint8_t __p1) {
  svuint8_t __ret;
  __ret = __builtin_sve_svzip2_u8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint32_t svzip2_u32(svuint32_t __p0, svuint32_t __p1) {
  svuint32_t __ret;
  __ret = __builtin_sve_svzip2_u32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint64_t svzip2_u64(svuint64_t __p0, svuint64_t __p1) {
  svuint64_t __ret;
  __ret = __builtin_sve_svzip2_u64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svuint16_t svzip2_u16(svuint16_t __p0, svuint16_t __p1) {
  svuint16_t __ret;
  __ret = __builtin_sve_svzip2_u16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint8_t svzip2_s8(svint8_t __p0, svint8_t __p1) {
  svint8_t __ret;
  __ret = __builtin_sve_svzip2_s8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat64_t svzip2_f64(svfloat64_t __p0, svfloat64_t __p1) {
  svfloat64_t __ret;
  __ret = __builtin_sve_svzip2_f64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat32_t svzip2_f32(svfloat32_t __p0, svfloat32_t __p1) {
  svfloat32_t __ret;
  __ret = __builtin_sve_svzip2_f32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svfloat16_t svzip2_f16(svfloat16_t __p0, svfloat16_t __p1) {
  svfloat16_t __ret;
  __ret = __builtin_sve_svzip2_f16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint32_t svzip2_s32(svint32_t __p0, svint32_t __p1) {
  svint32_t __ret;
  __ret = __builtin_sve_svzip2_s32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint64_t svzip2_s64(svint64_t __p0, svint64_t __p1) {
  svint64_t __ret;
  __ret = __builtin_sve_svzip2_s64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svint16_t svzip2_s16(svint16_t __p0, svint16_t __p1) {
  svint16_t __ret;
  __ret = __builtin_sve_svzip2_s16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip2_b8(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip2_b8(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip2_b32(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip2_b32(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip2_b64(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip2_b64(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svzip2_b16(svbool_t __p0, svbool_t __p1) {
  svbool_t __ret;
  __ret = __builtin_sve_svzip2_b16(__p0, __p1);
  return __ret;
}
#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svabd_x(__p0, __p1, __p2)  \
__extension__({ \
  svabd_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svabd_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svabd_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svabd_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_f16,\
      svfloat16_t: __builtin_sve_svabd_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_f32,\
      svfloat32_t: __builtin_sve_svabd_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_f64,\
      svfloat64_t: __builtin_sve_svabd_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_s16,\
      svint16_t: __builtin_sve_svabd_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_s32,\
      svint32_t: __builtin_sve_svabd_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_s64,\
      svint64_t: __builtin_sve_svabd_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svabd_s8,\
      svint8_t: __builtin_sve_svabd_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svabd_u16,\
      default: __builtin_sve_svabd_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svabd_u32,\
      default: __builtin_sve_svabd_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svabd_u64,\
      default: __builtin_sve_svabd_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svabd_u8,\
      default: __builtin_sve_svabd_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svabs_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svabs_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svabs_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svabs_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svabs_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svabs_f64_m( __p0,  __p1,  __p2);
}
__aio svint16_t svabs_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svabs_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svabs_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svabs_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svabs_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svabs_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svabs_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svabs_s8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svabs_x(svbool_t __p0, svfloat16_t __p1) {
  return svabs_f16_x( __p0,  __p1);
}
__aio svfloat32_t svabs_x(svbool_t __p0, svfloat32_t __p1) {
  return svabs_f32_x( __p0,  __p1);
}
__aio svfloat64_t svabs_x(svbool_t __p0, svfloat64_t __p1) {
  return svabs_f64_x( __p0,  __p1);
}
__aio svint16_t svabs_x(svbool_t __p0, svint16_t __p1) {
  return svabs_s16_x( __p0,  __p1);
}
__aio svint32_t svabs_x(svbool_t __p0, svint32_t __p1) {
  return svabs_s32_x( __p0,  __p1);
}
__aio svint64_t svabs_x(svbool_t __p0, svint64_t __p1) {
  return svabs_s64_x( __p0,  __p1);
}
__aio svint8_t svabs_x(svbool_t __p0, svint8_t __p1) {
  return svabs_s8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svabs_z(svbool_t __p0, svfloat16_t __p1) {
  return svabs_f16_z( __p0,  __p1);
}
__aio svfloat32_t svabs_z(svbool_t __p0, svfloat32_t __p1) {
  return svabs_f32_z( __p0,  __p1);
}
__aio svfloat64_t svabs_z(svbool_t __p0, svfloat64_t __p1) {
  return svabs_f64_z( __p0,  __p1);
}
__aio svint16_t svabs_z(svbool_t __p0, svint16_t __p1) {
  return svabs_s16_z( __p0,  __p1);
}
__aio svint32_t svabs_z(svbool_t __p0, svint32_t __p1) {
  return svabs_s32_z( __p0,  __p1);
}
__aio svint64_t svabs_z(svbool_t __p0, svint64_t __p1) {
  return svabs_s64_z( __p0,  __p1);
}
__aio svint8_t svabs_z(svbool_t __p0, svint8_t __p1) {
  return svabs_s8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svacge(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svacge_f16,\
      svfloat16_t: __builtin_sve_svacge_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svacge_f32,\
      svfloat32_t: __builtin_sve_svacge_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svacge_f64,\
      svfloat64_t: __builtin_sve_svacge_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svacgt(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svacgt_f16,\
      svfloat16_t: __builtin_sve_svacgt_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svacgt_f32,\
      svfloat32_t: __builtin_sve_svacgt_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svacgt_f64,\
      svfloat64_t: __builtin_sve_svacgt_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svacle(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svacle_f16,\
      svfloat16_t: __builtin_sve_svacle_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svacle_f32,\
      svfloat32_t: __builtin_sve_svacle_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svacle_f64,\
      svfloat64_t: __builtin_sve_svacle_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svaclt(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svaclt_f16,\
      svfloat16_t: __builtin_sve_svaclt_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svaclt_f32,\
      svfloat32_t: __builtin_sve_svaclt_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svaclt_f64,\
      svfloat64_t: __builtin_sve_svaclt_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadd_x(__p0, __p1, __p2)  \
__extension__({ \
  svadd_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadd_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svadd_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadd_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_f16,\
      svfloat16_t: __builtin_sve_svadd_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_f32,\
      svfloat32_t: __builtin_sve_svadd_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_f64,\
      svfloat64_t: __builtin_sve_svadd_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_s16,\
      svint16_t: __builtin_sve_svadd_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_s32,\
      svint32_t: __builtin_sve_svadd_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_s64,\
      svint64_t: __builtin_sve_svadd_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svadd_s8,\
      svint8_t: __builtin_sve_svadd_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svadd_u16,\
      default: __builtin_sve_svadd_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svadd_u32,\
      default: __builtin_sve_svadd_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svadd_u64,\
      default: __builtin_sve_svadd_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svadd_u8,\
      default: __builtin_sve_svadd_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svadda(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svadda_f16,\
    float32_t: __builtin_sve_svadda_f32,\
    float64_t: __builtin_sve_svadda_f64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svaddv(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svaddv_f16,\
    svfloat32_t: __builtin_sve_svaddv_f32,\
    svfloat64_t: __builtin_sve_svaddv_f64,\
    svint16_t: __builtin_sve_svaddv_s16,\
    svint32_t: __builtin_sve_svaddv_s32,\
    svint64_t: __builtin_sve_svaddv_s64,\
    svint8_t: __builtin_sve_svaddv_s8,\
    svuint16_t: __builtin_sve_svaddv_u16,\
    svuint32_t: __builtin_sve_svaddv_u32,\
    svuint64_t: __builtin_sve_svaddv_u64,\
    svuint8_t: __builtin_sve_svaddv_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svadrb_offset(svuint32_t __p0, svint32_t __p1) {
  return svadrb_u32base_s32offset( __p0,  __p1);
}
__aio svuint32_t svadrb_offset(svuint32_t __p0, svuint32_t __p1) {
  return svadrb_u32base_u32offset( __p0,  __p1);
}
__aio svuint64_t svadrb_offset(svuint64_t __p0, svint64_t __p1) {
  return svadrb_u64base_s64offset( __p0,  __p1);
}
__aio svuint64_t svadrb_offset(svuint64_t __p0, svuint64_t __p1) {
  return svadrb_u64base_u64offset( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svadrd_index(svuint32_t __p0, svint32_t __p1) {
  return svadrd_u32base_s32index( __p0,  __p1);
}
__aio svuint32_t svadrd_index(svuint32_t __p0, svuint32_t __p1) {
  return svadrd_u32base_u32index( __p0,  __p1);
}
__aio svuint64_t svadrd_index(svuint64_t __p0, svint64_t __p1) {
  return svadrd_u64base_s64index( __p0,  __p1);
}
__aio svuint64_t svadrd_index(svuint64_t __p0, svuint64_t __p1) {
  return svadrd_u64base_u64index( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svadrh_index(svuint32_t __p0, svint32_t __p1) {
  return svadrh_u32base_s32index( __p0,  __p1);
}
__aio svuint32_t svadrh_index(svuint32_t __p0, svuint32_t __p1) {
  return svadrh_u32base_u32index( __p0,  __p1);
}
__aio svuint64_t svadrh_index(svuint64_t __p0, svint64_t __p1) {
  return svadrh_u64base_s64index( __p0,  __p1);
}
__aio svuint64_t svadrh_index(svuint64_t __p0, svuint64_t __p1) {
  return svadrh_u64base_u64index( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svadrw_index(svuint32_t __p0, svint32_t __p1) {
  return svadrw_u32base_s32index( __p0,  __p1);
}
__aio svuint32_t svadrw_index(svuint32_t __p0, svuint32_t __p1) {
  return svadrw_u32base_u32index( __p0,  __p1);
}
__aio svuint64_t svadrw_index(svuint64_t __p0, svint64_t __p1) {
  return svadrw_u64base_s64index( __p0,  __p1);
}
__aio svuint64_t svadrw_index(svuint64_t __p0, svuint64_t __p1) {
  return svadrw_u64base_u64index( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svand_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svand_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svand_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svand_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svand_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svand_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svand_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svand_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svand_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svand_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svand_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svand_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svand_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svand_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svand_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svand_n_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svand_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svand_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svand_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svand_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svand_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svand_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svand_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svand_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svand_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svand_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svand_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svand_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svand_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svand_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svand_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svand_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svand_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svand_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svand_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svand_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svand_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svand_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svand_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svand_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svand_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svand_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svand_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svand_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svand_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svand_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svand_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svand_n_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svand_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svand_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svand_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svand_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svand_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svand_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svand_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svand_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svand_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svand_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svand_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svand_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svand_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svand_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svand_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svand_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svand_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svand_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svand_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svand_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svand_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svand_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svand_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svand_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svand_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svand_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svand_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svand_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svand_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svand_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svand_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svand_n_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svand_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svand_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svand_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svand_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svand_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svand_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svand_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svand_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svand_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svand_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svand_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svand_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svand_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svand_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svand_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svand_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svand_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svand_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int16_t svandv(svbool_t __p0, svint16_t __p1) {
  return svandv_s16( __p0,  __p1);
}
__aio int32_t svandv(svbool_t __p0, svint32_t __p1) {
  return svandv_s32( __p0,  __p1);
}
__aio int64_t svandv(svbool_t __p0, svint64_t __p1) {
  return svandv_s64( __p0,  __p1);
}
__aio int8_t svandv(svbool_t __p0, svint8_t __p1) {
  return svandv_s8( __p0,  __p1);
}
__aio uint16_t svandv(svbool_t __p0, svuint16_t __p1) {
  return svandv_u16( __p0,  __p1);
}
__aio uint32_t svandv(svbool_t __p0, svuint32_t __p1) {
  return svandv_u32( __p0,  __p1);
}
__aio uint64_t svandv(svbool_t __p0, svuint64_t __p1) {
  return svandv_u64( __p0,  __p1);
}
__aio uint8_t svandv(svbool_t __p0, svuint8_t __p1) {
  return svandv_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svasr_x(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svasr_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svasr_x(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svasr_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_x(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svasr_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_x(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svasr_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svasr_x(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svasr_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svasr_x(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svasr_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_x(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svasr_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_x(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svasr_n_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svasr_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_x(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svasr_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svasr_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_x(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svasr_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svasr_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svasr_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svasr_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svasr_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svasr_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_x(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svasr_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svasr_z(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svasr_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svasr_z(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svasr_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_z(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svasr_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_z(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svasr_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svasr_z(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svasr_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svasr_z(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svasr_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_z(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svasr_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_z(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svasr_n_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svasr_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_z(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svasr_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svasr_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_z(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svasr_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svasr_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svasr_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svasr_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svasr_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svasr_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_z(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svasr_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svasr_m(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svasr_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svasr_m(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svasr_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_m(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svasr_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_m(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svasr_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svasr_m(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svasr_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svasr_m(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svasr_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_m(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svasr_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_m(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svasr_n_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svasr_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_m(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svasr_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svasr_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_m(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svasr_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svasr_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svasr_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svasr_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svasr_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svasr_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_m(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svasr_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svasr_wide_m(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svasr_wide_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_wide_m(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svasr_wide_s32_m( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_wide_m(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svasr_wide_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_wide_m(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svasr_wide_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_wide_m(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svasr_wide_u32_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_wide_m(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svasr_wide_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svasr_wide_x(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svasr_wide_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_wide_x(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svasr_wide_s32_x( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_wide_x(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svasr_wide_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_wide_x(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svasr_wide_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_wide_x(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svasr_wide_u32_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_wide_x(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svasr_wide_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svasr_wide_z(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svasr_wide_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svasr_wide_z(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svasr_wide_s32_z( __p0,  __p1,  __p2);
}
__aio svint8_t svasr_wide_z(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svasr_wide_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svasr_wide_z(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svasr_wide_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svasr_wide_z(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svasr_wide_u32_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svasr_wide_z(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svasr_wide_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svasrd_n_s16,\
    svint32_t: __builtin_sve_svasrd_n_s32,\
    svint64_t: __builtin_sve_svasrd_n_s64,\
    svint8_t: __builtin_sve_svasrd_n_s8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_x(__p0, __p1, __p2)  \
__extension__({ \
  svasrd_m(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svasrd_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svasrd_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbic_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svbic_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svbic_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svbic_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svbic_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svbic_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svbic_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svbic_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svbic_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svbic_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svbic_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svbic_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svbic_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svbic_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svbic_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svbic_n_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svbic_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svbic_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svbic_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svbic_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svbic_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svbic_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svbic_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svbic_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svbic_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svbic_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svbic_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svbic_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svbic_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svbic_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svbic_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svbic_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svbic_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svbic_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svbic_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svbic_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svbic_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svbic_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svbic_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svbic_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svbic_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svbic_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svbic_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svbic_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svbic_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svbic_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svbic_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svbic_n_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svbic_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svbic_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svbic_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svbic_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svbic_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svbic_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svbic_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svbic_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svbic_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svbic_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svbic_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svbic_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svbic_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svbic_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svbic_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svbic_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svbic_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svbic_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svbic_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svbic_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svbic_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svbic_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svbic_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svbic_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svbic_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svbic_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svbic_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svbic_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svbic_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svbic_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svbic_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svbic_n_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svbic_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svbic_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svbic_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svbic_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svbic_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svbic_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svbic_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svbic_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svbic_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svbic_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svbic_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svbic_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svbic_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svbic_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svbic_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svbic_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svbic_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svbic_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrka_m(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svbrka_b_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrka_z(svbool_t __p0, svbool_t __p1) {
  return svbrka_b_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrkb_m(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svbrkb_b_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrkb_z(svbool_t __p0, svbool_t __p1) {
  return svbrkb_b_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrkn_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svbrkn_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrkpa_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svbrkpa_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svbrkpb_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svbrkpb_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svcadd_f16,\
    svfloat32_t: __builtin_sve_svcadd_f32,\
    svfloat64_t: __builtin_sve_svcadd_f64)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svcadd_m(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcadd_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svcadd_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svclasta(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svclasta_n_f16,\
    float32_t: __builtin_sve_svclasta_n_f32,\
    float64_t: __builtin_sve_svclasta_n_f64,\
    int16_t: __builtin_sve_svclasta_n_s16,\
    int32_t: __builtin_sve_svclasta_n_s32,\
    int64_t: __builtin_sve_svclasta_n_s64,\
    int8_t: __builtin_sve_svclasta_n_s8,\
    svfloat16_t: __builtin_sve_svclasta_f16,\
    svfloat32_t: __builtin_sve_svclasta_f32,\
    svfloat64_t: __builtin_sve_svclasta_f64,\
    svint16_t: __builtin_sve_svclasta_s16,\
    svint32_t: __builtin_sve_svclasta_s32,\
    svint64_t: __builtin_sve_svclasta_s64,\
    svint8_t: __builtin_sve_svclasta_s8,\
    svuint16_t: __builtin_sve_svclasta_u16,\
    svuint32_t: __builtin_sve_svclasta_u32,\
    svuint64_t: __builtin_sve_svclasta_u64,\
    svuint8_t: __builtin_sve_svclasta_u8,\
    uint16_t: __builtin_sve_svclasta_n_u16,\
    uint32_t: __builtin_sve_svclasta_n_u32,\
    uint64_t: __builtin_sve_svclasta_n_u64,\
    uint8_t: __builtin_sve_svclasta_n_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svclastb(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svclastb_n_f16,\
    float32_t: __builtin_sve_svclastb_n_f32,\
    float64_t: __builtin_sve_svclastb_n_f64,\
    int16_t: __builtin_sve_svclastb_n_s16,\
    int32_t: __builtin_sve_svclastb_n_s32,\
    int64_t: __builtin_sve_svclastb_n_s64,\
    int8_t: __builtin_sve_svclastb_n_s8,\
    svfloat16_t: __builtin_sve_svclastb_f16,\
    svfloat32_t: __builtin_sve_svclastb_f32,\
    svfloat64_t: __builtin_sve_svclastb_f64,\
    svint16_t: __builtin_sve_svclastb_s16,\
    svint32_t: __builtin_sve_svclastb_s32,\
    svint64_t: __builtin_sve_svclastb_s64,\
    svint8_t: __builtin_sve_svclastb_s8,\
    svuint16_t: __builtin_sve_svclastb_u16,\
    svuint32_t: __builtin_sve_svclastb_u32,\
    svuint64_t: __builtin_sve_svclastb_u64,\
    svuint8_t: __builtin_sve_svclastb_u8,\
    uint16_t: __builtin_sve_svclastb_n_u16,\
    uint32_t: __builtin_sve_svclastb_n_u32,\
    uint64_t: __builtin_sve_svclastb_n_u64,\
    uint8_t: __builtin_sve_svclastb_n_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcls_m(svuint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svcls_s16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcls_m(svuint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svcls_s32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcls_m(svuint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svcls_s64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svcls_m(svuint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svcls_s8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcls_x(svbool_t __p0, svint16_t __p1) {
  return svcls_s16_x( __p0,  __p1);
}
__aio svuint32_t svcls_x(svbool_t __p0, svint32_t __p1) {
  return svcls_s32_x( __p0,  __p1);
}
__aio svuint64_t svcls_x(svbool_t __p0, svint64_t __p1) {
  return svcls_s64_x( __p0,  __p1);
}
__aio svuint8_t svcls_x(svbool_t __p0, svint8_t __p1) {
  return svcls_s8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcls_z(svbool_t __p0, svint16_t __p1) {
  return svcls_s16_z( __p0,  __p1);
}
__aio svuint32_t svcls_z(svbool_t __p0, svint32_t __p1) {
  return svcls_s32_z( __p0,  __p1);
}
__aio svuint64_t svcls_z(svbool_t __p0, svint64_t __p1) {
  return svcls_s64_z( __p0,  __p1);
}
__aio svuint8_t svcls_z(svbool_t __p0, svint8_t __p1) {
  return svcls_s8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svclz_m(svuint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svclz_s16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svclz_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svclz_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svclz_m(svuint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svclz_s32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svclz_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svclz_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svclz_m(svuint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svclz_s64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svclz_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svclz_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svclz_m(svuint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svclz_s8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svclz_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  return svclz_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svclz_x(svbool_t __p0, svint16_t __p1) {
  return svclz_s16_x( __p0,  __p1);
}
__aio svuint32_t svclz_x(svbool_t __p0, svint32_t __p1) {
  return svclz_s32_x( __p0,  __p1);
}
__aio svuint64_t svclz_x(svbool_t __p0, svint64_t __p1) {
  return svclz_s64_x( __p0,  __p1);
}
__aio svuint8_t svclz_x(svbool_t __p0, svint8_t __p1) {
  return svclz_s8_x( __p0,  __p1);
}
__aio svuint16_t svclz_x(svbool_t __p0, svuint16_t __p1) {
  return svclz_u16_x( __p0,  __p1);
}
__aio svuint32_t svclz_x(svbool_t __p0, svuint32_t __p1) {
  return svclz_u32_x( __p0,  __p1);
}
__aio svuint64_t svclz_x(svbool_t __p0, svuint64_t __p1) {
  return svclz_u64_x( __p0,  __p1);
}
__aio svuint8_t svclz_x(svbool_t __p0, svuint8_t __p1) {
  return svclz_u8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svclz_z(svbool_t __p0, svint16_t __p1) {
  return svclz_s16_z( __p0,  __p1);
}
__aio svuint32_t svclz_z(svbool_t __p0, svint32_t __p1) {
  return svclz_s32_z( __p0,  __p1);
}
__aio svuint64_t svclz_z(svbool_t __p0, svint64_t __p1) {
  return svclz_s64_z( __p0,  __p1);
}
__aio svuint8_t svclz_z(svbool_t __p0, svint8_t __p1) {
  return svclz_s8_z( __p0,  __p1);
}
__aio svuint16_t svclz_z(svbool_t __p0, svuint16_t __p1) {
  return svclz_u16_z( __p0,  __p1);
}
__aio svuint32_t svclz_z(svbool_t __p0, svuint32_t __p1) {
  return svclz_u32_z( __p0,  __p1);
}
__aio svuint64_t svclz_z(svbool_t __p0, svuint64_t __p1) {
  return svclz_u64_z( __p0,  __p1);
}
__aio svuint8_t svclz_z(svbool_t __p0, svuint8_t __p1) {
  return svclz_u8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_m(__p0, __p1, __p2, __p3, __p4)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svcmla_f16,\
    svfloat32_t: __builtin_sve_svcmla_f32,\
    svfloat64_t: __builtin_sve_svcmla_f64)(__p0, __p1, __p2, __p3, __p4); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_x(__p0, __p1, __p2, __p3, __p4)  \
__extension__({ \
  svcmla_m(__p0, __p1, __p2, __p3, __p4); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_z(__p0, __p1, __p2, __p3, __p4)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svcmla_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __p3, __p4); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmla_lane(__p0, __p1, __p2, __p3, __p4)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svcmla_lane_f16,\
  svfloat32_t: __builtin_sve_svcmla_lane_f32)(__p0, __p1, __p2, __p3, __p4); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpeq(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_f16,\
      svfloat16_t: __builtin_sve_svcmpeq_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_f32,\
      svfloat32_t: __builtin_sve_svcmpeq_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_f64,\
      svfloat64_t: __builtin_sve_svcmpeq_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_wide_s16,\
      svint16_t: __builtin_sve_svcmpeq_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_wide_s32,\
      svint32_t: __builtin_sve_svcmpeq_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_s64,\
      svint64_t: __builtin_sve_svcmpeq_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpeq_wide_s8,\
      svint8_t: __builtin_sve_svcmpeq_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svcmpeq_u16,\
      default: __builtin_sve_svcmpeq_wide_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svcmpeq_u32,\
      default: __builtin_sve_svcmpeq_wide_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svcmpeq_u64,\
      default: __builtin_sve_svcmpeq_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svcmpeq_u8,\
      default: __builtin_sve_svcmpeq_wide_u8))(__p0, __p1, __svdup_wide(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svcmpeq_wide(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  return svcmpeq_wide_s16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpeq_wide(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  return svcmpeq_wide_s32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpeq_wide(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  return svcmpeq_wide_s8( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpeq_wide(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svcmpeq_wide_u16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpeq_wide(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svcmpeq_wide_u32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpeq_wide(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svcmpeq_wide_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpge(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_f16,\
      svfloat16_t: __builtin_sve_svcmpge_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_f32,\
      svfloat32_t: __builtin_sve_svcmpge_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_f64,\
      svfloat64_t: __builtin_sve_svcmpge_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_wide_s16,\
      svint16_t: __builtin_sve_svcmpge_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_wide_s32,\
      svint32_t: __builtin_sve_svcmpge_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_s64,\
      svint64_t: __builtin_sve_svcmpge_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpge_wide_s8,\
      svint8_t: __builtin_sve_svcmpge_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svcmpge_u16,\
      default: __builtin_sve_svcmpge_wide_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svcmpge_u32,\
      default: __builtin_sve_svcmpge_wide_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svcmpge_u64,\
      default: __builtin_sve_svcmpge_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svcmpge_u8,\
      default: __builtin_sve_svcmpge_wide_u8))(__p0, __p1, __svdup_wide(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svcmpge_wide(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  return svcmpge_wide_s16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpge_wide(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  return svcmpge_wide_s32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpge_wide(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  return svcmpge_wide_s8( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpge_wide(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svcmpge_wide_u16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpge_wide(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svcmpge_wide_u32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpge_wide(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svcmpge_wide_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpgt(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_f16,\
      svfloat16_t: __builtin_sve_svcmpgt_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_f32,\
      svfloat32_t: __builtin_sve_svcmpgt_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_f64,\
      svfloat64_t: __builtin_sve_svcmpgt_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_wide_s16,\
      svint16_t: __builtin_sve_svcmpgt_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_wide_s32,\
      svint32_t: __builtin_sve_svcmpgt_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_s64,\
      svint64_t: __builtin_sve_svcmpgt_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpgt_wide_s8,\
      svint8_t: __builtin_sve_svcmpgt_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svcmpgt_u16,\
      default: __builtin_sve_svcmpgt_wide_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svcmpgt_u32,\
      default: __builtin_sve_svcmpgt_wide_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svcmpgt_u64,\
      default: __builtin_sve_svcmpgt_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svcmpgt_u8,\
      default: __builtin_sve_svcmpgt_wide_u8))(__p0, __p1, __svdup_wide(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svcmpgt_wide(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  return svcmpgt_wide_s16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpgt_wide(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  return svcmpgt_wide_s32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpgt_wide(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  return svcmpgt_wide_s8( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpgt_wide(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svcmpgt_wide_u16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpgt_wide(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svcmpgt_wide_u32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpgt_wide(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svcmpgt_wide_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmple(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_f16,\
      svfloat16_t: __builtin_sve_svcmple_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_f32,\
      svfloat32_t: __builtin_sve_svcmple_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_f64,\
      svfloat64_t: __builtin_sve_svcmple_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_wide_s16,\
      svint16_t: __builtin_sve_svcmple_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_wide_s32,\
      svint32_t: __builtin_sve_svcmple_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_s64,\
      svint64_t: __builtin_sve_svcmple_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmple_wide_s8,\
      svint8_t: __builtin_sve_svcmple_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svcmple_u16,\
      default: __builtin_sve_svcmple_wide_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svcmple_u32,\
      default: __builtin_sve_svcmple_wide_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svcmple_u64,\
      default: __builtin_sve_svcmple_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svcmple_u8,\
      default: __builtin_sve_svcmple_wide_u8))(__p0, __p1, __svdup_wide(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svcmple_wide(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  return svcmple_wide_s16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmple_wide(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  return svcmple_wide_s32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmple_wide(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  return svcmple_wide_s8( __p0,  __p1,  __p2);
}
__aio svbool_t svcmple_wide(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svcmple_wide_u16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmple_wide(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svcmple_wide_u32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmple_wide(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svcmple_wide_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmplt(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_f16,\
      svfloat16_t: __builtin_sve_svcmplt_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_f32,\
      svfloat32_t: __builtin_sve_svcmplt_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_f64,\
      svfloat64_t: __builtin_sve_svcmplt_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_wide_s16,\
      svint16_t: __builtin_sve_svcmplt_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_wide_s32,\
      svint32_t: __builtin_sve_svcmplt_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_s64,\
      svint64_t: __builtin_sve_svcmplt_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmplt_wide_s8,\
      svint8_t: __builtin_sve_svcmplt_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svcmplt_u16,\
      default: __builtin_sve_svcmplt_wide_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svcmplt_u32,\
      default: __builtin_sve_svcmplt_wide_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svcmplt_u64,\
      default: __builtin_sve_svcmplt_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svcmplt_u8,\
      default: __builtin_sve_svcmplt_wide_u8))(__p0, __p1, __svdup_wide(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svcmplt_wide(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  return svcmplt_wide_s16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmplt_wide(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  return svcmplt_wide_s32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmplt_wide(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  return svcmplt_wide_s8( __p0,  __p1,  __p2);
}
__aio svbool_t svcmplt_wide(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svcmplt_wide_u16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmplt_wide(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svcmplt_wide_u32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmplt_wide(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svcmplt_wide_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpne(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_f16,\
      svfloat16_t: __builtin_sve_svcmpne_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_f32,\
      svfloat32_t: __builtin_sve_svcmpne_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_f64,\
      svfloat64_t: __builtin_sve_svcmpne_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_wide_s16,\
      svint16_t: __builtin_sve_svcmpne_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_wide_s32,\
      svint32_t: __builtin_sve_svcmpne_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_s64,\
      svint64_t: __builtin_sve_svcmpne_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpne_wide_s8,\
      svint8_t: __builtin_sve_svcmpne_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svcmpne_u16,\
      default: __builtin_sve_svcmpne_wide_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svcmpne_u32,\
      default: __builtin_sve_svcmpne_wide_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svcmpne_u64,\
      default: __builtin_sve_svcmpne_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svcmpne_u8,\
      default: __builtin_sve_svcmpne_wide_u8))(__p0, __p1, __svdup_wide(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svcmpne_wide(svbool_t __p0, svint16_t __p1, svint64_t __p2) {
  return svcmpne_wide_s16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpne_wide(svbool_t __p0, svint32_t __p1, svint64_t __p2) {
  return svcmpne_wide_s32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpne_wide(svbool_t __p0, svint8_t __p1, svint64_t __p2) {
  return svcmpne_wide_s8( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpne_wide(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svcmpne_wide_u16( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpne_wide(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svcmpne_wide_u32( __p0,  __p1,  __p2);
}
__aio svbool_t svcmpne_wide(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svcmpne_wide_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svcmpuo(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpuo_f16,\
      svfloat16_t: __builtin_sve_svcmpuo_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpuo_f32,\
      svfloat32_t: __builtin_sve_svcmpuo_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svcmpuo_f64,\
      svfloat64_t: __builtin_sve_svcmpuo_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svcnot_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svcnot_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svcnot_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svcnot_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svcnot_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svcnot_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svcnot_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svcnot_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svcnot_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svcnot_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcnot_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svcnot_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcnot_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svcnot_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svcnot_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  return svcnot_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svcnot_x(svbool_t __p0, svint16_t __p1) {
  return svcnot_s16_x( __p0,  __p1);
}
__aio svint32_t svcnot_x(svbool_t __p0, svint32_t __p1) {
  return svcnot_s32_x( __p0,  __p1);
}
__aio svint64_t svcnot_x(svbool_t __p0, svint64_t __p1) {
  return svcnot_s64_x( __p0,  __p1);
}
__aio svint8_t svcnot_x(svbool_t __p0, svint8_t __p1) {
  return svcnot_s8_x( __p0,  __p1);
}
__aio svuint16_t svcnot_x(svbool_t __p0, svuint16_t __p1) {
  return svcnot_u16_x( __p0,  __p1);
}
__aio svuint32_t svcnot_x(svbool_t __p0, svuint32_t __p1) {
  return svcnot_u32_x( __p0,  __p1);
}
__aio svuint64_t svcnot_x(svbool_t __p0, svuint64_t __p1) {
  return svcnot_u64_x( __p0,  __p1);
}
__aio svuint8_t svcnot_x(svbool_t __p0, svuint8_t __p1) {
  return svcnot_u8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svcnot_z(svbool_t __p0, svint16_t __p1) {
  return svcnot_s16_z( __p0,  __p1);
}
__aio svint32_t svcnot_z(svbool_t __p0, svint32_t __p1) {
  return svcnot_s32_z( __p0,  __p1);
}
__aio svint64_t svcnot_z(svbool_t __p0, svint64_t __p1) {
  return svcnot_s64_z( __p0,  __p1);
}
__aio svint8_t svcnot_z(svbool_t __p0, svint8_t __p1) {
  return svcnot_s8_z( __p0,  __p1);
}
__aio svuint16_t svcnot_z(svbool_t __p0, svuint16_t __p1) {
  return svcnot_u16_z( __p0,  __p1);
}
__aio svuint32_t svcnot_z(svbool_t __p0, svuint32_t __p1) {
  return svcnot_u32_z( __p0,  __p1);
}
__aio svuint64_t svcnot_z(svbool_t __p0, svuint64_t __p1) {
  return svcnot_u64_z( __p0,  __p1);
}
__aio svuint8_t svcnot_z(svbool_t __p0, svuint8_t __p1) {
  return svcnot_u8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcnt_m(svuint16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcnt_f16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svcnt_m(svuint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svcnt_s16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svcnt_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svcnt_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcnt_m(svuint32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcnt_f32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcnt_m(svuint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svcnt_s32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcnt_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svcnt_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcnt_m(svuint64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcnt_f64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcnt_m(svuint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svcnt_s64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcnt_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svcnt_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svcnt_m(svuint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svcnt_s8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svcnt_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  return svcnt_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcnt_x(svbool_t __p0, svfloat16_t __p1) {
  return svcnt_f16_x( __p0,  __p1);
}
__aio svuint32_t svcnt_x(svbool_t __p0, svfloat32_t __p1) {
  return svcnt_f32_x( __p0,  __p1);
}
__aio svuint64_t svcnt_x(svbool_t __p0, svfloat64_t __p1) {
  return svcnt_f64_x( __p0,  __p1);
}
__aio svuint16_t svcnt_x(svbool_t __p0, svint16_t __p1) {
  return svcnt_s16_x( __p0,  __p1);
}
__aio svuint32_t svcnt_x(svbool_t __p0, svint32_t __p1) {
  return svcnt_s32_x( __p0,  __p1);
}
__aio svuint64_t svcnt_x(svbool_t __p0, svint64_t __p1) {
  return svcnt_s64_x( __p0,  __p1);
}
__aio svuint8_t svcnt_x(svbool_t __p0, svint8_t __p1) {
  return svcnt_s8_x( __p0,  __p1);
}
__aio svuint16_t svcnt_x(svbool_t __p0, svuint16_t __p1) {
  return svcnt_u16_x( __p0,  __p1);
}
__aio svuint32_t svcnt_x(svbool_t __p0, svuint32_t __p1) {
  return svcnt_u32_x( __p0,  __p1);
}
__aio svuint64_t svcnt_x(svbool_t __p0, svuint64_t __p1) {
  return svcnt_u64_x( __p0,  __p1);
}
__aio svuint8_t svcnt_x(svbool_t __p0, svuint8_t __p1) {
  return svcnt_u8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcnt_z(svbool_t __p0, svfloat16_t __p1) {
  return svcnt_f16_z( __p0,  __p1);
}
__aio svuint32_t svcnt_z(svbool_t __p0, svfloat32_t __p1) {
  return svcnt_f32_z( __p0,  __p1);
}
__aio svuint64_t svcnt_z(svbool_t __p0, svfloat64_t __p1) {
  return svcnt_f64_z( __p0,  __p1);
}
__aio svuint16_t svcnt_z(svbool_t __p0, svint16_t __p1) {
  return svcnt_s16_z( __p0,  __p1);
}
__aio svuint32_t svcnt_z(svbool_t __p0, svint32_t __p1) {
  return svcnt_s32_z( __p0,  __p1);
}
__aio svuint64_t svcnt_z(svbool_t __p0, svint64_t __p1) {
  return svcnt_s64_z( __p0,  __p1);
}
__aio svuint8_t svcnt_z(svbool_t __p0, svint8_t __p1) {
  return svcnt_s8_z( __p0,  __p1);
}
__aio svuint16_t svcnt_z(svbool_t __p0, svuint16_t __p1) {
  return svcnt_u16_z( __p0,  __p1);
}
__aio svuint32_t svcnt_z(svbool_t __p0, svuint32_t __p1) {
  return svcnt_u32_z( __p0,  __p1);
}
__aio svuint64_t svcnt_z(svbool_t __p0, svuint64_t __p1) {
  return svcnt_u64_z( __p0,  __p1);
}
__aio svuint8_t svcnt_z(svbool_t __p0, svuint8_t __p1) {
  return svcnt_u8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svcompact(svbool_t __p0, svfloat32_t __p1) {
  return svcompact_f32( __p0,  __p1);
}
__aio svfloat64_t svcompact(svbool_t __p0, svfloat64_t __p1) {
  return svcompact_f64( __p0,  __p1);
}
__aio svint32_t svcompact(svbool_t __p0, svint32_t __p1) {
  return svcompact_s32( __p0,  __p1);
}
__aio svint64_t svcompact(svbool_t __p0, svint64_t __p1) {
  return svcompact_s64( __p0,  __p1);
}
__aio svuint32_t svcompact(svbool_t __p0, svuint32_t __p1) {
  return svcompact_u32( __p0,  __p1);
}
__aio svuint64_t svcompact(svbool_t __p0, svuint64_t __p1) {
  return svcompact_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcvt_f16_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcvt_f16_f64_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svcvt_f16_s16_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svint32_t __p2) {
  return svcvt_f16_s32_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svint64_t __p2) {
  return svcvt_f16_s64_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svcvt_f16_u16_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svcvt_f16_u32_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svcvt_f16_m(svfloat16_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svcvt_f16_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svcvt_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_f32_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svcvt_f32_m(svfloat32_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcvt_f32_f64_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svcvt_f32_m(svfloat32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svcvt_f32_s32_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svcvt_f32_m(svfloat32_t __p0, svbool_t __p1, svint64_t __p2) {
  return svcvt_f32_s64_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svcvt_f32_m(svfloat32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svcvt_f32_u32_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svcvt_f32_m(svfloat32_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svcvt_f32_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svcvt_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_f64_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svcvt_f64_m(svfloat64_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcvt_f64_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svcvt_f64_m(svfloat64_t __p0, svbool_t __p1, svint32_t __p2) {
  return svcvt_f64_s32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svcvt_f64_m(svfloat64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svcvt_f64_s64_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svcvt_f64_m(svfloat64_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svcvt_f64_u32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svcvt_f64_m(svfloat64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svcvt_f64_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_f16_f32_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_f16_f64_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svint16_t __p1) {
  return svcvt_f16_s16_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svint32_t __p1) {
  return svcvt_f16_s32_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svint64_t __p1) {
  return svcvt_f16_s64_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svuint16_t __p1) {
  return svcvt_f16_u16_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svuint32_t __p1) {
  return svcvt_f16_u32_x( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_x(svbool_t __p0, svuint64_t __p1) {
  return svcvt_f16_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svcvt_f32_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_f32_f16_x( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_x(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_f32_f64_x( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_x(svbool_t __p0, svint32_t __p1) {
  return svcvt_f32_s32_x( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_x(svbool_t __p0, svint64_t __p1) {
  return svcvt_f32_s64_x( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_x(svbool_t __p0, svuint32_t __p1) {
  return svcvt_f32_u32_x( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_x(svbool_t __p0, svuint64_t __p1) {
  return svcvt_f32_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svcvt_f64_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_f64_f16_x( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_x(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_f64_f32_x( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_x(svbool_t __p0, svint32_t __p1) {
  return svcvt_f64_s32_x( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_x(svbool_t __p0, svint64_t __p1) {
  return svcvt_f64_s64_x( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_x(svbool_t __p0, svuint32_t __p1) {
  return svcvt_f64_u32_x( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_x(svbool_t __p0, svuint64_t __p1) {
  return svcvt_f64_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_f16_f32_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_f16_f64_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svint16_t __p1) {
  return svcvt_f16_s16_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svint32_t __p1) {
  return svcvt_f16_s32_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svint64_t __p1) {
  return svcvt_f16_s64_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svuint16_t __p1) {
  return svcvt_f16_u16_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svuint32_t __p1) {
  return svcvt_f16_u32_z( __p0,  __p1);
}
__aio svfloat16_t svcvt_f16_z(svbool_t __p0, svuint64_t __p1) {
  return svcvt_f16_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svcvt_f32_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_f32_f16_z( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_z(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_f32_f64_z( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_z(svbool_t __p0, svint32_t __p1) {
  return svcvt_f32_s32_z( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_z(svbool_t __p0, svint64_t __p1) {
  return svcvt_f32_s64_z( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_z(svbool_t __p0, svuint32_t __p1) {
  return svcvt_f32_u32_z( __p0,  __p1);
}
__aio svfloat32_t svcvt_f32_z(svbool_t __p0, svuint64_t __p1) {
  return svcvt_f32_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svcvt_f64_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_f64_f16_z( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_z(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_f64_f32_z( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_z(svbool_t __p0, svint32_t __p1) {
  return svcvt_f64_s32_z( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_z(svbool_t __p0, svint64_t __p1) {
  return svcvt_f64_s64_z( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_z(svbool_t __p0, svuint32_t __p1) {
  return svcvt_f64_u32_z( __p0,  __p1);
}
__aio svfloat64_t svcvt_f64_z(svbool_t __p0, svuint64_t __p1) {
  return svcvt_f64_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svcvt_s32_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_s32_f16_x( __p0,  __p1);
}
__aio svint32_t svcvt_s32_x(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_s32_f32_x( __p0,  __p1);
}
__aio svint32_t svcvt_s32_x(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_s32_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svcvt_s64_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_s64_f16_x( __p0,  __p1);
}
__aio svint64_t svcvt_s64_x(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_s64_f32_x( __p0,  __p1);
}
__aio svint64_t svcvt_s64_x(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_s64_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svcvt_s16_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_s16_f16_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svcvt_s32_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_s32_f16_z( __p0,  __p1);
}
__aio svint32_t svcvt_s32_z(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_s32_f32_z( __p0,  __p1);
}
__aio svint32_t svcvt_s32_z(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_s32_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svcvt_s64_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_s64_f16_z( __p0,  __p1);
}
__aio svint64_t svcvt_s64_z(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_s64_f32_z( __p0,  __p1);
}
__aio svint64_t svcvt_s64_z(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_s64_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svcvt_s16_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_s16_f16_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svcvt_u32_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_u32_f16_x( __p0,  __p1);
}
__aio svuint32_t svcvt_u32_x(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_u32_f32_x( __p0,  __p1);
}
__aio svuint32_t svcvt_u32_x(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_u32_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svcvt_u64_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_u64_f16_x( __p0,  __p1);
}
__aio svuint64_t svcvt_u64_x(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_u64_f32_x( __p0,  __p1);
}
__aio svuint64_t svcvt_u64_x(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_u64_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcvt_u16_x(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_u16_f16_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svcvt_u32_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_u32_f16_z( __p0,  __p1);
}
__aio svuint32_t svcvt_u32_z(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_u32_f32_z( __p0,  __p1);
}
__aio svuint32_t svcvt_u32_z(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_u32_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svcvt_u64_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_u64_f16_z( __p0,  __p1);
}
__aio svuint64_t svcvt_u64_z(svbool_t __p0, svfloat32_t __p1) {
  return svcvt_u64_f32_z( __p0,  __p1);
}
__aio svuint64_t svcvt_u64_z(svbool_t __p0, svfloat64_t __p1) {
  return svcvt_u64_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcvt_u16_z(svbool_t __p0, svfloat16_t __p1) {
  return svcvt_u16_f16_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svcvt_s32_m(svint32_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_s32_f16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svcvt_s32_m(svint32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcvt_s32_f32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svcvt_s32_m(svint32_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcvt_s32_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svcvt_s64_m(svint64_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_s64_f16_m( __p0,  __p1,  __p2);
}
__aio svint64_t svcvt_s64_m(svint64_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcvt_s64_f32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svcvt_s64_m(svint64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcvt_s64_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svcvt_s16_m(svint16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_s16_f16_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svcvt_u32_m(svuint32_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_u32_f16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcvt_u32_m(svuint32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcvt_u32_f32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svcvt_u32_m(svuint32_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcvt_u32_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svcvt_u64_m(svuint64_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_u64_f16_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcvt_u64_m(svuint64_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svcvt_u64_f32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svcvt_u64_m(svuint64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svcvt_u64_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint16_t svcvt_u16_m(svuint16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svcvt_u16_f16_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdiv_x(__p0, __p1, __p2)  \
__extension__({ \
  svdiv_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdiv_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svdiv_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdiv_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svdiv_f16,\
      svfloat16_t: __builtin_sve_svdiv_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdiv_f32,\
      svfloat32_t: __builtin_sve_svdiv_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdiv_f64,\
      svfloat64_t: __builtin_sve_svdiv_f64),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdiv_s32,\
      svint32_t: __builtin_sve_svdiv_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdiv_s64,\
      svint64_t: __builtin_sve_svdiv_s64),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svdiv_u32,\
      default: __builtin_sve_svdiv_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svdiv_u64,\
      default: __builtin_sve_svdiv_u64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdivr_x(__p0, __p1, __p2)  \
__extension__({ \
  svdivr_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdivr_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svdivr_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdivr_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svdivr_f16,\
      svfloat16_t: __builtin_sve_svdivr_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdivr_f32,\
      svfloat32_t: __builtin_sve_svdivr_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdivr_f64,\
      svfloat64_t: __builtin_sve_svdivr_f64),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdivr_s32,\
      svint32_t: __builtin_sve_svdivr_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svdivr_s64,\
      svint64_t: __builtin_sve_svdivr_s64),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svdivr_u32,\
      default: __builtin_sve_svdivr_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svdivr_u64,\
      default: __builtin_sve_svdivr_u64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svdot(svint32_t __p0, svint8_t __p1, int8_t __p2) {
  return svdot_n_s32( __p0,  __p1,  __p2);
}
__aio svint32_t svdot(svint32_t __p0, svint8_t __p1, svint8_t __p2) {
  return svdot_s32( __p0,  __p1,  __p2);
}
__aio svint64_t svdot(svint64_t __p0, svint16_t __p1, int16_t __p2) {
  return svdot_n_s64( __p0,  __p1,  __p2);
}
__aio svint64_t svdot(svint64_t __p0, svint16_t __p1, svint16_t __p2) {
  return svdot_s64( __p0,  __p1,  __p2);
}
__aio svuint32_t svdot(svuint32_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svdot_u32( __p0,  __p1,  __p2);
}
__aio svuint32_t svdot(svuint32_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svdot_n_u32( __p0,  __p1,  __p2);
}
__aio svuint64_t svdot(svuint64_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svdot_u64( __p0,  __p1,  __p2);
}
__aio svuint64_t svdot(svuint64_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svdot_n_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svdot_lane(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svdot_lane_s32,\
  svint64_t: __builtin_sve_svdot_lane_s64,\
  svuint32_t: __builtin_sve_svdot_lane_u32,\
  svuint64_t: __builtin_sve_svdot_lane_u64)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svdup_lane(svfloat16_t __p0, uint16_t __p1) {
  return svdup_lane_f16( __p0,  __p1);
}
__aio svfloat32_t svdup_lane(svfloat32_t __p0, uint32_t __p1) {
  return svdup_lane_f32( __p0,  __p1);
}
__aio svfloat64_t svdup_lane(svfloat64_t __p0, uint64_t __p1) {
  return svdup_lane_f64( __p0,  __p1);
}
__aio svint16_t svdup_lane(svint16_t __p0, uint16_t __p1) {
  return svdup_lane_s16( __p0,  __p1);
}
__aio svint32_t svdup_lane(svint32_t __p0, uint32_t __p1) {
  return svdup_lane_s32( __p0,  __p1);
}
__aio svint64_t svdup_lane(svint64_t __p0, uint64_t __p1) {
  return svdup_lane_s64( __p0,  __p1);
}
__aio svint8_t svdup_lane(svint8_t __p0, uint8_t __p1) {
  return svdup_lane_s8( __p0,  __p1);
}
__aio svuint16_t svdup_lane(svuint16_t __p0, uint16_t __p1) {
  return svdup_lane_u16( __p0,  __p1);
}
__aio svuint32_t svdup_lane(svuint32_t __p0, uint32_t __p1) {
  return svdup_lane_u32( __p0,  __p1);
}
__aio svuint64_t svdup_lane(svuint64_t __p0, uint64_t __p1) {
  return svdup_lane_u64( __p0,  __p1);
}
__aio svuint8_t svdup_lane(svuint8_t __p0, uint8_t __p1) {
  return svdup_lane_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svdupq_lane(svfloat16_t __p0, uint64_t __p1) {
  return svdupq_lane_f16( __p0,  __p1);
}
__aio svfloat32_t svdupq_lane(svfloat32_t __p0, uint64_t __p1) {
  return svdupq_lane_f32( __p0,  __p1);
}
__aio svfloat64_t svdupq_lane(svfloat64_t __p0, uint64_t __p1) {
  return svdupq_lane_f64( __p0,  __p1);
}
__aio svint16_t svdupq_lane(svint16_t __p0, uint64_t __p1) {
  return svdupq_lane_s16( __p0,  __p1);
}
__aio svint32_t svdupq_lane(svint32_t __p0, uint64_t __p1) {
  return svdupq_lane_s32( __p0,  __p1);
}
__aio svint64_t svdupq_lane(svint64_t __p0, uint64_t __p1) {
  return svdupq_lane_s64( __p0,  __p1);
}
__aio svint8_t svdupq_lane(svint8_t __p0, uint64_t __p1) {
  return svdupq_lane_s8( __p0,  __p1);
}
__aio svuint16_t svdupq_lane(svuint16_t __p0, uint64_t __p1) {
  return svdupq_lane_u16( __p0,  __p1);
}
__aio svuint32_t svdupq_lane(svuint32_t __p0, uint64_t __p1) {
  return svdupq_lane_u32( __p0,  __p1);
}
__aio svuint64_t svdupq_lane(svuint64_t __p0, uint64_t __p1) {
  return svdupq_lane_u64( __p0,  __p1);
}
__aio svuint8_t svdupq_lane(svuint8_t __p0, uint64_t __p1) {
  return svdupq_lane_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t sveor_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return sveor_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t sveor_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return sveor_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t sveor_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return sveor_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t sveor_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return sveor_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t sveor_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return sveor_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t sveor_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return sveor_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t sveor_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return sveor_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t sveor_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return sveor_n_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t sveor_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return sveor_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t sveor_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return sveor_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t sveor_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return sveor_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t sveor_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return sveor_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t sveor_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return sveor_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t sveor_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return sveor_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t sveor_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return sveor_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t sveor_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return sveor_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t sveor_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return sveor_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t sveor_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return sveor_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t sveor_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return sveor_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t sveor_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return sveor_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t sveor_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return sveor_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t sveor_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return sveor_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t sveor_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return sveor_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t sveor_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return sveor_n_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t sveor_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return sveor_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t sveor_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return sveor_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t sveor_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return sveor_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t sveor_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return sveor_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t sveor_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return sveor_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t sveor_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return sveor_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t sveor_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return sveor_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t sveor_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return sveor_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t sveor_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return sveor_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t sveor_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return sveor_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t sveor_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return sveor_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t sveor_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return sveor_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t sveor_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return sveor_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t sveor_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return sveor_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t sveor_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return sveor_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t sveor_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return sveor_n_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t sveor_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return sveor_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t sveor_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return sveor_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t sveor_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return sveor_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t sveor_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return sveor_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t sveor_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return sveor_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t sveor_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return sveor_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t sveor_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return sveor_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t sveor_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return sveor_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t sveor_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return sveor_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int16_t sveorv(svbool_t __p0, svint16_t __p1) {
  return sveorv_s16( __p0,  __p1);
}
__aio int32_t sveorv(svbool_t __p0, svint32_t __p1) {
  return sveorv_s32( __p0,  __p1);
}
__aio int64_t sveorv(svbool_t __p0, svint64_t __p1) {
  return sveorv_s64( __p0,  __p1);
}
__aio int8_t sveorv(svbool_t __p0, svint8_t __p1) {
  return sveorv_s8( __p0,  __p1);
}
__aio uint16_t sveorv(svbool_t __p0, svuint16_t __p1) {
  return sveorv_u16( __p0,  __p1);
}
__aio uint32_t sveorv(svbool_t __p0, svuint32_t __p1) {
  return sveorv_u32( __p0,  __p1);
}
__aio uint64_t sveorv(svbool_t __p0, svuint64_t __p1) {
  return sveorv_u64( __p0,  __p1);
}
__aio uint8_t sveorv(svbool_t __p0, svuint8_t __p1) {
  return sveorv_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svexpa(svuint16_t __p0) {
  return svexpa_f16( __p0);
}
__aio svfloat32_t svexpa(svuint32_t __p0) {
  return svexpa_f32( __p0);
}
__aio svfloat64_t svexpa(svuint64_t __p0) {
  return svexpa_f64( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svext(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svext_f16,\
  svfloat32_t: __builtin_sve_svext_f32,\
  svfloat64_t: __builtin_sve_svext_f64,\
  svint16_t: __builtin_sve_svext_s16,\
  svint32_t: __builtin_sve_svext_s32,\
  svint64_t: __builtin_sve_svext_s64,\
  svint8_t: __builtin_sve_svext_s8,\
  svuint16_t: __builtin_sve_svext_u16,\
  svuint32_t: __builtin_sve_svext_u32,\
  svuint64_t: __builtin_sve_svext_u64,\
  svuint8_t: __builtin_sve_svext_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svextb_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svextb_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svextb_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svextb_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svextb_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svextb_s64_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svextb_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svextb_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svextb_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svextb_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svextb_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svextb_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svextb_x(svbool_t __p0, svint16_t __p1) {
  return svextb_s16_x( __p0,  __p1);
}
__aio svint32_t svextb_x(svbool_t __p0, svint32_t __p1) {
  return svextb_s32_x( __p0,  __p1);
}
__aio svint64_t svextb_x(svbool_t __p0, svint64_t __p1) {
  return svextb_s64_x( __p0,  __p1);
}
__aio svuint16_t svextb_x(svbool_t __p0, svuint16_t __p1) {
  return svextb_u16_x( __p0,  __p1);
}
__aio svuint32_t svextb_x(svbool_t __p0, svuint32_t __p1) {
  return svextb_u32_x( __p0,  __p1);
}
__aio svuint64_t svextb_x(svbool_t __p0, svuint64_t __p1) {
  return svextb_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svextb_z(svbool_t __p0, svint16_t __p1) {
  return svextb_s16_z( __p0,  __p1);
}
__aio svint32_t svextb_z(svbool_t __p0, svint32_t __p1) {
  return svextb_s32_z( __p0,  __p1);
}
__aio svint64_t svextb_z(svbool_t __p0, svint64_t __p1) {
  return svextb_s64_z( __p0,  __p1);
}
__aio svuint16_t svextb_z(svbool_t __p0, svuint16_t __p1) {
  return svextb_u16_z( __p0,  __p1);
}
__aio svuint32_t svextb_z(svbool_t __p0, svuint32_t __p1) {
  return svextb_u32_z( __p0,  __p1);
}
__aio svuint64_t svextb_z(svbool_t __p0, svuint64_t __p1) {
  return svextb_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svexth_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svexth_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svexth_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svexth_s64_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svexth_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svexth_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svexth_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svexth_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svexth_x(svbool_t __p0, svint32_t __p1) {
  return svexth_s32_x( __p0,  __p1);
}
__aio svint64_t svexth_x(svbool_t __p0, svint64_t __p1) {
  return svexth_s64_x( __p0,  __p1);
}
__aio svuint32_t svexth_x(svbool_t __p0, svuint32_t __p1) {
  return svexth_u32_x( __p0,  __p1);
}
__aio svuint64_t svexth_x(svbool_t __p0, svuint64_t __p1) {
  return svexth_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svexth_z(svbool_t __p0, svint32_t __p1) {
  return svexth_s32_z( __p0,  __p1);
}
__aio svint64_t svexth_z(svbool_t __p0, svint64_t __p1) {
  return svexth_s64_z( __p0,  __p1);
}
__aio svuint32_t svexth_z(svbool_t __p0, svuint32_t __p1) {
  return svexth_u32_z( __p0,  __p1);
}
__aio svuint64_t svexth_z(svbool_t __p0, svuint64_t __p1) {
  return svexth_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svextw_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svextw_s64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svextw_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svextw_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svextw_x(svbool_t __p0, svint64_t __p1) {
  return svextw_s64_x( __p0,  __p1);
}
__aio svuint64_t svextw_x(svbool_t __p0, svuint64_t __p1) {
  return svextw_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svextw_z(svbool_t __p0, svint64_t __p1) {
  return svextw_s64_z( __p0,  __p1);
}
__aio svuint64_t svextw_z(svbool_t __p0, svuint64_t __p1) {
  return svextw_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svinsr(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svinsr_n_f16,\
  svfloat32_t: __builtin_sve_svinsr_n_f32,\
  svfloat64_t: __builtin_sve_svinsr_n_f64,\
  svint16_t: __builtin_sve_svinsr_n_s16,\
  svint32_t: __builtin_sve_svinsr_n_s32,\
  svint64_t: __builtin_sve_svinsr_n_s64,\
  svint8_t: __builtin_sve_svinsr_n_s8,\
  svuint16_t: __builtin_sve_svinsr_n_u16,\
  svuint32_t: __builtin_sve_svinsr_n_u32,\
  svuint64_t: __builtin_sve_svinsr_n_u64,\
  svuint8_t: __builtin_sve_svinsr_n_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svlasta(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svlasta_f16,\
    svfloat32_t: __builtin_sve_svlasta_f32,\
    svfloat64_t: __builtin_sve_svlasta_f64,\
    svint16_t: __builtin_sve_svlasta_s16,\
    svint32_t: __builtin_sve_svlasta_s32,\
    svint64_t: __builtin_sve_svlasta_s64,\
    svint8_t: __builtin_sve_svlasta_s8,\
    svuint16_t: __builtin_sve_svlasta_u16,\
    svuint32_t: __builtin_sve_svlasta_u32,\
    svuint64_t: __builtin_sve_svlasta_u64,\
    svuint8_t: __builtin_sve_svlasta_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svlastb(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svlastb_f16,\
    svfloat32_t: __builtin_sve_svlastb_f32,\
    svfloat64_t: __builtin_sve_svlastb_f64,\
    svint16_t: __builtin_sve_svlastb_s16,\
    svint32_t: __builtin_sve_svlastb_s32,\
    svint64_t: __builtin_sve_svlastb_s64,\
    svint8_t: __builtin_sve_svlastb_s8,\
    svuint16_t: __builtin_sve_svlastb_u16,\
    svuint32_t: __builtin_sve_svlastb_u32,\
    svuint64_t: __builtin_sve_svlastb_u64,\
    svuint8_t: __builtin_sve_svlastb_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1_f16,\
    float16_t const *: __builtin_sve_svld1_f16,\
    float32_t *: __builtin_sve_svld1_f32,\
    float32_t const *: __builtin_sve_svld1_f32,\
    float64_t *: __builtin_sve_svld1_f64,\
    float64_t const *: __builtin_sve_svld1_f64,\
    int16_t *: __builtin_sve_svld1_s16,\
    int16_t const *: __builtin_sve_svld1_s16,\
    int32_t *: __builtin_sve_svld1_s32,\
    int32_t const *: __builtin_sve_svld1_s32,\
    int64_t *: __builtin_sve_svld1_s64,\
    int64_t const *: __builtin_sve_svld1_s64,\
    int8_t *: __builtin_sve_svld1_s8,\
    int8_t const *: __builtin_sve_svld1_s8,\
    uint16_t *: __builtin_sve_svld1_u16,\
    uint16_t const *: __builtin_sve_svld1_u16,\
    uint32_t *: __builtin_sve_svld1_u32,\
    uint32_t const *: __builtin_sve_svld1_u32,\
    uint64_t *: __builtin_sve_svld1_u64,\
    uint64_t const *: __builtin_sve_svld1_u64,\
    uint8_t *: __builtin_sve_svld1_u8,\
    uint8_t const *: __builtin_sve_svld1_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1_gather_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svld1_gather_u32base_index_u32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1_gather_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svld1_gather_u64base_index_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svld1_gather_index_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svld1_gather_u64base_index_f64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svld1_gather_index_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svld1_gather_u32base_index_f32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1_gather_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svld1_gather_u32base_index_s32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1_gather_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svld1_gather_u64base_index_s64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1_gather_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svld1_gather_u32base_offset_u32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1_gather_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svld1_gather_u64base_offset_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svld1_gather_offset_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svld1_gather_u64base_offset_f64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svld1_gather_offset_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svld1_gather_u32base_offset_f32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1_gather_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svld1_gather_u32base_offset_s32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1_gather_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svld1_gather_u64base_offset_s64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svld1_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svld1_gather_f64(svbool_t __p0, svuint64_t __p1) {
  return svld1_gather_u64base_f64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svld1_gather_f32(svbool_t __p0, svuint32_t __p1) {
  return svld1_gather_u32base_f32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svld1_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_index(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32index_f32,\
      svuint32_t: __builtin_sve_svld1_gather_u32index_f32),\
    float32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32index_f32,\
      svuint32_t: __builtin_sve_svld1_gather_u32index_f32),\
    float64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64index_f64,\
      svuint64_t: __builtin_sve_svld1_gather_u64index_f64),\
    float64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64index_f64,\
      svuint64_t: __builtin_sve_svld1_gather_u64index_f64),\
    int32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svld1_gather_u32index_s32),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svld1_gather_u32index_s32),\
    int64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1_gather_u64index_s64),\
    int64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1_gather_u64index_s64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svld1_gather_u32index_u32),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svld1_gather_u32index_u32),\
    uint64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1_gather_u64index_u64),\
    uint64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1_gather_u64index_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_gather_offset(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32offset_f32,\
      svuint32_t: __builtin_sve_svld1_gather_u32offset_f32),\
    float32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32offset_f32,\
      svuint32_t: __builtin_sve_svld1_gather_u32offset_f32),\
    float64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64offset_f64,\
      svuint64_t: __builtin_sve_svld1_gather_u64offset_f64),\
    float64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64offset_f64,\
      svuint64_t: __builtin_sve_svld1_gather_u64offset_f64),\
    int32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1_gather_u32offset_s32),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1_gather_u32offset_s32),\
    int64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1_gather_u64offset_s64),\
    int64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1_gather_u64offset_s64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1_gather_u32offset_u32),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1_gather_u32offset_u32),\
    uint64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1_gather_u64offset_u64),\
    uint64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1_vnum(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1_vnum_f16,\
    float16_t const *: __builtin_sve_svld1_vnum_f16,\
    float32_t *: __builtin_sve_svld1_vnum_f32,\
    float32_t const *: __builtin_sve_svld1_vnum_f32,\
    float64_t *: __builtin_sve_svld1_vnum_f64,\
    float64_t const *: __builtin_sve_svld1_vnum_f64,\
    int16_t *: __builtin_sve_svld1_vnum_s16,\
    int16_t const *: __builtin_sve_svld1_vnum_s16,\
    int32_t *: __builtin_sve_svld1_vnum_s32,\
    int32_t const *: __builtin_sve_svld1_vnum_s32,\
    int64_t *: __builtin_sve_svld1_vnum_s64,\
    int64_t const *: __builtin_sve_svld1_vnum_s64,\
    int8_t *: __builtin_sve_svld1_vnum_s8,\
    int8_t const *: __builtin_sve_svld1_vnum_s8,\
    uint16_t *: __builtin_sve_svld1_vnum_u16,\
    uint16_t const *: __builtin_sve_svld1_vnum_u16,\
    uint32_t *: __builtin_sve_svld1_vnum_u32,\
    uint32_t const *: __builtin_sve_svld1_vnum_u32,\
    uint64_t *: __builtin_sve_svld1_vnum_u64,\
    uint64_t const *: __builtin_sve_svld1_vnum_u64,\
    uint8_t *: __builtin_sve_svld1_vnum_u8,\
    uint8_t const *: __builtin_sve_svld1_vnum_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1rq(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1rq_f16,\
    float16_t const *: __builtin_sve_svld1rq_f16,\
    float32_t *: __builtin_sve_svld1rq_f32,\
    float32_t const *: __builtin_sve_svld1rq_f32,\
    float64_t *: __builtin_sve_svld1rq_f64,\
    float64_t const *: __builtin_sve_svld1rq_f64,\
    int16_t *: __builtin_sve_svld1rq_s16,\
    int16_t const *: __builtin_sve_svld1rq_s16,\
    int32_t *: __builtin_sve_svld1rq_s32,\
    int32_t const *: __builtin_sve_svld1rq_s32,\
    int64_t *: __builtin_sve_svld1rq_s64,\
    int64_t const *: __builtin_sve_svld1rq_s64,\
    int8_t *: __builtin_sve_svld1rq_s8,\
    int8_t const *: __builtin_sve_svld1rq_s8,\
    uint16_t *: __builtin_sve_svld1rq_u16,\
    uint16_t const *: __builtin_sve_svld1rq_u16,\
    uint32_t *: __builtin_sve_svld1rq_u32,\
    uint32_t const *: __builtin_sve_svld1rq_u32,\
    uint64_t *: __builtin_sve_svld1rq_u64,\
    uint64_t const *: __builtin_sve_svld1rq_u64,\
    uint8_t *: __builtin_sve_svld1rq_u8,\
    uint8_t const *: __builtin_sve_svld1rq_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1sb_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svld1sb_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1sb_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1sb_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1sb_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svld1sb_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1sb_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1sb_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1sb_gather_u32offset_u32),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1sb_gather_u32offset_u32),\
    svuint32_t: __builtin_sve_svld1sb_gather_u32base_offset_u32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1sb_gather_u64offset_u64),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1sb_gather_u64offset_u64),\
    svuint64_t: __builtin_sve_svld1sb_gather_u64base_offset_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1sb_gather_u32offset_s32),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1sb_gather_u32offset_s32),\
    svuint32_t: __builtin_sve_svld1sb_gather_u32base_offset_s32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sb_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1sb_gather_u64offset_s64),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sb_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1sb_gather_u64offset_s64),\
    svuint64_t: __builtin_sve_svld1sb_gather_u64base_offset_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_index_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32index_u32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32index_u32),\
    svuint32_t: __builtin_sve_svld1sh_gather_u32base_index_u32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64index_u64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64index_u64),\
    svuint64_t: __builtin_sve_svld1sh_gather_u64base_index_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_index_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32index_s32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32index_s32),\
    svuint32_t: __builtin_sve_svld1sh_gather_u32base_index_s32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64index_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64index_s64),\
    svuint64_t: __builtin_sve_svld1sh_gather_u64base_index_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1sh_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svld1sh_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1sh_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1sh_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1sh_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svld1sh_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1sh_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1sh_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32offset_u32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32offset_u32),\
    svuint32_t: __builtin_sve_svld1sh_gather_u32base_offset_u32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64offset_u64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64offset_u64),\
    svuint64_t: __builtin_sve_svld1sh_gather_u64base_offset_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32offset_s32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1sh_gather_u32offset_s32),\
    svuint32_t: __builtin_sve_svld1sh_gather_u32base_offset_s32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sh_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64offset_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1sh_gather_u64offset_s64),\
    svuint64_t: __builtin_sve_svld1sh_gather_u64base_offset_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64index_u64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64index_u64),\
    svuint64_t: __builtin_sve_svld1sw_gather_u64base_index_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64index_s64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64index_s64),\
    svuint64_t: __builtin_sve_svld1sw_gather_u64base_index_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1sw_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1sw_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1sw_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1sw_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64offset_u64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64offset_u64),\
    svuint64_t: __builtin_sve_svld1sw_gather_u64base_offset_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1sw_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64offset_s64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1sw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1sw_gather_u64offset_s64),\
    svuint64_t: __builtin_sve_svld1sw_gather_u64base_offset_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1ub_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svld1ub_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1ub_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1ub_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1ub_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svld1ub_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1ub_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1ub_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1ub_gather_u32base_offset_u32,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1ub_gather_u32offset_u32),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1ub_gather_u32offset_u32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1ub_gather_u64base_offset_u64,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1ub_gather_u64offset_u64),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1ub_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1ub_gather_u32base_offset_s32,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1ub_gather_u32offset_s32),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1ub_gather_u32offset_s32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1ub_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1ub_gather_u64base_offset_s64,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1ub_gather_u64offset_s64),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1ub_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1ub_gather_u64offset_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_index_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u32base_index_u32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32index_u32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32index_u32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u64base_index_u64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64index_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64index_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_index_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u32base_index_s32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32index_s32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32index_s32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u64base_index_s64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64index_s64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64index_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svld1uh_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svld1uh_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1uh_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1uh_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svld1uh_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svld1uh_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1uh_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1uh_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u32base_offset_u32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32offset_u32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32offset_u32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u64base_offset_u64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64offset_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u32base_offset_s32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32offset_s32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svld1uh_gather_u32offset_s32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uh_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uh_gather_u64base_offset_s64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64offset_s64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1uh_gather_u64offset_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uw_gather_u64base_index_u64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64index_u64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64index_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uw_gather_u64base_index_s64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64index_s64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64index_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svld1uw_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svld1uw_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svld1uw_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svld1uw_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uw_gather_u64base_offset_u64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64offset_u64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld1uw_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svld1uw_gather_u64base_offset_s64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64offset_s64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svld1uw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svld1uw_gather_u64offset_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2(__p0, __p1)  \
__extension__({ \
  /* Return object depends on type */ \
  __typeof(  _Generic((__p1),\
      default: (svfloat16x2_t) {},\
      float16_t const *: (svfloat16x2_t) {},\
      float32_t *: (svfloat32x2_t) {},\
      float32_t const *: (svfloat32x2_t) {},\
      float64_t *: (svfloat64x2_t) {},\
      float64_t const *: (svfloat64x2_t) {},\
      int16_t *: (svint16x2_t) {},\
      int16_t const *: (svint16x2_t) {},\
      int32_t *: (svint32x2_t) {},\
      int32_t const *: (svint32x2_t) {},\
      int64_t *: (svint64x2_t) {},\
      int64_t const *: (svint64x2_t) {},\
      int8_t *: (svint8x2_t) {},\
      int8_t const *: (svint8x2_t) {},\
      uint16_t *: (svuint16x2_t) {},\
      uint16_t const *: (svuint16x2_t) {},\
      uint32_t *: (svuint32x2_t) {},\
      uint32_t const *: (svuint32x2_t) {},\
      uint64_t *: (svuint64x2_t) {},\
      uint64_t const *: (svuint64x2_t) {},\
      uint8_t *: (svuint8x2_t) {},\
      uint8_t const *: (svuint8x2_t) {})) __ret;\
  _Generic((__p1),\
    default: __builtin_sve_svld2_f16,\
    float16_t const *: __builtin_sve_svld2_f16,\
    float32_t *: __builtin_sve_svld2_f32,\
    float32_t const *: __builtin_sve_svld2_f32,\
    float64_t *: __builtin_sve_svld2_f64,\
    float64_t const *: __builtin_sve_svld2_f64,\
    int16_t *: __builtin_sve_svld2_s16,\
    int16_t const *: __builtin_sve_svld2_s16,\
    int32_t *: __builtin_sve_svld2_s32,\
    int32_t const *: __builtin_sve_svld2_s32,\
    int64_t *: __builtin_sve_svld2_s64,\
    int64_t const *: __builtin_sve_svld2_s64,\
    int8_t *: __builtin_sve_svld2_s8,\
    int8_t const *: __builtin_sve_svld2_s8,\
    uint16_t *: __builtin_sve_svld2_u16,\
    uint16_t const *: __builtin_sve_svld2_u16,\
    uint32_t *: __builtin_sve_svld2_u32,\
    uint32_t const *: __builtin_sve_svld2_u32,\
    uint64_t *: __builtin_sve_svld2_u64,\
    uint64_t const *: __builtin_sve_svld2_u64,\
    uint8_t *: __builtin_sve_svld2_u8,\
    uint8_t const *: __builtin_sve_svld2_u8)(&__ret, __p0, __p1); \
  __ret;})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld2_vnum(__p0, __p1, __p2)  \
__extension__({ \
  /* Return object depends on type */ \
  __typeof(  _Generic((__p1),\
      default: (svfloat16x2_t) {},\
      float16_t const *: (svfloat16x2_t) {},\
      float32_t *: (svfloat32x2_t) {},\
      float32_t const *: (svfloat32x2_t) {},\
      float64_t *: (svfloat64x2_t) {},\
      float64_t const *: (svfloat64x2_t) {},\
      int16_t *: (svint16x2_t) {},\
      int16_t const *: (svint16x2_t) {},\
      int32_t *: (svint32x2_t) {},\
      int32_t const *: (svint32x2_t) {},\
      int64_t *: (svint64x2_t) {},\
      int64_t const *: (svint64x2_t) {},\
      int8_t *: (svint8x2_t) {},\
      int8_t const *: (svint8x2_t) {},\
      uint16_t *: (svuint16x2_t) {},\
      uint16_t const *: (svuint16x2_t) {},\
      uint32_t *: (svuint32x2_t) {},\
      uint32_t const *: (svuint32x2_t) {},\
      uint64_t *: (svuint64x2_t) {},\
      uint64_t const *: (svuint64x2_t) {},\
      uint8_t *: (svuint8x2_t) {},\
      uint8_t const *: (svuint8x2_t) {})) __ret;\
  _Generic((__p1),\
    default: __builtin_sve_svld2_vnum_f16,\
    float16_t const *: __builtin_sve_svld2_vnum_f16,\
    float32_t *: __builtin_sve_svld2_vnum_f32,\
    float32_t const *: __builtin_sve_svld2_vnum_f32,\
    float64_t *: __builtin_sve_svld2_vnum_f64,\
    float64_t const *: __builtin_sve_svld2_vnum_f64,\
    int16_t *: __builtin_sve_svld2_vnum_s16,\
    int16_t const *: __builtin_sve_svld2_vnum_s16,\
    int32_t *: __builtin_sve_svld2_vnum_s32,\
    int32_t const *: __builtin_sve_svld2_vnum_s32,\
    int64_t *: __builtin_sve_svld2_vnum_s64,\
    int64_t const *: __builtin_sve_svld2_vnum_s64,\
    int8_t *: __builtin_sve_svld2_vnum_s8,\
    int8_t const *: __builtin_sve_svld2_vnum_s8,\
    uint16_t *: __builtin_sve_svld2_vnum_u16,\
    uint16_t const *: __builtin_sve_svld2_vnum_u16,\
    uint32_t *: __builtin_sve_svld2_vnum_u32,\
    uint32_t const *: __builtin_sve_svld2_vnum_u32,\
    uint64_t *: __builtin_sve_svld2_vnum_u64,\
    uint64_t const *: __builtin_sve_svld2_vnum_u64,\
    uint8_t *: __builtin_sve_svld2_vnum_u8,\
    uint8_t const *: __builtin_sve_svld2_vnum_u8)(&__ret, __p0, __p1, __p2); \
  __ret;})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3(__p0, __p1)  \
__extension__({ \
  /* Return object depends on type */ \
  __typeof(  _Generic((__p1),\
      default: (svfloat16x3_t) {},\
      float16_t const *: (svfloat16x3_t) {},\
      float32_t *: (svfloat32x3_t) {},\
      float32_t const *: (svfloat32x3_t) {},\
      float64_t *: (svfloat64x3_t) {},\
      float64_t const *: (svfloat64x3_t) {},\
      int16_t *: (svint16x3_t) {},\
      int16_t const *: (svint16x3_t) {},\
      int32_t *: (svint32x3_t) {},\
      int32_t const *: (svint32x3_t) {},\
      int64_t *: (svint64x3_t) {},\
      int64_t const *: (svint64x3_t) {},\
      int8_t *: (svint8x3_t) {},\
      int8_t const *: (svint8x3_t) {},\
      uint16_t *: (svuint16x3_t) {},\
      uint16_t const *: (svuint16x3_t) {},\
      uint32_t *: (svuint32x3_t) {},\
      uint32_t const *: (svuint32x3_t) {},\
      uint64_t *: (svuint64x3_t) {},\
      uint64_t const *: (svuint64x3_t) {},\
      uint8_t *: (svuint8x3_t) {},\
      uint8_t const *: (svuint8x3_t) {})) __ret;\
  _Generic((__p1),\
    default: __builtin_sve_svld3_f16,\
    float16_t const *: __builtin_sve_svld3_f16,\
    float32_t *: __builtin_sve_svld3_f32,\
    float32_t const *: __builtin_sve_svld3_f32,\
    float64_t *: __builtin_sve_svld3_f64,\
    float64_t const *: __builtin_sve_svld3_f64,\
    int16_t *: __builtin_sve_svld3_s16,\
    int16_t const *: __builtin_sve_svld3_s16,\
    int32_t *: __builtin_sve_svld3_s32,\
    int32_t const *: __builtin_sve_svld3_s32,\
    int64_t *: __builtin_sve_svld3_s64,\
    int64_t const *: __builtin_sve_svld3_s64,\
    int8_t *: __builtin_sve_svld3_s8,\
    int8_t const *: __builtin_sve_svld3_s8,\
    uint16_t *: __builtin_sve_svld3_u16,\
    uint16_t const *: __builtin_sve_svld3_u16,\
    uint32_t *: __builtin_sve_svld3_u32,\
    uint32_t const *: __builtin_sve_svld3_u32,\
    uint64_t *: __builtin_sve_svld3_u64,\
    uint64_t const *: __builtin_sve_svld3_u64,\
    uint8_t *: __builtin_sve_svld3_u8,\
    uint8_t const *: __builtin_sve_svld3_u8)(&__ret, __p0, __p1); \
  __ret;})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld3_vnum(__p0, __p1, __p2)  \
__extension__({ \
  /* Return object depends on type */ \
  __typeof(  _Generic((__p1),\
      default: (svfloat16x3_t) {},\
      float16_t const *: (svfloat16x3_t) {},\
      float32_t *: (svfloat32x3_t) {},\
      float32_t const *: (svfloat32x3_t) {},\
      float64_t *: (svfloat64x3_t) {},\
      float64_t const *: (svfloat64x3_t) {},\
      int16_t *: (svint16x3_t) {},\
      int16_t const *: (svint16x3_t) {},\
      int32_t *: (svint32x3_t) {},\
      int32_t const *: (svint32x3_t) {},\
      int64_t *: (svint64x3_t) {},\
      int64_t const *: (svint64x3_t) {},\
      int8_t *: (svint8x3_t) {},\
      int8_t const *: (svint8x3_t) {},\
      uint16_t *: (svuint16x3_t) {},\
      uint16_t const *: (svuint16x3_t) {},\
      uint32_t *: (svuint32x3_t) {},\
      uint32_t const *: (svuint32x3_t) {},\
      uint64_t *: (svuint64x3_t) {},\
      uint64_t const *: (svuint64x3_t) {},\
      uint8_t *: (svuint8x3_t) {},\
      uint8_t const *: (svuint8x3_t) {})) __ret;\
  _Generic((__p1),\
    default: __builtin_sve_svld3_vnum_f16,\
    float16_t const *: __builtin_sve_svld3_vnum_f16,\
    float32_t *: __builtin_sve_svld3_vnum_f32,\
    float32_t const *: __builtin_sve_svld3_vnum_f32,\
    float64_t *: __builtin_sve_svld3_vnum_f64,\
    float64_t const *: __builtin_sve_svld3_vnum_f64,\
    int16_t *: __builtin_sve_svld3_vnum_s16,\
    int16_t const *: __builtin_sve_svld3_vnum_s16,\
    int32_t *: __builtin_sve_svld3_vnum_s32,\
    int32_t const *: __builtin_sve_svld3_vnum_s32,\
    int64_t *: __builtin_sve_svld3_vnum_s64,\
    int64_t const *: __builtin_sve_svld3_vnum_s64,\
    int8_t *: __builtin_sve_svld3_vnum_s8,\
    int8_t const *: __builtin_sve_svld3_vnum_s8,\
    uint16_t *: __builtin_sve_svld3_vnum_u16,\
    uint16_t const *: __builtin_sve_svld3_vnum_u16,\
    uint32_t *: __builtin_sve_svld3_vnum_u32,\
    uint32_t const *: __builtin_sve_svld3_vnum_u32,\
    uint64_t *: __builtin_sve_svld3_vnum_u64,\
    uint64_t const *: __builtin_sve_svld3_vnum_u64,\
    uint8_t *: __builtin_sve_svld3_vnum_u8,\
    uint8_t const *: __builtin_sve_svld3_vnum_u8)(&__ret, __p0, __p1, __p2); \
  __ret;})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4(__p0, __p1)  \
__extension__({ \
  /* Return object depends on type */ \
  __typeof(  _Generic((__p1),\
      default: (svfloat16x4_t) {},\
      float16_t const *: (svfloat16x4_t) {},\
      float32_t *: (svfloat32x4_t) {},\
      float32_t const *: (svfloat32x4_t) {},\
      float64_t *: (svfloat64x4_t) {},\
      float64_t const *: (svfloat64x4_t) {},\
      int16_t *: (svint16x4_t) {},\
      int16_t const *: (svint16x4_t) {},\
      int32_t *: (svint32x4_t) {},\
      int32_t const *: (svint32x4_t) {},\
      int64_t *: (svint64x4_t) {},\
      int64_t const *: (svint64x4_t) {},\
      int8_t *: (svint8x4_t) {},\
      int8_t const *: (svint8x4_t) {},\
      uint16_t *: (svuint16x4_t) {},\
      uint16_t const *: (svuint16x4_t) {},\
      uint32_t *: (svuint32x4_t) {},\
      uint32_t const *: (svuint32x4_t) {},\
      uint64_t *: (svuint64x4_t) {},\
      uint64_t const *: (svuint64x4_t) {},\
      uint8_t *: (svuint8x4_t) {},\
      uint8_t const *: (svuint8x4_t) {})) __ret;\
  _Generic((__p1),\
    default: __builtin_sve_svld4_f16,\
    float16_t const *: __builtin_sve_svld4_f16,\
    float32_t *: __builtin_sve_svld4_f32,\
    float32_t const *: __builtin_sve_svld4_f32,\
    float64_t *: __builtin_sve_svld4_f64,\
    float64_t const *: __builtin_sve_svld4_f64,\
    int16_t *: __builtin_sve_svld4_s16,\
    int16_t const *: __builtin_sve_svld4_s16,\
    int32_t *: __builtin_sve_svld4_s32,\
    int32_t const *: __builtin_sve_svld4_s32,\
    int64_t *: __builtin_sve_svld4_s64,\
    int64_t const *: __builtin_sve_svld4_s64,\
    int8_t *: __builtin_sve_svld4_s8,\
    int8_t const *: __builtin_sve_svld4_s8,\
    uint16_t *: __builtin_sve_svld4_u16,\
    uint16_t const *: __builtin_sve_svld4_u16,\
    uint32_t *: __builtin_sve_svld4_u32,\
    uint32_t const *: __builtin_sve_svld4_u32,\
    uint64_t *: __builtin_sve_svld4_u64,\
    uint64_t const *: __builtin_sve_svld4_u64,\
    uint8_t *: __builtin_sve_svld4_u8,\
    uint8_t const *: __builtin_sve_svld4_u8)(&__ret, __p0, __p1); \
  __ret;})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svld4_vnum(__p0, __p1, __p2)  \
__extension__({ \
  /* Return object depends on type */ \
  __typeof(  _Generic((__p1),\
      default: (svfloat16x4_t) {},\
      float16_t const *: (svfloat16x4_t) {},\
      float32_t *: (svfloat32x4_t) {},\
      float32_t const *: (svfloat32x4_t) {},\
      float64_t *: (svfloat64x4_t) {},\
      float64_t const *: (svfloat64x4_t) {},\
      int16_t *: (svint16x4_t) {},\
      int16_t const *: (svint16x4_t) {},\
      int32_t *: (svint32x4_t) {},\
      int32_t const *: (svint32x4_t) {},\
      int64_t *: (svint64x4_t) {},\
      int64_t const *: (svint64x4_t) {},\
      int8_t *: (svint8x4_t) {},\
      int8_t const *: (svint8x4_t) {},\
      uint16_t *: (svuint16x4_t) {},\
      uint16_t const *: (svuint16x4_t) {},\
      uint32_t *: (svuint32x4_t) {},\
      uint32_t const *: (svuint32x4_t) {},\
      uint64_t *: (svuint64x4_t) {},\
      uint64_t const *: (svuint64x4_t) {},\
      uint8_t *: (svuint8x4_t) {},\
      uint8_t const *: (svuint8x4_t) {})) __ret;\
  _Generic((__p1),\
    default: __builtin_sve_svld4_vnum_f16,\
    float16_t const *: __builtin_sve_svld4_vnum_f16,\
    float32_t *: __builtin_sve_svld4_vnum_f32,\
    float32_t const *: __builtin_sve_svld4_vnum_f32,\
    float64_t *: __builtin_sve_svld4_vnum_f64,\
    float64_t const *: __builtin_sve_svld4_vnum_f64,\
    int16_t *: __builtin_sve_svld4_vnum_s16,\
    int16_t const *: __builtin_sve_svld4_vnum_s16,\
    int32_t *: __builtin_sve_svld4_vnum_s32,\
    int32_t const *: __builtin_sve_svld4_vnum_s32,\
    int64_t *: __builtin_sve_svld4_vnum_s64,\
    int64_t const *: __builtin_sve_svld4_vnum_s64,\
    int8_t *: __builtin_sve_svld4_vnum_s8,\
    int8_t const *: __builtin_sve_svld4_vnum_s8,\
    uint16_t *: __builtin_sve_svld4_vnum_u16,\
    uint16_t const *: __builtin_sve_svld4_vnum_u16,\
    uint32_t *: __builtin_sve_svld4_vnum_u32,\
    uint32_t const *: __builtin_sve_svld4_vnum_u32,\
    uint64_t *: __builtin_sve_svld4_vnum_u64,\
    uint64_t const *: __builtin_sve_svld4_vnum_u64,\
    uint8_t *: __builtin_sve_svld4_vnum_u8,\
    uint8_t const *: __builtin_sve_svld4_vnum_u8)(&__ret, __p0, __p1, __p2); \
  __ret;})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1_f16,\
    float16_t const *: __builtin_sve_svldff1_f16,\
    float32_t *: __builtin_sve_svldff1_f32,\
    float32_t const *: __builtin_sve_svldff1_f32,\
    float64_t *: __builtin_sve_svldff1_f64,\
    float64_t const *: __builtin_sve_svldff1_f64,\
    int16_t *: __builtin_sve_svldff1_s16,\
    int16_t const *: __builtin_sve_svldff1_s16,\
    int32_t *: __builtin_sve_svldff1_s32,\
    int32_t const *: __builtin_sve_svldff1_s32,\
    int64_t *: __builtin_sve_svldff1_s64,\
    int64_t const *: __builtin_sve_svldff1_s64,\
    int8_t *: __builtin_sve_svldff1_s8,\
    int8_t const *: __builtin_sve_svldff1_s8,\
    uint16_t *: __builtin_sve_svldff1_u16,\
    uint16_t const *: __builtin_sve_svldff1_u16,\
    uint32_t *: __builtin_sve_svldff1_u32,\
    uint32_t const *: __builtin_sve_svldff1_u32,\
    uint64_t *: __builtin_sve_svldff1_u64,\
    uint64_t const *: __builtin_sve_svldff1_u64,\
    uint8_t *: __builtin_sve_svldff1_u8,\
    uint8_t const *: __builtin_sve_svldff1_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1_gather_index_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svldff1_gather_u32base_index_u32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1_gather_index_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svldff1_gather_u64base_index_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svldff1_gather_index_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svldff1_gather_u64base_index_f64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svldff1_gather_index_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svldff1_gather_u32base_index_f32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1_gather_index_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svldff1_gather_u32base_index_s32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1_gather_index_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svldff1_gather_u64base_index_s64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1_gather_offset_u32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svldff1_gather_u32base_offset_u32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1_gather_offset_u64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svldff1_gather_u64base_offset_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svldff1_gather_offset_f64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svldff1_gather_u64base_offset_f64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svldff1_gather_offset_f32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svldff1_gather_u32base_offset_f32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1_gather_offset_s32(svbool_t __p0, svuint32_t __p1, int64_t __p2) {
  return svldff1_gather_u32base_offset_s32( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1_gather_offset_s64(svbool_t __p0, svuint64_t __p1, int64_t __p2) {
  return svldff1_gather_u64base_offset_s64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svldff1_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat64_t svldff1_gather_f64(svbool_t __p0, svuint64_t __p1) {
  return svldff1_gather_u64base_f64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat32_t svldff1_gather_f32(svbool_t __p0, svuint32_t __p1) {
  return svldff1_gather_u32base_f32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svldff1_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_index(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32index_f32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32index_f32),\
    float32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32index_f32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32index_f32),\
    float64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64index_f64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64index_f64),\
    float64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64index_f64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64index_f64),\
    int32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32index_s32),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32index_s32),\
    int64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64index_s64),\
    int64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64index_s64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32index_u32),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32index_u32),\
    uint64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64index_u64),\
    uint64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64index_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_gather_offset(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32offset_f32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32offset_f32),\
    float32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32offset_f32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32offset_f32),\
    float64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64offset_f64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64offset_f64),\
    float64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64offset_f64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64offset_f64),\
    int32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32offset_s32),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32offset_s32),\
    int64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64offset_s64),\
    int64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64offset_s64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32offset_u32),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1_gather_u32offset_u32),\
    uint64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64offset_u64),\
    uint64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1_vnum(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1_vnum_f16,\
    float16_t const *: __builtin_sve_svldff1_vnum_f16,\
    float32_t *: __builtin_sve_svldff1_vnum_f32,\
    float32_t const *: __builtin_sve_svldff1_vnum_f32,\
    float64_t *: __builtin_sve_svldff1_vnum_f64,\
    float64_t const *: __builtin_sve_svldff1_vnum_f64,\
    int16_t *: __builtin_sve_svldff1_vnum_s16,\
    int16_t const *: __builtin_sve_svldff1_vnum_s16,\
    int32_t *: __builtin_sve_svldff1_vnum_s32,\
    int32_t const *: __builtin_sve_svldff1_vnum_s32,\
    int64_t *: __builtin_sve_svldff1_vnum_s64,\
    int64_t const *: __builtin_sve_svldff1_vnum_s64,\
    int8_t *: __builtin_sve_svldff1_vnum_s8,\
    int8_t const *: __builtin_sve_svldff1_vnum_s8,\
    uint16_t *: __builtin_sve_svldff1_vnum_u16,\
    uint16_t const *: __builtin_sve_svldff1_vnum_u16,\
    uint32_t *: __builtin_sve_svldff1_vnum_u32,\
    uint32_t const *: __builtin_sve_svldff1_vnum_u32,\
    uint64_t *: __builtin_sve_svldff1_vnum_u64,\
    uint64_t const *: __builtin_sve_svldff1_vnum_u64,\
    uint8_t *: __builtin_sve_svldff1_vnum_u8,\
    uint8_t const *: __builtin_sve_svldff1_vnum_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1sb_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svldff1sb_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1sb_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1sb_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1sb_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svldff1sb_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1sb_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1sb_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1sb_gather_u32offset_u32),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1sb_gather_u32offset_u32),\
    svuint32_t: __builtin_sve_svldff1sb_gather_u32base_offset_u32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1sb_gather_u64offset_u64),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1sb_gather_u64offset_u64),\
    svuint64_t: __builtin_sve_svldff1sb_gather_u64base_offset_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1sb_gather_u32offset_s32),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1sb_gather_u32offset_s32),\
    svuint32_t: __builtin_sve_svldff1sb_gather_u32base_offset_s32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sb_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1sb_gather_u64offset_s64),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sb_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1sb_gather_u64offset_s64),\
    svuint64_t: __builtin_sve_svldff1sb_gather_u64base_offset_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_index_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32index_u32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32index_u32),\
    svuint32_t: __builtin_sve_svldff1sh_gather_u32base_index_u32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64index_u64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64index_u64),\
    svuint64_t: __builtin_sve_svldff1sh_gather_u64base_index_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_index_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32index_s32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32index_s32),\
    svuint32_t: __builtin_sve_svldff1sh_gather_u32base_index_s32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64index_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64index_s64),\
    svuint64_t: __builtin_sve_svldff1sh_gather_u64base_index_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1sh_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svldff1sh_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1sh_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1sh_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1sh_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svldff1sh_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1sh_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1sh_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32offset_u32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32offset_u32),\
    svuint32_t: __builtin_sve_svldff1sh_gather_u32base_offset_u32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64offset_u64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64offset_u64),\
    svuint64_t: __builtin_sve_svldff1sh_gather_u64base_offset_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32offset_s32),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1sh_gather_u32offset_s32),\
    svuint32_t: __builtin_sve_svldff1sh_gather_u32base_offset_s32)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sh_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64offset_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1sh_gather_u64offset_s64),\
    svuint64_t: __builtin_sve_svldff1sh_gather_u64base_offset_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64index_u64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64index_u64),\
    svuint64_t: __builtin_sve_svldff1sw_gather_u64base_index_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64index_s64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64index_s64),\
    svuint64_t: __builtin_sve_svldff1sw_gather_u64base_index_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1sw_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1sw_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1sw_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1sw_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64offset_u64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64offset_u64),\
    svuint64_t: __builtin_sve_svldff1sw_gather_u64base_offset_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1sw_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64offset_s64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1sw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1sw_gather_u64offset_s64),\
    svuint64_t: __builtin_sve_svldff1sw_gather_u64base_offset_s64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1ub_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svldff1ub_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1ub_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1ub_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1ub_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svldff1ub_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1ub_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1ub_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1ub_gather_u32base_offset_u32,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1ub_gather_u32offset_u32),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1ub_gather_u32offset_u32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1ub_gather_u64base_offset_u64,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1ub_gather_u64offset_u64),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1ub_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1ub_gather_u32base_offset_s32,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1ub_gather_u32offset_s32),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1ub_gather_u32offset_s32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1ub_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1ub_gather_u64base_offset_s64,\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1ub_gather_u64offset_s64),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1ub_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1ub_gather_u64offset_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_index_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u32base_index_u32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32index_u32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32index_u32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32index_u32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u64base_index_u64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64index_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64index_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_index_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u32base_index_s32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32index_s32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32index_s32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32index_s32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u64base_index_s64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64index_s64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64index_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint32_t svldff1uh_gather_u32(svbool_t __p0, svuint32_t __p1) {
  return svldff1uh_gather_u32base_u32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1uh_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1uh_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svldff1uh_gather_s32(svbool_t __p0, svuint32_t __p1) {
  return svldff1uh_gather_u32base_s32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1uh_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1uh_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_offset_u32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u32base_offset_u32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32offset_u32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32offset_u32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32offset_u32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u64base_offset_u64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64offset_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_offset_s32(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u32base_offset_s32,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32offset_s32),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s32offset_s32,\
      svuint32_t: __builtin_sve_svldff1uh_gather_u32offset_s32))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uh_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uh_gather_u64base_offset_s64,\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64offset_s64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uh_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1uh_gather_u64offset_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_index_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uw_gather_u64base_index_u64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64index_u64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64index_u64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64index_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_index_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uw_gather_u64base_index_s64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64index_s64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64index_s64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64index_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svuint64_t svldff1uw_gather_u64(svbool_t __p0, svuint64_t __p1) {
  return svldff1uw_gather_u64base_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svldff1uw_gather_s64(svbool_t __p0, svuint64_t __p1) {
  return svldff1uw_gather_u64base_s64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_offset_u64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uw_gather_u64base_offset_u64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64offset_u64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64offset_u64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64offset_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldff1uw_gather_offset_s64(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldff1uw_gather_u64base_offset_s64,\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64offset_s64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svldff1uw_gather_s64offset_s64,\
      svuint64_t: __builtin_sve_svldff1uw_gather_u64offset_s64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldnf1_f16,\
    float16_t const *: __builtin_sve_svldnf1_f16,\
    float32_t *: __builtin_sve_svldnf1_f32,\
    float32_t const *: __builtin_sve_svldnf1_f32,\
    float64_t *: __builtin_sve_svldnf1_f64,\
    float64_t const *: __builtin_sve_svldnf1_f64,\
    int16_t *: __builtin_sve_svldnf1_s16,\
    int16_t const *: __builtin_sve_svldnf1_s16,\
    int32_t *: __builtin_sve_svldnf1_s32,\
    int32_t const *: __builtin_sve_svldnf1_s32,\
    int64_t *: __builtin_sve_svldnf1_s64,\
    int64_t const *: __builtin_sve_svldnf1_s64,\
    int8_t *: __builtin_sve_svldnf1_s8,\
    int8_t const *: __builtin_sve_svldnf1_s8,\
    uint16_t *: __builtin_sve_svldnf1_u16,\
    uint16_t const *: __builtin_sve_svldnf1_u16,\
    uint32_t *: __builtin_sve_svldnf1_u32,\
    uint32_t const *: __builtin_sve_svldnf1_u32,\
    uint64_t *: __builtin_sve_svldnf1_u64,\
    uint64_t const *: __builtin_sve_svldnf1_u64,\
    uint8_t *: __builtin_sve_svldnf1_u8,\
    uint8_t const *: __builtin_sve_svldnf1_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnf1_vnum(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldnf1_vnum_f16,\
    float16_t const *: __builtin_sve_svldnf1_vnum_f16,\
    float32_t *: __builtin_sve_svldnf1_vnum_f32,\
    float32_t const *: __builtin_sve_svldnf1_vnum_f32,\
    float64_t *: __builtin_sve_svldnf1_vnum_f64,\
    float64_t const *: __builtin_sve_svldnf1_vnum_f64,\
    int16_t *: __builtin_sve_svldnf1_vnum_s16,\
    int16_t const *: __builtin_sve_svldnf1_vnum_s16,\
    int32_t *: __builtin_sve_svldnf1_vnum_s32,\
    int32_t const *: __builtin_sve_svldnf1_vnum_s32,\
    int64_t *: __builtin_sve_svldnf1_vnum_s64,\
    int64_t const *: __builtin_sve_svldnf1_vnum_s64,\
    int8_t *: __builtin_sve_svldnf1_vnum_s8,\
    int8_t const *: __builtin_sve_svldnf1_vnum_s8,\
    uint16_t *: __builtin_sve_svldnf1_vnum_u16,\
    uint16_t const *: __builtin_sve_svldnf1_vnum_u16,\
    uint32_t *: __builtin_sve_svldnf1_vnum_u32,\
    uint32_t const *: __builtin_sve_svldnf1_vnum_u32,\
    uint64_t *: __builtin_sve_svldnf1_vnum_u64,\
    uint64_t const *: __builtin_sve_svldnf1_vnum_u64,\
    uint8_t *: __builtin_sve_svldnf1_vnum_u8,\
    uint8_t const *: __builtin_sve_svldnf1_vnum_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldnt1_f16,\
    float16_t const *: __builtin_sve_svldnt1_f16,\
    float32_t *: __builtin_sve_svldnt1_f32,\
    float32_t const *: __builtin_sve_svldnt1_f32,\
    float64_t *: __builtin_sve_svldnt1_f64,\
    float64_t const *: __builtin_sve_svldnt1_f64,\
    int16_t *: __builtin_sve_svldnt1_s16,\
    int16_t const *: __builtin_sve_svldnt1_s16,\
    int32_t *: __builtin_sve_svldnt1_s32,\
    int32_t const *: __builtin_sve_svldnt1_s32,\
    int64_t *: __builtin_sve_svldnt1_s64,\
    int64_t const *: __builtin_sve_svldnt1_s64,\
    int8_t *: __builtin_sve_svldnt1_s8,\
    int8_t const *: __builtin_sve_svldnt1_s8,\
    uint16_t *: __builtin_sve_svldnt1_u16,\
    uint16_t const *: __builtin_sve_svldnt1_u16,\
    uint32_t *: __builtin_sve_svldnt1_u32,\
    uint32_t const *: __builtin_sve_svldnt1_u32,\
    uint64_t *: __builtin_sve_svldnt1_u64,\
    uint64_t const *: __builtin_sve_svldnt1_u64,\
    uint8_t *: __builtin_sve_svldnt1_u8,\
    uint8_t const *: __builtin_sve_svldnt1_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svldnt1_vnum(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svldnt1_vnum_f16,\
    float16_t const *: __builtin_sve_svldnt1_vnum_f16,\
    float32_t *: __builtin_sve_svldnt1_vnum_f32,\
    float32_t const *: __builtin_sve_svldnt1_vnum_f32,\
    float64_t *: __builtin_sve_svldnt1_vnum_f64,\
    float64_t const *: __builtin_sve_svldnt1_vnum_f64,\
    int16_t *: __builtin_sve_svldnt1_vnum_s16,\
    int16_t const *: __builtin_sve_svldnt1_vnum_s16,\
    int32_t *: __builtin_sve_svldnt1_vnum_s32,\
    int32_t const *: __builtin_sve_svldnt1_vnum_s32,\
    int64_t *: __builtin_sve_svldnt1_vnum_s64,\
    int64_t const *: __builtin_sve_svldnt1_vnum_s64,\
    int8_t *: __builtin_sve_svldnt1_vnum_s8,\
    int8_t const *: __builtin_sve_svldnt1_vnum_s8,\
    uint16_t *: __builtin_sve_svldnt1_vnum_u16,\
    uint16_t const *: __builtin_sve_svldnt1_vnum_u16,\
    uint32_t *: __builtin_sve_svldnt1_vnum_u32,\
    uint32_t const *: __builtin_sve_svldnt1_vnum_u32,\
    uint64_t *: __builtin_sve_svldnt1_vnum_u64,\
    uint64_t const *: __builtin_sve_svldnt1_vnum_u64,\
    uint8_t *: __builtin_sve_svldnt1_vnum_u8,\
    uint8_t const *: __builtin_sve_svldnt1_vnum_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio uint64_t svlen(svfloat16_t __p0) {
  return svlen_f16( __p0);
}
__aio uint64_t svlen(svfloat32_t __p0) {
  return svlen_f32( __p0);
}
__aio uint64_t svlen(svfloat64_t __p0) {
  return svlen_f64( __p0);
}
__aio uint64_t svlen(svint16_t __p0) {
  return svlen_s16( __p0);
}
__aio uint64_t svlen(svint32_t __p0) {
  return svlen_s32( __p0);
}
__aio uint64_t svlen(svint64_t __p0) {
  return svlen_s64( __p0);
}
__aio uint64_t svlen(svint8_t __p0) {
  return svlen_s8( __p0);
}
__aio uint64_t svlen(svuint16_t __p0) {
  return svlen_u16( __p0);
}
__aio uint64_t svlen(svuint32_t __p0) {
  return svlen_u32( __p0);
}
__aio uint64_t svlen(svuint64_t __p0) {
  return svlen_u64( __p0);
}
__aio uint64_t svlen(svuint8_t __p0) {
  return svlen_u8( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsl_x(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svlsl_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svlsl_x(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svlsl_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_x(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svlsl_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_x(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svlsl_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svlsl_x(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svlsl_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svlsl_x(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svlsl_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_x(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svlsl_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_x(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svlsl_n_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svlsl_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_x(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svlsl_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svlsl_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_x(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svlsl_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsl_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svlsl_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsl_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svlsl_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svlsl_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_x(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svlsl_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsl_z(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svlsl_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svlsl_z(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svlsl_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_z(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svlsl_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_z(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svlsl_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svlsl_z(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svlsl_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svlsl_z(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svlsl_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_z(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svlsl_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_z(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svlsl_n_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svlsl_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_z(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svlsl_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svlsl_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_z(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svlsl_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsl_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svlsl_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsl_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svlsl_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svlsl_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_z(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svlsl_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsl_m(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svlsl_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svlsl_m(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svlsl_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_m(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svlsl_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_m(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svlsl_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svlsl_m(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svlsl_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svlsl_m(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svlsl_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_m(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svlsl_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_m(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svlsl_n_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svlsl_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_m(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svlsl_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svlsl_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_m(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svlsl_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsl_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svlsl_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsl_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svlsl_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svlsl_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_m(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svlsl_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsl_wide_m(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svlsl_wide_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_wide_m(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svlsl_wide_s32_m( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_wide_m(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svlsl_wide_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_wide_m(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svlsl_wide_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_wide_m(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svlsl_wide_u32_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_wide_m(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svlsl_wide_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsl_wide_x(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svlsl_wide_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_wide_x(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svlsl_wide_s32_x( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_wide_x(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svlsl_wide_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_wide_x(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svlsl_wide_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_wide_x(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svlsl_wide_u32_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_wide_x(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svlsl_wide_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsl_wide_z(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svlsl_wide_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svlsl_wide_z(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svlsl_wide_s32_z( __p0,  __p1,  __p2);
}
__aio svint8_t svlsl_wide_z(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svlsl_wide_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsl_wide_z(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svlsl_wide_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsl_wide_z(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svlsl_wide_u32_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsl_wide_z(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svlsl_wide_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsr_x(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svlsr_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svlsr_x(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svlsr_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_x(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svlsr_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_x(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svlsr_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svlsr_x(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svlsr_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svlsr_x(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svlsr_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_x(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svlsr_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_x(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svlsr_n_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svlsr_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_x(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svlsr_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svlsr_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_x(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svlsr_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsr_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svlsr_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsr_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svlsr_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svlsr_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_x(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svlsr_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsr_z(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svlsr_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svlsr_z(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svlsr_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_z(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svlsr_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_z(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svlsr_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svlsr_z(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svlsr_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svlsr_z(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svlsr_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_z(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svlsr_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_z(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svlsr_n_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svlsr_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_z(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svlsr_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svlsr_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_z(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svlsr_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsr_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svlsr_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsr_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svlsr_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svlsr_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_z(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svlsr_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsr_m(svbool_t __p0, svint16_t __p1, svuint16_t __p2) {
  return svlsr_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svlsr_m(svbool_t __p0, svint16_t __p1, uint64_t __p2) {
  return svlsr_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_m(svbool_t __p0, svint32_t __p1, svuint32_t __p2) {
  return svlsr_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_m(svbool_t __p0, svint32_t __p1, uint64_t __p2) {
  return svlsr_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svlsr_m(svbool_t __p0, svint64_t __p1, svuint64_t __p2) {
  return svlsr_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svlsr_m(svbool_t __p0, svint64_t __p1, uint64_t __p2) {
  return svlsr_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_m(svbool_t __p0, svint8_t __p1, svuint8_t __p2) {
  return svlsr_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_m(svbool_t __p0, svint8_t __p1, uint64_t __p2) {
  return svlsr_n_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svlsr_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_m(svbool_t __p0, svuint16_t __p1, uint64_t __p2) {
  return svlsr_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svlsr_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_m(svbool_t __p0, svuint32_t __p1, uint64_t __p2) {
  return svlsr_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsr_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svlsr_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svlsr_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svlsr_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svlsr_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_m(svbool_t __p0, svuint8_t __p1, uint64_t __p2) {
  return svlsr_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsr_wide_m(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svlsr_wide_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_wide_m(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svlsr_wide_s32_m( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_wide_m(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svlsr_wide_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_wide_m(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svlsr_wide_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_wide_m(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svlsr_wide_u32_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_wide_m(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svlsr_wide_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsr_wide_x(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svlsr_wide_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_wide_x(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svlsr_wide_s32_x( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_wide_x(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svlsr_wide_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_wide_x(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svlsr_wide_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_wide_x(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svlsr_wide_u32_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_wide_x(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svlsr_wide_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svlsr_wide_z(svbool_t __p0, svint16_t __p1, svuint64_t __p2) {
  return svlsr_wide_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svlsr_wide_z(svbool_t __p0, svint32_t __p1, svuint64_t __p2) {
  return svlsr_wide_s32_z( __p0,  __p1,  __p2);
}
__aio svint8_t svlsr_wide_z(svbool_t __p0, svint8_t __p1, svuint64_t __p2) {
  return svlsr_wide_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svlsr_wide_z(svbool_t __p0, svuint16_t __p1, svuint64_t __p2) {
  return svlsr_wide_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svlsr_wide_z(svbool_t __p0, svuint32_t __p1, svuint64_t __p2) {
  return svlsr_wide_u32_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svlsr_wide_z(svbool_t __p0, svuint8_t __p1, svuint64_t __p2) {
  return svlsr_wide_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmad_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svmad_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmad_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmad_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmad_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_f16,\
        svfloat16_t: __builtin_sve_svmad_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_f32,\
        svfloat32_t: __builtin_sve_svmad_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_f64,\
        svfloat64_t: __builtin_sve_svmad_f64),\
    svint16_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_s16,\
        svint16_t: __builtin_sve_svmad_s16),\
    svint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_s32,\
        svint32_t: __builtin_sve_svmad_s32),\
    svint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_s64,\
        svint64_t: __builtin_sve_svmad_s64),\
    svint8_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmad_s8,\
        svint8_t: __builtin_sve_svmad_s8),\
    svuint16_t: \
    _Generic((__p3),\
        svuint16_t: __builtin_sve_svmad_u16,\
        default: __builtin_sve_svmad_u16),\
    svuint32_t: \
    _Generic((__p3),\
        svuint32_t: __builtin_sve_svmad_u32,\
        default: __builtin_sve_svmad_u32),\
    svuint64_t: \
    _Generic((__p3),\
        svuint64_t: __builtin_sve_svmad_u64,\
        default: __builtin_sve_svmad_u64),\
    svuint8_t: \
    _Generic((__p3),\
        svuint8_t: __builtin_sve_svmad_u8,\
        default: __builtin_sve_svmad_u8))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmax_x(__p0, __p1, __p2)  \
__extension__({ \
  svmax_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmax_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmax_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmax_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_f16,\
      svfloat16_t: __builtin_sve_svmax_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_f32,\
      svfloat32_t: __builtin_sve_svmax_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_f64,\
      svfloat64_t: __builtin_sve_svmax_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_s16,\
      svint16_t: __builtin_sve_svmax_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_s32,\
      svint32_t: __builtin_sve_svmax_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_s64,\
      svint64_t: __builtin_sve_svmax_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmax_s8,\
      svint8_t: __builtin_sve_svmax_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svmax_u16,\
      default: __builtin_sve_svmax_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svmax_u32,\
      default: __builtin_sve_svmax_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svmax_u64,\
      default: __builtin_sve_svmax_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svmax_u8,\
      default: __builtin_sve_svmax_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnm_x(__p0, __p1, __p2)  \
__extension__({ \
  svmaxnm_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnm_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmaxnm_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnm_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svmaxnm_f16,\
      svfloat16_t: __builtin_sve_svmaxnm_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmaxnm_f32,\
      svfloat32_t: __builtin_sve_svmaxnm_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmaxnm_f64,\
      svfloat64_t: __builtin_sve_svmaxnm_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxnmv(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svmaxnmv_f16,\
    svfloat32_t: __builtin_sve_svmaxnmv_f32,\
    svfloat64_t: __builtin_sve_svmaxnmv_f64)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmaxv(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svmaxv_f16,\
    svfloat32_t: __builtin_sve_svmaxv_f32,\
    svfloat64_t: __builtin_sve_svmaxv_f64,\
    svint16_t: __builtin_sve_svmaxv_s16,\
    svint32_t: __builtin_sve_svmaxv_s32,\
    svint64_t: __builtin_sve_svmaxv_s64,\
    svint8_t: __builtin_sve_svmaxv_s8,\
    svuint16_t: __builtin_sve_svmaxv_u16,\
    svuint32_t: __builtin_sve_svmaxv_u32,\
    svuint64_t: __builtin_sve_svmaxv_u64,\
    svuint8_t: __builtin_sve_svmaxv_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmin_x(__p0, __p1, __p2)  \
__extension__({ \
  svmin_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmin_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmin_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmin_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_f16,\
      svfloat16_t: __builtin_sve_svmin_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_f32,\
      svfloat32_t: __builtin_sve_svmin_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_f64,\
      svfloat64_t: __builtin_sve_svmin_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_s16,\
      svint16_t: __builtin_sve_svmin_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_s32,\
      svint32_t: __builtin_sve_svmin_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_s64,\
      svint64_t: __builtin_sve_svmin_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmin_s8,\
      svint8_t: __builtin_sve_svmin_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svmin_u16,\
      default: __builtin_sve_svmin_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svmin_u32,\
      default: __builtin_sve_svmin_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svmin_u64,\
      default: __builtin_sve_svmin_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svmin_u8,\
      default: __builtin_sve_svmin_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnm_x(__p0, __p1, __p2)  \
__extension__({ \
  svminnm_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnm_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svminnm_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnm_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svminnm_f16,\
      svfloat16_t: __builtin_sve_svminnm_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svminnm_f32,\
      svfloat32_t: __builtin_sve_svminnm_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svminnm_f64,\
      svfloat64_t: __builtin_sve_svminnm_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminnmv(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svminnmv_f16,\
    svfloat32_t: __builtin_sve_svminnmv_f32,\
    svfloat64_t: __builtin_sve_svminnmv_f64)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svminv(__p0, __p1)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svminv_f16,\
    svfloat32_t: __builtin_sve_svminv_f32,\
    svfloat64_t: __builtin_sve_svminv_f64,\
    svint16_t: __builtin_sve_svminv_s16,\
    svint32_t: __builtin_sve_svminv_s32,\
    svint64_t: __builtin_sve_svminv_s64,\
    svint8_t: __builtin_sve_svminv_s8,\
    svuint16_t: __builtin_sve_svminv_u16,\
    svuint32_t: __builtin_sve_svminv_u32,\
    svuint64_t: __builtin_sve_svminv_u64,\
    svuint8_t: __builtin_sve_svminv_u8)(__p0, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svmla_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmla_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_f16,\
        svfloat16_t: __builtin_sve_svmla_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_f32,\
        svfloat32_t: __builtin_sve_svmla_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_f64,\
        svfloat64_t: __builtin_sve_svmla_f64),\
    svint16_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_s16,\
        svint16_t: __builtin_sve_svmla_s16),\
    svint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_s32,\
        svint32_t: __builtin_sve_svmla_s32),\
    svint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_s64,\
        svint64_t: __builtin_sve_svmla_s64),\
    svint8_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmla_s8,\
        svint8_t: __builtin_sve_svmla_s8),\
    svuint16_t: \
    _Generic((__p3),\
        svuint16_t: __builtin_sve_svmla_u16,\
        default: __builtin_sve_svmla_u16),\
    svuint32_t: \
    _Generic((__p3),\
        svuint32_t: __builtin_sve_svmla_u32,\
        default: __builtin_sve_svmla_u32),\
    svuint64_t: \
    _Generic((__p3),\
        svuint64_t: __builtin_sve_svmla_u64,\
        default: __builtin_sve_svmla_u64),\
    svuint8_t: \
    _Generic((__p3),\
        svuint8_t: __builtin_sve_svmla_u8,\
        default: __builtin_sve_svmla_u8))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmla_lane(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svmla_lane_f16,\
  svfloat32_t: __builtin_sve_svmla_lane_f32,\
  svfloat64_t: __builtin_sve_svmla_lane_f64)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svmls_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmls_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_f16,\
        svfloat16_t: __builtin_sve_svmls_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_f32,\
        svfloat32_t: __builtin_sve_svmls_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_f64,\
        svfloat64_t: __builtin_sve_svmls_f64),\
    svint16_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_s16,\
        svint16_t: __builtin_sve_svmls_s16),\
    svint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_s32,\
        svint32_t: __builtin_sve_svmls_s32),\
    svint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_s64,\
        svint64_t: __builtin_sve_svmls_s64),\
    svint8_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmls_s8,\
        svint8_t: __builtin_sve_svmls_s8),\
    svuint16_t: \
    _Generic((__p3),\
        svuint16_t: __builtin_sve_svmls_u16,\
        default: __builtin_sve_svmls_u16),\
    svuint32_t: \
    _Generic((__p3),\
        svuint32_t: __builtin_sve_svmls_u32,\
        default: __builtin_sve_svmls_u32),\
    svuint64_t: \
    _Generic((__p3),\
        svuint64_t: __builtin_sve_svmls_u64,\
        default: __builtin_sve_svmls_u64),\
    svuint8_t: \
    _Generic((__p3),\
        svuint8_t: __builtin_sve_svmls_u8,\
        default: __builtin_sve_svmls_u8))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmls_lane(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svmls_lane_f16,\
  svfloat32_t: __builtin_sve_svmls_lane_f32,\
  svfloat64_t: __builtin_sve_svmls_lane_f64)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmsb_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svmsb_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmsb_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmsb_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmsb_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_f16,\
        svfloat16_t: __builtin_sve_svmsb_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_f32,\
        svfloat32_t: __builtin_sve_svmsb_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_f64,\
        svfloat64_t: __builtin_sve_svmsb_f64),\
    svint16_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_s16,\
        svint16_t: __builtin_sve_svmsb_s16),\
    svint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_s32,\
        svint32_t: __builtin_sve_svmsb_s32),\
    svint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_s64,\
        svint64_t: __builtin_sve_svmsb_s64),\
    svint8_t: \
    _Generic((__p3),\
        default: __builtin_sve_svmsb_s8,\
        svint8_t: __builtin_sve_svmsb_s8),\
    svuint16_t: \
    _Generic((__p3),\
        svuint16_t: __builtin_sve_svmsb_u16,\
        default: __builtin_sve_svmsb_u16),\
    svuint32_t: \
    _Generic((__p3),\
        svuint32_t: __builtin_sve_svmsb_u32,\
        default: __builtin_sve_svmsb_u32),\
    svuint64_t: \
    _Generic((__p3),\
        svuint64_t: __builtin_sve_svmsb_u64,\
        default: __builtin_sve_svmsb_u64),\
    svuint8_t: \
    _Generic((__p3),\
        svuint8_t: __builtin_sve_svmsb_u8,\
        default: __builtin_sve_svmsb_u8))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_x(__p0, __p1, __p2)  \
__extension__({ \
  svmul_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmul_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_f16,\
      svfloat16_t: __builtin_sve_svmul_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_f32,\
      svfloat32_t: __builtin_sve_svmul_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_f64,\
      svfloat64_t: __builtin_sve_svmul_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_s16,\
      svint16_t: __builtin_sve_svmul_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_s32,\
      svint32_t: __builtin_sve_svmul_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_s64,\
      svint64_t: __builtin_sve_svmul_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmul_s8,\
      svint8_t: __builtin_sve_svmul_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svmul_u16,\
      default: __builtin_sve_svmul_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svmul_u32,\
      default: __builtin_sve_svmul_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svmul_u64,\
      default: __builtin_sve_svmul_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svmul_u8,\
      default: __builtin_sve_svmul_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmul_lane(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svmul_lane_f16,\
  svfloat32_t: __builtin_sve_svmul_lane_f32,\
  svfloat64_t: __builtin_sve_svmul_lane_f64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svmulh_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svmulh_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svmulh_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svmulh_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svmulh_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svmulh_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svmulh_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svmulh_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svmulh_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svmulh_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svmulh_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svmulh_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svmulh_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svmulh_n_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svmulh_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svmulh_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svmulh_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svmulh_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svmulh_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svmulh_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svmulh_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svmulh_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svmulh_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svmulh_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svmulh_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svmulh_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svmulh_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svmulh_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svmulh_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svmulh_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svmulh_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svmulh_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svmulh_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svmulh_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svmulh_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svmulh_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svmulh_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svmulh_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svmulh_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svmulh_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svmulh_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svmulh_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svmulh_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svmulh_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svmulh_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svmulh_n_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svmulh_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svmulh_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svmulh_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svmulh_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svmulh_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svmulh_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svmulh_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svmulh_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svmulh_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svmulh_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svmulh_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svmulh_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svmulh_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svmulh_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svmulh_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svmulh_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svmulh_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svmulh_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svmulh_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svmulh_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svmulh_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svmulh_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svmulh_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svmulh_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svmulh_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svmulh_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svmulh_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svmulh_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svmulh_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svmulh_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svmulh_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svmulh_n_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svmulh_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svmulh_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svmulh_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svmulh_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svmulh_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svmulh_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svmulh_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svmulh_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svmulh_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svmulh_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svmulh_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svmulh_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svmulh_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svmulh_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svmulh_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svmulh_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svmulh_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svmulh_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmulx_x(__p0, __p1, __p2)  \
__extension__({ \
  svmulx_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmulx_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svmulx_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svmulx_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svmulx_f16,\
      svfloat16_t: __builtin_sve_svmulx_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmulx_f32,\
      svfloat32_t: __builtin_sve_svmulx_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svmulx_f64,\
      svfloat64_t: __builtin_sve_svmulx_f64))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svnand_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svnand_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svneg_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svneg_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svneg_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svneg_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svneg_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svneg_f64_m( __p0,  __p1,  __p2);
}
__aio svint16_t svneg_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svneg_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svneg_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svneg_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svneg_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svneg_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svneg_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svneg_s8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svneg_x(svbool_t __p0, svfloat16_t __p1) {
  return svneg_f16_x( __p0,  __p1);
}
__aio svfloat32_t svneg_x(svbool_t __p0, svfloat32_t __p1) {
  return svneg_f32_x( __p0,  __p1);
}
__aio svfloat64_t svneg_x(svbool_t __p0, svfloat64_t __p1) {
  return svneg_f64_x( __p0,  __p1);
}
__aio svint16_t svneg_x(svbool_t __p0, svint16_t __p1) {
  return svneg_s16_x( __p0,  __p1);
}
__aio svint32_t svneg_x(svbool_t __p0, svint32_t __p1) {
  return svneg_s32_x( __p0,  __p1);
}
__aio svint64_t svneg_x(svbool_t __p0, svint64_t __p1) {
  return svneg_s64_x( __p0,  __p1);
}
__aio svint8_t svneg_x(svbool_t __p0, svint8_t __p1) {
  return svneg_s8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svneg_z(svbool_t __p0, svfloat16_t __p1) {
  return svneg_f16_z( __p0,  __p1);
}
__aio svfloat32_t svneg_z(svbool_t __p0, svfloat32_t __p1) {
  return svneg_f32_z( __p0,  __p1);
}
__aio svfloat64_t svneg_z(svbool_t __p0, svfloat64_t __p1) {
  return svneg_f64_z( __p0,  __p1);
}
__aio svint16_t svneg_z(svbool_t __p0, svint16_t __p1) {
  return svneg_s16_z( __p0,  __p1);
}
__aio svint32_t svneg_z(svbool_t __p0, svint32_t __p1) {
  return svneg_s32_z( __p0,  __p1);
}
__aio svint64_t svneg_z(svbool_t __p0, svint64_t __p1) {
  return svneg_s64_z( __p0,  __p1);
}
__aio svint8_t svneg_z(svbool_t __p0, svint8_t __p1) {
  return svneg_s8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmad_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svnmad_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmad_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svnmad_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmad_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svnmad_f16,\
        svfloat16_t: __builtin_sve_svnmad_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmad_f32,\
        svfloat32_t: __builtin_sve_svnmad_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmad_f64,\
        svfloat64_t: __builtin_sve_svnmad_f64))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmla_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svnmla_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmla_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svnmla_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmla_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svnmla_f16,\
        svfloat16_t: __builtin_sve_svnmla_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmla_f32,\
        svfloat32_t: __builtin_sve_svnmla_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmla_f64,\
        svfloat64_t: __builtin_sve_svnmla_f64))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmls_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svnmls_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmls_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svnmls_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmls_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svnmls_f16,\
        svfloat16_t: __builtin_sve_svnmls_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmls_f32,\
        svfloat32_t: __builtin_sve_svnmls_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmls_f64,\
        svfloat64_t: __builtin_sve_svnmls_f64))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmsb_x(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svnmsb_m(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmsb_z(__p0, __p1, __p2, __p3)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svnmsb_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svnmsb_m(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svnmsb_f16,\
        svfloat16_t: __builtin_sve_svnmsb_f16),\
    svfloat32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmsb_f32,\
        svfloat32_t: __builtin_sve_svnmsb_f32),\
    svfloat64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svnmsb_f64,\
        svfloat64_t: __builtin_sve_svnmsb_f64))(__p0, __p1, __p2, __svdup(__p1, __p3)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svnor_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svnor_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svnot_z(svbool_t __p0, svbool_t __p1) {
  return svnot_b_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svnot_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svnot_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svnot_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svnot_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svnot_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svnot_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svnot_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svnot_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svnot_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svnot_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svnot_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svnot_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svnot_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svnot_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svnot_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  return svnot_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svnot_x(svbool_t __p0, svint16_t __p1) {
  return svnot_s16_x( __p0,  __p1);
}
__aio svint32_t svnot_x(svbool_t __p0, svint32_t __p1) {
  return svnot_s32_x( __p0,  __p1);
}
__aio svint64_t svnot_x(svbool_t __p0, svint64_t __p1) {
  return svnot_s64_x( __p0,  __p1);
}
__aio svint8_t svnot_x(svbool_t __p0, svint8_t __p1) {
  return svnot_s8_x( __p0,  __p1);
}
__aio svuint16_t svnot_x(svbool_t __p0, svuint16_t __p1) {
  return svnot_u16_x( __p0,  __p1);
}
__aio svuint32_t svnot_x(svbool_t __p0, svuint32_t __p1) {
  return svnot_u32_x( __p0,  __p1);
}
__aio svuint64_t svnot_x(svbool_t __p0, svuint64_t __p1) {
  return svnot_u64_x( __p0,  __p1);
}
__aio svuint8_t svnot_x(svbool_t __p0, svuint8_t __p1) {
  return svnot_u8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svnot_z(svbool_t __p0, svint16_t __p1) {
  return svnot_s16_z( __p0,  __p1);
}
__aio svint32_t svnot_z(svbool_t __p0, svint32_t __p1) {
  return svnot_s32_z( __p0,  __p1);
}
__aio svint64_t svnot_z(svbool_t __p0, svint64_t __p1) {
  return svnot_s64_z( __p0,  __p1);
}
__aio svint8_t svnot_z(svbool_t __p0, svint8_t __p1) {
  return svnot_s8_z( __p0,  __p1);
}
__aio svuint16_t svnot_z(svbool_t __p0, svuint16_t __p1) {
  return svnot_u16_z( __p0,  __p1);
}
__aio svuint32_t svnot_z(svbool_t __p0, svuint32_t __p1) {
  return svnot_u32_z( __p0,  __p1);
}
__aio svuint64_t svnot_z(svbool_t __p0, svuint64_t __p1) {
  return svnot_u64_z( __p0,  __p1);
}
__aio svuint8_t svnot_z(svbool_t __p0, svuint8_t __p1) {
  return svnot_u8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svorn_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svorn_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svorr_z(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svorr_b_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svorr_x(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svorr_n_s16_x( __p0,  __p1,  __p2);
}
__aio svint16_t svorr_x(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svorr_s16_x( __p0,  __p1,  __p2);
}
__aio svint32_t svorr_x(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svorr_n_s32_x( __p0,  __p1,  __p2);
}
__aio svint32_t svorr_x(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svorr_s32_x( __p0,  __p1,  __p2);
}
__aio svint64_t svorr_x(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svorr_n_s64_x( __p0,  __p1,  __p2);
}
__aio svint64_t svorr_x(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svorr_s64_x( __p0,  __p1,  __p2);
}
__aio svint8_t svorr_x(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svorr_n_s8_x( __p0,  __p1,  __p2);
}
__aio svint8_t svorr_x(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svorr_s8_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svorr_x(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svorr_u16_x( __p0,  __p1,  __p2);
}
__aio svuint16_t svorr_x(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svorr_n_u16_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svorr_x(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svorr_u32_x( __p0,  __p1,  __p2);
}
__aio svuint32_t svorr_x(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svorr_n_u32_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svorr_x(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svorr_u64_x( __p0,  __p1,  __p2);
}
__aio svuint64_t svorr_x(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svorr_n_u64_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svorr_x(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svorr_u8_x( __p0,  __p1,  __p2);
}
__aio svuint8_t svorr_x(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svorr_n_u8_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svorr_z(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svorr_n_s16_z( __p0,  __p1,  __p2);
}
__aio svint16_t svorr_z(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svorr_s16_z( __p0,  __p1,  __p2);
}
__aio svint32_t svorr_z(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svorr_n_s32_z( __p0,  __p1,  __p2);
}
__aio svint32_t svorr_z(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svorr_s32_z( __p0,  __p1,  __p2);
}
__aio svint64_t svorr_z(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svorr_n_s64_z( __p0,  __p1,  __p2);
}
__aio svint64_t svorr_z(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svorr_s64_z( __p0,  __p1,  __p2);
}
__aio svint8_t svorr_z(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svorr_n_s8_z( __p0,  __p1,  __p2);
}
__aio svint8_t svorr_z(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svorr_s8_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svorr_z(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svorr_u16_z( __p0,  __p1,  __p2);
}
__aio svuint16_t svorr_z(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svorr_n_u16_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svorr_z(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svorr_u32_z( __p0,  __p1,  __p2);
}
__aio svuint32_t svorr_z(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svorr_n_u32_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svorr_z(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svorr_u64_z( __p0,  __p1,  __p2);
}
__aio svuint64_t svorr_z(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svorr_n_u64_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svorr_z(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svorr_u8_z( __p0,  __p1,  __p2);
}
__aio svuint8_t svorr_z(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svorr_n_u8_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svorr_m(svbool_t __p0, svint16_t __p1, int16_t __p2) {
  return svorr_n_s16_m( __p0,  __p1,  __p2);
}
__aio svint16_t svorr_m(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svorr_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svorr_m(svbool_t __p0, svint32_t __p1, int32_t __p2) {
  return svorr_n_s32_m( __p0,  __p1,  __p2);
}
__aio svint32_t svorr_m(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svorr_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svorr_m(svbool_t __p0, svint64_t __p1, int64_t __p2) {
  return svorr_n_s64_m( __p0,  __p1,  __p2);
}
__aio svint64_t svorr_m(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svorr_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svorr_m(svbool_t __p0, svint8_t __p1, int8_t __p2) {
  return svorr_n_s8_m( __p0,  __p1,  __p2);
}
__aio svint8_t svorr_m(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svorr_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svorr_m(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svorr_u16_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svorr_m(svbool_t __p0, svuint16_t __p1, uint16_t __p2) {
  return svorr_n_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svorr_m(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svorr_u32_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svorr_m(svbool_t __p0, svuint32_t __p1, uint32_t __p2) {
  return svorr_n_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svorr_m(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svorr_u64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svorr_m(svbool_t __p0, svuint64_t __p1, uint64_t __p2) {
  return svorr_n_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svorr_m(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svorr_u8_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svorr_m(svbool_t __p0, svuint8_t __p1, uint8_t __p2) {
  return svorr_n_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int16_t svorv(svbool_t __p0, svint16_t __p1) {
  return svorv_s16( __p0,  __p1);
}
__aio int32_t svorv(svbool_t __p0, svint32_t __p1) {
  return svorv_s32( __p0,  __p1);
}
__aio int64_t svorv(svbool_t __p0, svint64_t __p1) {
  return svorv_s64( __p0,  __p1);
}
__aio int8_t svorv(svbool_t __p0, svint8_t __p1) {
  return svorv_s8( __p0,  __p1);
}
__aio uint16_t svorv(svbool_t __p0, svuint16_t __p1) {
  return svorv_u16( __p0,  __p1);
}
__aio uint32_t svorv(svbool_t __p0, svuint32_t __p1) {
  return svorv_u32( __p0,  __p1);
}
__aio uint64_t svorv(svbool_t __p0, svuint64_t __p1) {
  return svorv_u64( __p0,  __p1);
}
__aio uint8_t svorv(svbool_t __p0, svuint8_t __p1) {
  return svorv_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__ai svbool_t svpfalse() {
  return svpfalse_b();
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svpfirst(svbool_t __p0, svbool_t __p1) {
  return svpfirst_b( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfb_gather_u32base,\
    svuint64_t: __builtin_sve_svprfb_gather_u64base)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfb_gather_offset(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfb_gather_u32base_offset,\
    svuint64_t: __builtin_sve_svprfb_gather_u64base_offset,\
    void *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfb_gather_s32offset,\
      svint64_t: __builtin_sve_svprfb_gather_s64offset,\
      svuint32_t: __builtin_sve_svprfb_gather_u32offset,\
      svuint64_t: __builtin_sve_svprfb_gather_u64offset),\
    void const *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfb_gather_s32offset,\
      svint64_t: __builtin_sve_svprfb_gather_s64offset,\
      svuint32_t: __builtin_sve_svprfb_gather_u32offset,\
      svuint64_t: __builtin_sve_svprfb_gather_u64offset))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfd_gather_u32base,\
    svuint64_t: __builtin_sve_svprfd_gather_u64base)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfd_gather_index(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfd_gather_u32base_index,\
    svuint64_t: __builtin_sve_svprfd_gather_u64base_index,\
    void *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfd_gather_s32index,\
      svint64_t: __builtin_sve_svprfd_gather_s64index,\
      svuint32_t: __builtin_sve_svprfd_gather_u32index,\
      svuint64_t: __builtin_sve_svprfd_gather_u64index),\
    void const *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfd_gather_s32index,\
      svint64_t: __builtin_sve_svprfd_gather_s64index,\
      svuint32_t: __builtin_sve_svprfd_gather_u32index,\
      svuint64_t: __builtin_sve_svprfd_gather_u64index))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfh_gather_u32base,\
    svuint64_t: __builtin_sve_svprfh_gather_u64base)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfh_gather_index(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfh_gather_u32base_index,\
    svuint64_t: __builtin_sve_svprfh_gather_u64base_index,\
    void *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfh_gather_s32index,\
      svint64_t: __builtin_sve_svprfh_gather_s64index,\
      svuint32_t: __builtin_sve_svprfh_gather_u32index,\
      svuint64_t: __builtin_sve_svprfh_gather_u64index),\
    void const *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfh_gather_s32index,\
      svint64_t: __builtin_sve_svprfh_gather_s64index,\
      svuint32_t: __builtin_sve_svprfh_gather_u32index,\
      svuint64_t: __builtin_sve_svprfh_gather_u64index))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfw_gather_u32base,\
    svuint64_t: __builtin_sve_svprfw_gather_u64base)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svprfw_gather_index(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svprfw_gather_u32base_index,\
    svuint64_t: __builtin_sve_svprfw_gather_u64base_index,\
    void *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfw_gather_s32index,\
      svint64_t: __builtin_sve_svprfw_gather_s64index,\
      svuint32_t: __builtin_sve_svprfw_gather_u32index,\
      svuint64_t: __builtin_sve_svprfw_gather_u64index),\
    void const *: \
    _Generic((__p2),\
      default: __builtin_sve_svprfw_gather_s32index,\
      svint64_t: __builtin_sve_svprfw_gather_s64index,\
      svuint32_t: __builtin_sve_svprfw_gather_u32index,\
      svuint64_t: __builtin_sve_svprfw_gather_u64index))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svqadd(svint16_t __p0, int16_t __p1) {
  return svqadd_n_s16( __p0,  __p1);
}
__aio svint16_t svqadd(svint16_t __p0, svint16_t __p1) {
  return svqadd_s16( __p0,  __p1);
}
__aio svint32_t svqadd(svint32_t __p0, int32_t __p1) {
  return svqadd_n_s32( __p0,  __p1);
}
__aio svint32_t svqadd(svint32_t __p0, svint32_t __p1) {
  return svqadd_s32( __p0,  __p1);
}
__aio svint64_t svqadd(svint64_t __p0, int64_t __p1) {
  return svqadd_n_s64( __p0,  __p1);
}
__aio svint64_t svqadd(svint64_t __p0, svint64_t __p1) {
  return svqadd_s64( __p0,  __p1);
}
__aio svint8_t svqadd(svint8_t __p0, int8_t __p1) {
  return svqadd_n_s8( __p0,  __p1);
}
__aio svint8_t svqadd(svint8_t __p0, svint8_t __p1) {
  return svqadd_s8( __p0,  __p1);
}
__aio svuint16_t svqadd(svuint16_t __p0, svuint16_t __p1) {
  return svqadd_u16( __p0,  __p1);
}
__aio svuint16_t svqadd(svuint16_t __p0, uint16_t __p1) {
  return svqadd_n_u16( __p0,  __p1);
}
__aio svuint32_t svqadd(svuint32_t __p0, svuint32_t __p1) {
  return svqadd_u32( __p0,  __p1);
}
__aio svuint32_t svqadd(svuint32_t __p0, uint32_t __p1) {
  return svqadd_n_u32( __p0,  __p1);
}
__aio svuint64_t svqadd(svuint64_t __p0, svuint64_t __p1) {
  return svqadd_u64( __p0,  __p1);
}
__aio svuint64_t svqadd(svuint64_t __p0, uint64_t __p1) {
  return svqadd_n_u64( __p0,  __p1);
}
__aio svuint8_t svqadd(svuint8_t __p0, svuint8_t __p1) {
  return svqadd_u8( __p0,  __p1);
}
__aio svuint8_t svqadd(svuint8_t __p0, uint8_t __p1) {
  return svqadd_n_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdecb_pat_n_s32,\
  int64_t: __builtin_sve_svqdecb_pat_n_s64,\
  uint32_t: __builtin_sve_svqdecb_pat_n_u32,\
  uint64_t: __builtin_sve_svqdecb_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecb_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdecb_pat_n_s32,\
  int64_t: __builtin_sve_svqdecb_pat_n_s64,\
  uint32_t: __builtin_sve_svqdecb_pat_n_u32,\
  uint64_t: __builtin_sve_svqdecb_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdecd_pat_n_s32,\
  int64_t: __builtin_sve_svqdecd_pat_n_s64,\
  svint64_t: __builtin_sve_svqdecd_pat_s64,\
  svuint64_t: __builtin_sve_svqdecd_pat_u64,\
  uint32_t: __builtin_sve_svqdecd_pat_n_u32,\
  uint64_t: __builtin_sve_svqdecd_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecd_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdecd_pat_n_s32,\
  int64_t: __builtin_sve_svqdecd_pat_n_s64,\
  svint64_t: __builtin_sve_svqdecd_pat_s64,\
  svuint64_t: __builtin_sve_svqdecd_pat_u64,\
  uint32_t: __builtin_sve_svqdecd_pat_n_u32,\
  uint64_t: __builtin_sve_svqdecd_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdech_pat_n_s32,\
  int64_t: __builtin_sve_svqdech_pat_n_s64,\
  svint16_t: __builtin_sve_svqdech_pat_s16,\
  svuint16_t: __builtin_sve_svqdech_pat_u16,\
  uint32_t: __builtin_sve_svqdech_pat_n_u32,\
  uint64_t: __builtin_sve_svqdech_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdech_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdech_pat_n_s32,\
  int64_t: __builtin_sve_svqdech_pat_n_s64,\
  svint16_t: __builtin_sve_svqdech_pat_s16,\
  svuint16_t: __builtin_sve_svqdech_pat_u16,\
  uint32_t: __builtin_sve_svqdech_pat_n_u32,\
  uint64_t: __builtin_sve_svqdech_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqdecp_b8(int32_t __p0, svbool_t __p1) {
  return svqdecp_n_s32_b8( __p0,  __p1);
}
__aio int64_t svqdecp_b8(int64_t __p0, svbool_t __p1) {
  return svqdecp_n_s64_b8( __p0,  __p1);
}
__aio uint32_t svqdecp_b8(uint32_t __p0, svbool_t __p1) {
  return svqdecp_n_u32_b8( __p0,  __p1);
}
__aio uint64_t svqdecp_b8(uint64_t __p0, svbool_t __p1) {
  return svqdecp_n_u64_b8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqdecp_b32(int32_t __p0, svbool_t __p1) {
  return svqdecp_n_s32_b32( __p0,  __p1);
}
__aio int64_t svqdecp_b32(int64_t __p0, svbool_t __p1) {
  return svqdecp_n_s64_b32( __p0,  __p1);
}
__aio uint32_t svqdecp_b32(uint32_t __p0, svbool_t __p1) {
  return svqdecp_n_u32_b32( __p0,  __p1);
}
__aio uint64_t svqdecp_b32(uint64_t __p0, svbool_t __p1) {
  return svqdecp_n_u64_b32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqdecp_b64(int32_t __p0, svbool_t __p1) {
  return svqdecp_n_s32_b64( __p0,  __p1);
}
__aio int64_t svqdecp_b64(int64_t __p0, svbool_t __p1) {
  return svqdecp_n_s64_b64( __p0,  __p1);
}
__aio uint32_t svqdecp_b64(uint32_t __p0, svbool_t __p1) {
  return svqdecp_n_u32_b64( __p0,  __p1);
}
__aio uint64_t svqdecp_b64(uint64_t __p0, svbool_t __p1) {
  return svqdecp_n_u64_b64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqdecp_b16(int32_t __p0, svbool_t __p1) {
  return svqdecp_n_s32_b16( __p0,  __p1);
}
__aio int64_t svqdecp_b16(int64_t __p0, svbool_t __p1) {
  return svqdecp_n_s64_b16( __p0,  __p1);
}
__aio uint32_t svqdecp_b16(uint32_t __p0, svbool_t __p1) {
  return svqdecp_n_u32_b16( __p0,  __p1);
}
__aio uint64_t svqdecp_b16(uint64_t __p0, svbool_t __p1) {
  return svqdecp_n_u64_b16( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svqdecp(svint16_t __p0, svbool_t __p1) {
  return svqdecp_s16( __p0,  __p1);
}
__aio svint32_t svqdecp(svint32_t __p0, svbool_t __p1) {
  return svqdecp_s32( __p0,  __p1);
}
__aio svint64_t svqdecp(svint64_t __p0, svbool_t __p1) {
  return svqdecp_s64( __p0,  __p1);
}
__aio svuint16_t svqdecp(svuint16_t __p0, svbool_t __p1) {
  return svqdecp_u16( __p0,  __p1);
}
__aio svuint32_t svqdecp(svuint32_t __p0, svbool_t __p1) {
  return svqdecp_u32( __p0,  __p1);
}
__aio svuint64_t svqdecp(svuint64_t __p0, svbool_t __p1) {
  return svqdecp_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdecw_pat_n_s32,\
  int64_t: __builtin_sve_svqdecw_pat_n_s64,\
  svint32_t: __builtin_sve_svqdecw_pat_s32,\
  svuint32_t: __builtin_sve_svqdecw_pat_u32,\
  uint32_t: __builtin_sve_svqdecw_pat_n_u32,\
  uint64_t: __builtin_sve_svqdecw_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqdecw_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqdecw_pat_n_s32,\
  int64_t: __builtin_sve_svqdecw_pat_n_s64,\
  svint32_t: __builtin_sve_svqdecw_pat_s32,\
  svuint32_t: __builtin_sve_svqdecw_pat_u32,\
  uint32_t: __builtin_sve_svqdecw_pat_n_u32,\
  uint64_t: __builtin_sve_svqdecw_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqincb_pat_n_s32,\
  int64_t: __builtin_sve_svqincb_pat_n_s64,\
  uint32_t: __builtin_sve_svqincb_pat_n_u32,\
  uint64_t: __builtin_sve_svqincb_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincb_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqincb_pat_n_s32,\
  int64_t: __builtin_sve_svqincb_pat_n_s64,\
  uint32_t: __builtin_sve_svqincb_pat_n_u32,\
  uint64_t: __builtin_sve_svqincb_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqincd_pat_n_s32,\
  int64_t: __builtin_sve_svqincd_pat_n_s64,\
  svint64_t: __builtin_sve_svqincd_pat_s64,\
  svuint64_t: __builtin_sve_svqincd_pat_u64,\
  uint32_t: __builtin_sve_svqincd_pat_n_u32,\
  uint64_t: __builtin_sve_svqincd_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincd_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqincd_pat_n_s32,\
  int64_t: __builtin_sve_svqincd_pat_n_s64,\
  svint64_t: __builtin_sve_svqincd_pat_s64,\
  svuint64_t: __builtin_sve_svqincd_pat_u64,\
  uint32_t: __builtin_sve_svqincd_pat_n_u32,\
  uint64_t: __builtin_sve_svqincd_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqinch_pat_n_s32,\
  int64_t: __builtin_sve_svqinch_pat_n_s64,\
  svint16_t: __builtin_sve_svqinch_pat_s16,\
  svuint16_t: __builtin_sve_svqinch_pat_u16,\
  uint32_t: __builtin_sve_svqinch_pat_n_u32,\
  uint64_t: __builtin_sve_svqinch_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqinch_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqinch_pat_n_s32,\
  int64_t: __builtin_sve_svqinch_pat_n_s64,\
  svint16_t: __builtin_sve_svqinch_pat_s16,\
  svuint16_t: __builtin_sve_svqinch_pat_u16,\
  uint32_t: __builtin_sve_svqinch_pat_n_u32,\
  uint64_t: __builtin_sve_svqinch_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqincp_b8(int32_t __p0, svbool_t __p1) {
  return svqincp_n_s32_b8( __p0,  __p1);
}
__aio int64_t svqincp_b8(int64_t __p0, svbool_t __p1) {
  return svqincp_n_s64_b8( __p0,  __p1);
}
__aio uint32_t svqincp_b8(uint32_t __p0, svbool_t __p1) {
  return svqincp_n_u32_b8( __p0,  __p1);
}
__aio uint64_t svqincp_b8(uint64_t __p0, svbool_t __p1) {
  return svqincp_n_u64_b8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqincp_b32(int32_t __p0, svbool_t __p1) {
  return svqincp_n_s32_b32( __p0,  __p1);
}
__aio int64_t svqincp_b32(int64_t __p0, svbool_t __p1) {
  return svqincp_n_s64_b32( __p0,  __p1);
}
__aio uint32_t svqincp_b32(uint32_t __p0, svbool_t __p1) {
  return svqincp_n_u32_b32( __p0,  __p1);
}
__aio uint64_t svqincp_b32(uint64_t __p0, svbool_t __p1) {
  return svqincp_n_u64_b32( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqincp_b64(int32_t __p0, svbool_t __p1) {
  return svqincp_n_s32_b64( __p0,  __p1);
}
__aio int64_t svqincp_b64(int64_t __p0, svbool_t __p1) {
  return svqincp_n_s64_b64( __p0,  __p1);
}
__aio uint32_t svqincp_b64(uint32_t __p0, svbool_t __p1) {
  return svqincp_n_u32_b64( __p0,  __p1);
}
__aio uint64_t svqincp_b64(uint64_t __p0, svbool_t __p1) {
  return svqincp_n_u64_b64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio int32_t svqincp_b16(int32_t __p0, svbool_t __p1) {
  return svqincp_n_s32_b16( __p0,  __p1);
}
__aio int64_t svqincp_b16(int64_t __p0, svbool_t __p1) {
  return svqincp_n_s64_b16( __p0,  __p1);
}
__aio uint32_t svqincp_b16(uint32_t __p0, svbool_t __p1) {
  return svqincp_n_u32_b16( __p0,  __p1);
}
__aio uint64_t svqincp_b16(uint64_t __p0, svbool_t __p1) {
  return svqincp_n_u64_b16( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svqincp(svint16_t __p0, svbool_t __p1) {
  return svqincp_s16( __p0,  __p1);
}
__aio svint32_t svqincp(svint32_t __p0, svbool_t __p1) {
  return svqincp_s32( __p0,  __p1);
}
__aio svint64_t svqincp(svint64_t __p0, svbool_t __p1) {
  return svqincp_s64( __p0,  __p1);
}
__aio svuint16_t svqincp(svuint16_t __p0, svbool_t __p1) {
  return svqincp_u16( __p0,  __p1);
}
__aio svuint32_t svqincp(svuint32_t __p0, svbool_t __p1) {
  return svqincp_u32( __p0,  __p1);
}
__aio svuint64_t svqincp(svuint64_t __p0, svbool_t __p1) {
  return svqincp_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw(__p0, __p1)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqincw_pat_n_s32,\
  int64_t: __builtin_sve_svqincw_pat_n_s64,\
  svint32_t: __builtin_sve_svqincw_pat_s32,\
  svuint32_t: __builtin_sve_svqincw_pat_u32,\
  uint32_t: __builtin_sve_svqincw_pat_n_u32,\
  uint64_t: __builtin_sve_svqincw_pat_n_u64)(__p0, SV_ALL, __p1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svqincw_pat(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svqincw_pat_n_s32,\
  int64_t: __builtin_sve_svqincw_pat_n_s64,\
  svint32_t: __builtin_sve_svqincw_pat_s32,\
  svuint32_t: __builtin_sve_svqincw_pat_u32,\
  uint32_t: __builtin_sve_svqincw_pat_n_u32,\
  uint64_t: __builtin_sve_svqincw_pat_n_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svqsub(svint16_t __p0, int16_t __p1) {
  return svqsub_n_s16( __p0,  __p1);
}
__aio svint16_t svqsub(svint16_t __p0, svint16_t __p1) {
  return svqsub_s16( __p0,  __p1);
}
__aio svint32_t svqsub(svint32_t __p0, int32_t __p1) {
  return svqsub_n_s32( __p0,  __p1);
}
__aio svint32_t svqsub(svint32_t __p0, svint32_t __p1) {
  return svqsub_s32( __p0,  __p1);
}
__aio svint64_t svqsub(svint64_t __p0, int64_t __p1) {
  return svqsub_n_s64( __p0,  __p1);
}
__aio svint64_t svqsub(svint64_t __p0, svint64_t __p1) {
  return svqsub_s64( __p0,  __p1);
}
__aio svint8_t svqsub(svint8_t __p0, int8_t __p1) {
  return svqsub_n_s8( __p0,  __p1);
}
__aio svint8_t svqsub(svint8_t __p0, svint8_t __p1) {
  return svqsub_s8( __p0,  __p1);
}
__aio svuint16_t svqsub(svuint16_t __p0, svuint16_t __p1) {
  return svqsub_u16( __p0,  __p1);
}
__aio svuint16_t svqsub(svuint16_t __p0, uint16_t __p1) {
  return svqsub_n_u16( __p0,  __p1);
}
__aio svuint32_t svqsub(svuint32_t __p0, svuint32_t __p1) {
  return svqsub_u32( __p0,  __p1);
}
__aio svuint32_t svqsub(svuint32_t __p0, uint32_t __p1) {
  return svqsub_n_u32( __p0,  __p1);
}
__aio svuint64_t svqsub(svuint64_t __p0, svuint64_t __p1) {
  return svqsub_u64( __p0,  __p1);
}
__aio svuint64_t svqsub(svuint64_t __p0, uint64_t __p1) {
  return svqsub_n_u64( __p0,  __p1);
}
__aio svuint8_t svqsub(svuint8_t __p0, svuint8_t __p1) {
  return svqsub_u8( __p0,  __p1);
}
__aio svuint8_t svqsub(svuint8_t __p0, uint8_t __p1) {
  return svqsub_n_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svrbit_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svrbit_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svrbit_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svrbit_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svrbit_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svrbit_s64_m( __p0,  __p1,  __p2);
}
__aio svint8_t svrbit_m(svint8_t __p0, svbool_t __p1, svint8_t __p2) {
  return svrbit_s8_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svrbit_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svrbit_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svrbit_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svrbit_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svrbit_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svrbit_u64_m( __p0,  __p1,  __p2);
}
__aio svuint8_t svrbit_m(svuint8_t __p0, svbool_t __p1, svuint8_t __p2) {
  return svrbit_u8_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svrbit_x(svbool_t __p0, svint16_t __p1) {
  return svrbit_s16_x( __p0,  __p1);
}
__aio svint32_t svrbit_x(svbool_t __p0, svint32_t __p1) {
  return svrbit_s32_x( __p0,  __p1);
}
__aio svint64_t svrbit_x(svbool_t __p0, svint64_t __p1) {
  return svrbit_s64_x( __p0,  __p1);
}
__aio svint8_t svrbit_x(svbool_t __p0, svint8_t __p1) {
  return svrbit_s8_x( __p0,  __p1);
}
__aio svuint16_t svrbit_x(svbool_t __p0, svuint16_t __p1) {
  return svrbit_u16_x( __p0,  __p1);
}
__aio svuint32_t svrbit_x(svbool_t __p0, svuint32_t __p1) {
  return svrbit_u32_x( __p0,  __p1);
}
__aio svuint64_t svrbit_x(svbool_t __p0, svuint64_t __p1) {
  return svrbit_u64_x( __p0,  __p1);
}
__aio svuint8_t svrbit_x(svbool_t __p0, svuint8_t __p1) {
  return svrbit_u8_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svrbit_z(svbool_t __p0, svint16_t __p1) {
  return svrbit_s16_z( __p0,  __p1);
}
__aio svint32_t svrbit_z(svbool_t __p0, svint32_t __p1) {
  return svrbit_s32_z( __p0,  __p1);
}
__aio svint64_t svrbit_z(svbool_t __p0, svint64_t __p1) {
  return svrbit_s64_z( __p0,  __p1);
}
__aio svint8_t svrbit_z(svbool_t __p0, svint8_t __p1) {
  return svrbit_s8_z( __p0,  __p1);
}
__aio svuint16_t svrbit_z(svbool_t __p0, svuint16_t __p1) {
  return svrbit_u16_z( __p0,  __p1);
}
__aio svuint32_t svrbit_z(svbool_t __p0, svuint32_t __p1) {
  return svrbit_u32_z( __p0,  __p1);
}
__aio svuint64_t svrbit_z(svbool_t __p0, svuint64_t __p1) {
  return svrbit_u64_z( __p0,  __p1);
}
__aio svuint8_t svrbit_z(svbool_t __p0, svuint8_t __p1) {
  return svrbit_u8_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrecpe(svfloat16_t __p0) {
  return svrecpe_f16( __p0);
}
__aio svfloat32_t svrecpe(svfloat32_t __p0) {
  return svrecpe_f32( __p0);
}
__aio svfloat64_t svrecpe(svfloat64_t __p0) {
  return svrecpe_f64( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrecps(svfloat16_t __p0, svfloat16_t __p1) {
  return svrecps_f16( __p0,  __p1);
}
__aio svfloat32_t svrecps(svfloat32_t __p0, svfloat32_t __p1) {
  return svrecps_f32( __p0,  __p1);
}
__aio svfloat64_t svrecps(svfloat64_t __p0, svfloat64_t __p1) {
  return svrecps_f64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrecpx_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrecpx_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrecpx_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrecpx_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrecpx_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrecpx_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrecpx_x(svbool_t __p0, svfloat16_t __p1) {
  return svrecpx_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrecpx_x(svbool_t __p0, svfloat32_t __p1) {
  return svrecpx_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrecpx_x(svbool_t __p0, svfloat64_t __p1) {
  return svrecpx_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrecpx_z(svbool_t __p0, svfloat16_t __p1) {
  return svrecpx_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrecpx_z(svbool_t __p0, svfloat32_t __p1) {
  return svrecpx_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrecpx_z(svbool_t __p0, svfloat64_t __p1) {
  return svrecpx_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrev(svfloat16_t __p0) {
  return svrev_f16( __p0);
}
__aio svfloat32_t svrev(svfloat32_t __p0) {
  return svrev_f32( __p0);
}
__aio svfloat64_t svrev(svfloat64_t __p0) {
  return svrev_f64( __p0);
}
__aio svint16_t svrev(svint16_t __p0) {
  return svrev_s16( __p0);
}
__aio svint32_t svrev(svint32_t __p0) {
  return svrev_s32( __p0);
}
__aio svint64_t svrev(svint64_t __p0) {
  return svrev_s64( __p0);
}
__aio svint8_t svrev(svint8_t __p0) {
  return svrev_s8( __p0);
}
__aio svuint16_t svrev(svuint16_t __p0) {
  return svrev_u16( __p0);
}
__aio svuint32_t svrev(svuint32_t __p0) {
  return svrev_u32( __p0);
}
__aio svuint64_t svrev(svuint64_t __p0) {
  return svrev_u64( __p0);
}
__aio svuint8_t svrev(svuint8_t __p0) {
  return svrev_u8( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svrevb_m(svint16_t __p0, svbool_t __p1, svint16_t __p2) {
  return svrevb_s16_m( __p0,  __p1,  __p2);
}
__aio svint32_t svrevb_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svrevb_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svrevb_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svrevb_s64_m( __p0,  __p1,  __p2);
}
__aio svuint16_t svrevb_m(svuint16_t __p0, svbool_t __p1, svuint16_t __p2) {
  return svrevb_u16_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svrevb_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svrevb_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svrevb_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svrevb_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svrevb_x(svbool_t __p0, svint16_t __p1) {
  return svrevb_s16_x( __p0,  __p1);
}
__aio svint32_t svrevb_x(svbool_t __p0, svint32_t __p1) {
  return svrevb_s32_x( __p0,  __p1);
}
__aio svint64_t svrevb_x(svbool_t __p0, svint64_t __p1) {
  return svrevb_s64_x( __p0,  __p1);
}
__aio svuint16_t svrevb_x(svbool_t __p0, svuint16_t __p1) {
  return svrevb_u16_x( __p0,  __p1);
}
__aio svuint32_t svrevb_x(svbool_t __p0, svuint32_t __p1) {
  return svrevb_u32_x( __p0,  __p1);
}
__aio svuint64_t svrevb_x(svbool_t __p0, svuint64_t __p1) {
  return svrevb_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint16_t svrevb_z(svbool_t __p0, svint16_t __p1) {
  return svrevb_s16_z( __p0,  __p1);
}
__aio svint32_t svrevb_z(svbool_t __p0, svint32_t __p1) {
  return svrevb_s32_z( __p0,  __p1);
}
__aio svint64_t svrevb_z(svbool_t __p0, svint64_t __p1) {
  return svrevb_s64_z( __p0,  __p1);
}
__aio svuint16_t svrevb_z(svbool_t __p0, svuint16_t __p1) {
  return svrevb_u16_z( __p0,  __p1);
}
__aio svuint32_t svrevb_z(svbool_t __p0, svuint32_t __p1) {
  return svrevb_u32_z( __p0,  __p1);
}
__aio svuint64_t svrevb_z(svbool_t __p0, svuint64_t __p1) {
  return svrevb_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svrevh_m(svint32_t __p0, svbool_t __p1, svint32_t __p2) {
  return svrevh_s32_m( __p0,  __p1,  __p2);
}
__aio svint64_t svrevh_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svrevh_s64_m( __p0,  __p1,  __p2);
}
__aio svuint32_t svrevh_m(svuint32_t __p0, svbool_t __p1, svuint32_t __p2) {
  return svrevh_u32_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svrevh_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svrevh_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svrevh_x(svbool_t __p0, svint32_t __p1) {
  return svrevh_s32_x( __p0,  __p1);
}
__aio svint64_t svrevh_x(svbool_t __p0, svint64_t __p1) {
  return svrevh_s64_x( __p0,  __p1);
}
__aio svuint32_t svrevh_x(svbool_t __p0, svuint32_t __p1) {
  return svrevh_u32_x( __p0,  __p1);
}
__aio svuint64_t svrevh_x(svbool_t __p0, svuint64_t __p1) {
  return svrevh_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint32_t svrevh_z(svbool_t __p0, svint32_t __p1) {
  return svrevh_s32_z( __p0,  __p1);
}
__aio svint64_t svrevh_z(svbool_t __p0, svint64_t __p1) {
  return svrevh_s64_z( __p0,  __p1);
}
__aio svuint32_t svrevh_z(svbool_t __p0, svuint32_t __p1) {
  return svrevh_u32_z( __p0,  __p1);
}
__aio svuint64_t svrevh_z(svbool_t __p0, svuint64_t __p1) {
  return svrevh_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svrevw_m(svint64_t __p0, svbool_t __p1, svint64_t __p2) {
  return svrevw_s64_m( __p0,  __p1,  __p2);
}
__aio svuint64_t svrevw_m(svuint64_t __p0, svbool_t __p1, svuint64_t __p2) {
  return svrevw_u64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svrevw_x(svbool_t __p0, svint64_t __p1) {
  return svrevw_s64_x( __p0,  __p1);
}
__aio svuint64_t svrevw_x(svbool_t __p0, svuint64_t __p1) {
  return svrevw_u64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svint64_t svrevw_z(svbool_t __p0, svint64_t __p1) {
  return svrevw_s64_z( __p0,  __p1);
}
__aio svuint64_t svrevw_z(svbool_t __p0, svuint64_t __p1) {
  return svrevw_u64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrinta_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrinta_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrinta_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrinta_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrinta_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrinta_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrinta_x(svbool_t __p0, svfloat16_t __p1) {
  return svrinta_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrinta_x(svbool_t __p0, svfloat32_t __p1) {
  return svrinta_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrinta_x(svbool_t __p0, svfloat64_t __p1) {
  return svrinta_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrinta_z(svbool_t __p0, svfloat16_t __p1) {
  return svrinta_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrinta_z(svbool_t __p0, svfloat32_t __p1) {
  return svrinta_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrinta_z(svbool_t __p0, svfloat64_t __p1) {
  return svrinta_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrinti_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrinti_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrinti_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrinti_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrinti_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrinti_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrinti_x(svbool_t __p0, svfloat16_t __p1) {
  return svrinti_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrinti_x(svbool_t __p0, svfloat32_t __p1) {
  return svrinti_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrinti_x(svbool_t __p0, svfloat64_t __p1) {
  return svrinti_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrinti_z(svbool_t __p0, svfloat16_t __p1) {
  return svrinti_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrinti_z(svbool_t __p0, svfloat32_t __p1) {
  return svrinti_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrinti_z(svbool_t __p0, svfloat64_t __p1) {
  return svrinti_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintm_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrintm_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrintm_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrintm_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrintm_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrintm_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintm_x(svbool_t __p0, svfloat16_t __p1) {
  return svrintm_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrintm_x(svbool_t __p0, svfloat32_t __p1) {
  return svrintm_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrintm_x(svbool_t __p0, svfloat64_t __p1) {
  return svrintm_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintm_z(svbool_t __p0, svfloat16_t __p1) {
  return svrintm_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrintm_z(svbool_t __p0, svfloat32_t __p1) {
  return svrintm_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrintm_z(svbool_t __p0, svfloat64_t __p1) {
  return svrintm_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintn_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrintn_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrintn_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrintn_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrintn_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrintn_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintn_x(svbool_t __p0, svfloat16_t __p1) {
  return svrintn_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrintn_x(svbool_t __p0, svfloat32_t __p1) {
  return svrintn_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrintn_x(svbool_t __p0, svfloat64_t __p1) {
  return svrintn_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintn_z(svbool_t __p0, svfloat16_t __p1) {
  return svrintn_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrintn_z(svbool_t __p0, svfloat32_t __p1) {
  return svrintn_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrintn_z(svbool_t __p0, svfloat64_t __p1) {
  return svrintn_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintp_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrintp_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrintp_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrintp_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrintp_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrintp_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintp_x(svbool_t __p0, svfloat16_t __p1) {
  return svrintp_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrintp_x(svbool_t __p0, svfloat32_t __p1) {
  return svrintp_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrintp_x(svbool_t __p0, svfloat64_t __p1) {
  return svrintp_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintp_z(svbool_t __p0, svfloat16_t __p1) {
  return svrintp_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrintp_z(svbool_t __p0, svfloat32_t __p1) {
  return svrintp_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrintp_z(svbool_t __p0, svfloat64_t __p1) {
  return svrintp_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintx_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrintx_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrintx_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrintx_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrintx_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrintx_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintx_x(svbool_t __p0, svfloat16_t __p1) {
  return svrintx_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrintx_x(svbool_t __p0, svfloat32_t __p1) {
  return svrintx_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrintx_x(svbool_t __p0, svfloat64_t __p1) {
  return svrintx_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintx_z(svbool_t __p0, svfloat16_t __p1) {
  return svrintx_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrintx_z(svbool_t __p0, svfloat32_t __p1) {
  return svrintx_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrintx_z(svbool_t __p0, svfloat64_t __p1) {
  return svrintx_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintz_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svrintz_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svrintz_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svrintz_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svrintz_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svrintz_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintz_x(svbool_t __p0, svfloat16_t __p1) {
  return svrintz_f16_x( __p0,  __p1);
}
__aio svfloat32_t svrintz_x(svbool_t __p0, svfloat32_t __p1) {
  return svrintz_f32_x( __p0,  __p1);
}
__aio svfloat64_t svrintz_x(svbool_t __p0, svfloat64_t __p1) {
  return svrintz_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrintz_z(svbool_t __p0, svfloat16_t __p1) {
  return svrintz_f16_z( __p0,  __p1);
}
__aio svfloat32_t svrintz_z(svbool_t __p0, svfloat32_t __p1) {
  return svrintz_f32_z( __p0,  __p1);
}
__aio svfloat64_t svrintz_z(svbool_t __p0, svfloat64_t __p1) {
  return svrintz_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrsqrte(svfloat16_t __p0) {
  return svrsqrte_f16( __p0);
}
__aio svfloat32_t svrsqrte(svfloat32_t __p0) {
  return svrsqrte_f32( __p0);
}
__aio svfloat64_t svrsqrte(svfloat64_t __p0) {
  return svrsqrte_f64( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svrsqrts(svfloat16_t __p0, svfloat16_t __p1) {
  return svrsqrts_f16( __p0,  __p1);
}
__aio svfloat32_t svrsqrts(svfloat32_t __p0, svfloat32_t __p1) {
  return svrsqrts_f32( __p0,  __p1);
}
__aio svfloat64_t svrsqrts(svfloat64_t __p0, svfloat64_t __p1) {
  return svrsqrts_f64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svscale_x(svbool_t __p0, svfloat16_t __p1, int16_t __p2) {
  return svscale_n_f16_x( __p0,  __p1,  __p2);
}
__aio svfloat16_t svscale_x(svbool_t __p0, svfloat16_t __p1, svint16_t __p2) {
  return svscale_f16_x( __p0,  __p1,  __p2);
}
__aio svfloat32_t svscale_x(svbool_t __p0, svfloat32_t __p1, int32_t __p2) {
  return svscale_n_f32_x( __p0,  __p1,  __p2);
}
__aio svfloat32_t svscale_x(svbool_t __p0, svfloat32_t __p1, svint32_t __p2) {
  return svscale_f32_x( __p0,  __p1,  __p2);
}
__aio svfloat64_t svscale_x(svbool_t __p0, svfloat64_t __p1, int64_t __p2) {
  return svscale_n_f64_x( __p0,  __p1,  __p2);
}
__aio svfloat64_t svscale_x(svbool_t __p0, svfloat64_t __p1, svint64_t __p2) {
  return svscale_f64_x( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svscale_z(svbool_t __p0, svfloat16_t __p1, int16_t __p2) {
  return svscale_n_f16_z( __p0,  __p1,  __p2);
}
__aio svfloat16_t svscale_z(svbool_t __p0, svfloat16_t __p1, svint16_t __p2) {
  return svscale_f16_z( __p0,  __p1,  __p2);
}
__aio svfloat32_t svscale_z(svbool_t __p0, svfloat32_t __p1, int32_t __p2) {
  return svscale_n_f32_z( __p0,  __p1,  __p2);
}
__aio svfloat32_t svscale_z(svbool_t __p0, svfloat32_t __p1, svint32_t __p2) {
  return svscale_f32_z( __p0,  __p1,  __p2);
}
__aio svfloat64_t svscale_z(svbool_t __p0, svfloat64_t __p1, int64_t __p2) {
  return svscale_n_f64_z( __p0,  __p1,  __p2);
}
__aio svfloat64_t svscale_z(svbool_t __p0, svfloat64_t __p1, svint64_t __p2) {
  return svscale_f64_z( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svscale_m(svbool_t __p0, svfloat16_t __p1, int16_t __p2) {
  return svscale_n_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat16_t svscale_m(svbool_t __p0, svfloat16_t __p1, svint16_t __p2) {
  return svscale_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svscale_m(svbool_t __p0, svfloat32_t __p1, int32_t __p2) {
  return svscale_n_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svscale_m(svbool_t __p0, svfloat32_t __p1, svint32_t __p2) {
  return svscale_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svscale_m(svbool_t __p0, svfloat64_t __p1, int64_t __p2) {
  return svscale_n_f64_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svscale_m(svbool_t __p0, svfloat64_t __p1, svint64_t __p2) {
  return svscale_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svsel(svbool_t __p0, svbool_t __p1, svbool_t __p2) {
  return svsel_b( __p0,  __p1,  __p2);
}
__aio svfloat16_t svsel(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  return svsel_f16( __p0,  __p1,  __p2);
}
__aio svfloat32_t svsel(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  return svsel_f32( __p0,  __p1,  __p2);
}
__aio svfloat64_t svsel(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  return svsel_f64( __p0,  __p1,  __p2);
}
__aio svint16_t svsel(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svsel_s16( __p0,  __p1,  __p2);
}
__aio svint32_t svsel(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svsel_s32( __p0,  __p1,  __p2);
}
__aio svint64_t svsel(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svsel_s64( __p0,  __p1,  __p2);
}
__aio svint8_t svsel(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svsel_s8( __p0,  __p1,  __p2);
}
__aio svuint16_t svsel(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svsel_u16( __p0,  __p1,  __p2);
}
__aio svuint32_t svsel(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svsel_u32( __p0,  __p1,  __p2);
}
__aio svuint64_t svsel(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svsel_u64( __p0,  __p1,  __p2);
}
__aio svuint8_t svsel(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svsel_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svsplice(svbool_t __p0, svfloat16_t __p1, svfloat16_t __p2) {
  return svsplice_f16( __p0,  __p1,  __p2);
}
__aio svfloat32_t svsplice(svbool_t __p0, svfloat32_t __p1, svfloat32_t __p2) {
  return svsplice_f32( __p0,  __p1,  __p2);
}
__aio svfloat64_t svsplice(svbool_t __p0, svfloat64_t __p1, svfloat64_t __p2) {
  return svsplice_f64( __p0,  __p1,  __p2);
}
__aio svint16_t svsplice(svbool_t __p0, svint16_t __p1, svint16_t __p2) {
  return svsplice_s16( __p0,  __p1,  __p2);
}
__aio svint32_t svsplice(svbool_t __p0, svint32_t __p1, svint32_t __p2) {
  return svsplice_s32( __p0,  __p1,  __p2);
}
__aio svint64_t svsplice(svbool_t __p0, svint64_t __p1, svint64_t __p2) {
  return svsplice_s64( __p0,  __p1,  __p2);
}
__aio svint8_t svsplice(svbool_t __p0, svint8_t __p1, svint8_t __p2) {
  return svsplice_s8( __p0,  __p1,  __p2);
}
__aio svuint16_t svsplice(svbool_t __p0, svuint16_t __p1, svuint16_t __p2) {
  return svsplice_u16( __p0,  __p1,  __p2);
}
__aio svuint32_t svsplice(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  return svsplice_u32( __p0,  __p1,  __p2);
}
__aio svuint64_t svsplice(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  return svsplice_u64( __p0,  __p1,  __p2);
}
__aio svuint8_t svsplice(svbool_t __p0, svuint8_t __p1, svuint8_t __p2) {
  return svsplice_u8( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svsqrt_m(svfloat16_t __p0, svbool_t __p1, svfloat16_t __p2) {
  return svsqrt_f16_m( __p0,  __p1,  __p2);
}
__aio svfloat32_t svsqrt_m(svfloat32_t __p0, svbool_t __p1, svfloat32_t __p2) {
  return svsqrt_f32_m( __p0,  __p1,  __p2);
}
__aio svfloat64_t svsqrt_m(svfloat64_t __p0, svbool_t __p1, svfloat64_t __p2) {
  return svsqrt_f64_m( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svsqrt_x(svbool_t __p0, svfloat16_t __p1) {
  return svsqrt_f16_x( __p0,  __p1);
}
__aio svfloat32_t svsqrt_x(svbool_t __p0, svfloat32_t __p1) {
  return svsqrt_f32_x( __p0,  __p1);
}
__aio svfloat64_t svsqrt_x(svbool_t __p0, svfloat64_t __p1) {
  return svsqrt_f64_x( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svsqrt_z(svbool_t __p0, svfloat16_t __p1) {
  return svsqrt_f16_z( __p0,  __p1);
}
__aio svfloat32_t svsqrt_z(svbool_t __p0, svfloat32_t __p1) {
  return svsqrt_f32_z( __p0,  __p1);
}
__aio svfloat64_t svsqrt_z(svbool_t __p0, svfloat64_t __p1) {
  return svsqrt_f64_z( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svst1_f16,\
    float16_t const *: __builtin_sve_svst1_f16,\
    float32_t *: __builtin_sve_svst1_f32,\
    float32_t const *: __builtin_sve_svst1_f32,\
    float64_t *: __builtin_sve_svst1_f64,\
    float64_t const *: __builtin_sve_svst1_f64,\
    int16_t *: __builtin_sve_svst1_s16,\
    int16_t const *: __builtin_sve_svst1_s16,\
    int32_t *: __builtin_sve_svst1_s32,\
    int32_t const *: __builtin_sve_svst1_s32,\
    int64_t *: __builtin_sve_svst1_s64,\
    int64_t const *: __builtin_sve_svst1_s64,\
    int8_t *: __builtin_sve_svst1_s8,\
    int8_t const *: __builtin_sve_svst1_s8,\
    uint16_t *: __builtin_sve_svst1_u16,\
    uint16_t const *: __builtin_sve_svst1_u16,\
    uint32_t *: __builtin_sve_svst1_u32,\
    uint32_t const *: __builtin_sve_svst1_u32,\
    uint64_t *: __builtin_sve_svst1_u64,\
    uint64_t const *: __builtin_sve_svst1_u64,\
    uint8_t *: __builtin_sve_svst1_u8,\
    uint8_t const *: __builtin_sve_svst1_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_index(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32index_f32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32index_f32),\
    float32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32index_f32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32index_f32),\
    float64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64index_f64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64index_f64),\
    float64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64index_f64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64index_f64),\
    int32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32index_s32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32index_s32),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32index_s32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32index_s32),\
    int64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64index_s64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64index_s64),\
    int64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64index_s64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64index_s64),\
    svuint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1_scatter_u32base_index_f32,\
        svint32_t: __builtin_sve_svst1_scatter_u32base_index_s32,\
        svuint32_t: __builtin_sve_svst1_scatter_u32base_index_u32),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1_scatter_u64base_index_f64,\
        svint64_t: __builtin_sve_svst1_scatter_u64base_index_s64,\
        svuint64_t: __builtin_sve_svst1_scatter_u64base_index_u64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32index_u32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32index_u32),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32index_u32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32index_u32),\
    uint64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64index_u64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64index_u64),\
    uint64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64index_u64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64index_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio void svst1_scatter(svbool_t __p0, svuint32_t __p1, svfloat32_t __p2) {
  svst1_scatter_u32base_f32( __p0,  __p1,  __p2);
}
__aio void svst1_scatter(svbool_t __p0, svuint32_t __p1, svint32_t __p2) {
  svst1_scatter_u32base_s32( __p0,  __p1,  __p2);
}
__aio void svst1_scatter(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svst1_scatter_u32base_u32( __p0,  __p1,  __p2);
}
__aio void svst1_scatter(svbool_t __p0, svuint64_t __p1, svfloat64_t __p2) {
  svst1_scatter_u64base_f64( __p0,  __p1,  __p2);
}
__aio void svst1_scatter(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  svst1_scatter_u64base_s64( __p0,  __p1,  __p2);
}
__aio void svst1_scatter(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svst1_scatter_u64base_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_scatter_offset(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32offset_f32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32offset_f32),\
    float32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32offset_f32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32offset_f32),\
    float64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64offset_f64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64offset_f64),\
    float64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64offset_f64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64offset_f64),\
    int32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32offset_s32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32offset_s32),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32offset_s32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32offset_s32),\
    int64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64offset_s64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64offset_s64),\
    int64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64offset_s64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64offset_s64),\
    svuint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1_scatter_u32base_offset_f32,\
        svint32_t: __builtin_sve_svst1_scatter_u32base_offset_s32,\
        svuint32_t: __builtin_sve_svst1_scatter_u32base_offset_u32),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1_scatter_u64base_offset_f64,\
        svint64_t: __builtin_sve_svst1_scatter_u64base_offset_s64,\
        svuint64_t: __builtin_sve_svst1_scatter_u64base_offset_u64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32offset_u32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32offset_u32),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s32offset_u32,\
      svuint32_t: __builtin_sve_svst1_scatter_u32offset_u32),\
    uint64_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64offset_u64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64offset_u64),\
    uint64_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1_scatter_s64offset_u64,\
      svuint64_t: __builtin_sve_svst1_scatter_u64offset_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svst1_vnum_f16,\
    float16_t const *: __builtin_sve_svst1_vnum_f16,\
    float32_t *: __builtin_sve_svst1_vnum_f32,\
    float32_t const *: __builtin_sve_svst1_vnum_f32,\
    float64_t *: __builtin_sve_svst1_vnum_f64,\
    float64_t const *: __builtin_sve_svst1_vnum_f64,\
    int16_t *: __builtin_sve_svst1_vnum_s16,\
    int16_t const *: __builtin_sve_svst1_vnum_s16,\
    int32_t *: __builtin_sve_svst1_vnum_s32,\
    int32_t const *: __builtin_sve_svst1_vnum_s32,\
    int64_t *: __builtin_sve_svst1_vnum_s64,\
    int64_t const *: __builtin_sve_svst1_vnum_s64,\
    int8_t *: __builtin_sve_svst1_vnum_s8,\
    int8_t const *: __builtin_sve_svst1_vnum_s8,\
    uint16_t *: __builtin_sve_svst1_vnum_u16,\
    uint16_t const *: __builtin_sve_svst1_vnum_u16,\
    uint32_t *: __builtin_sve_svst1_vnum_u32,\
    uint32_t const *: __builtin_sve_svst1_vnum_u32,\
    uint64_t *: __builtin_sve_svst1_vnum_u64,\
    uint64_t const *: __builtin_sve_svst1_vnum_u64,\
    uint8_t *: __builtin_sve_svst1_vnum_u8,\
    uint8_t const *: __builtin_sve_svst1_vnum_u8)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_s16,\
      svint32_t: __builtin_sve_svst1b_s32,\
      svint64_t: __builtin_sve_svst1b_s64),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_s16,\
      svint32_t: __builtin_sve_svst1b_s32,\
      svint64_t: __builtin_sve_svst1b_s64),\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_u16,\
      svuint32_t: __builtin_sve_svst1b_u32,\
      svuint64_t: __builtin_sve_svst1b_u64),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_u16,\
      svuint32_t: __builtin_sve_svst1b_u32,\
      svuint64_t: __builtin_sve_svst1b_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio void svst1b_scatter(svbool_t __p0, svuint32_t __p1, svint32_t __p2) {
  svst1b_scatter_u32base_s32( __p0,  __p1,  __p2);
}
__aio void svst1b_scatter(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svst1b_scatter_u32base_u32( __p0,  __p1,  __p2);
}
__aio void svst1b_scatter(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  svst1b_scatter_u64base_s64( __p0,  __p1,  __p2);
}
__aio void svst1b_scatter(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svst1b_scatter_u64base_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_scatter_offset(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_scatter_s32offset_s32,\
      svint64_t: __builtin_sve_svst1b_scatter_s64offset_s64,\
      svuint32_t: __builtin_sve_svst1b_scatter_u32offset_s32,\
      svuint64_t: __builtin_sve_svst1b_scatter_u64offset_s64),\
    int8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_scatter_s32offset_s32,\
      svint64_t: __builtin_sve_svst1b_scatter_s64offset_s64,\
      svuint32_t: __builtin_sve_svst1b_scatter_u32offset_s32,\
      svuint64_t: __builtin_sve_svst1b_scatter_u64offset_s64),\
    svuint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1b_scatter_u32base_offset_s32,\
        svuint32_t: __builtin_sve_svst1b_scatter_u32base_offset_u32),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1b_scatter_u64base_offset_s64,\
        svuint64_t: __builtin_sve_svst1b_scatter_u64base_offset_u64),\
    uint8_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_scatter_s32offset_u32,\
      svint64_t: __builtin_sve_svst1b_scatter_s64offset_u64,\
      svuint32_t: __builtin_sve_svst1b_scatter_u32offset_u32,\
      svuint64_t: __builtin_sve_svst1b_scatter_u64offset_u64),\
    uint8_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1b_scatter_s32offset_u32,\
      svint64_t: __builtin_sve_svst1b_scatter_s64offset_u64,\
      svuint32_t: __builtin_sve_svst1b_scatter_u32offset_u32,\
      svuint64_t: __builtin_sve_svst1b_scatter_u64offset_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1b_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svst1b_vnum_s16,\
        svint32_t: __builtin_sve_svst1b_vnum_s32,\
        svint64_t: __builtin_sve_svst1b_vnum_s64),\
    int8_t const *: \
    _Generic((__p3),\
        default: __builtin_sve_svst1b_vnum_s16,\
        svint32_t: __builtin_sve_svst1b_vnum_s32,\
        svint64_t: __builtin_sve_svst1b_vnum_s64),\
    uint8_t *: \
    _Generic((__p3),\
        default: __builtin_sve_svst1b_vnum_u16,\
        svuint32_t: __builtin_sve_svst1b_vnum_u32,\
        svuint64_t: __builtin_sve_svst1b_vnum_u64),\
    uint8_t const *: \
    _Generic((__p3),\
        default: __builtin_sve_svst1b_vnum_u16,\
        svuint32_t: __builtin_sve_svst1b_vnum_u32,\
        svuint64_t: __builtin_sve_svst1b_vnum_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_s32,\
      svint64_t: __builtin_sve_svst1h_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_s32,\
      svint64_t: __builtin_sve_svst1h_s64),\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_u32,\
      svuint64_t: __builtin_sve_svst1h_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_u32,\
      svuint64_t: __builtin_sve_svst1h_u64))(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_index(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32index_s32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64index_s64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32index_s32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64index_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32index_s32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64index_s64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32index_s32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64index_s64),\
    svuint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_scatter_u32base_index_s32,\
        svuint32_t: __builtin_sve_svst1h_scatter_u32base_index_u32),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_scatter_u64base_index_s64,\
        svuint64_t: __builtin_sve_svst1h_scatter_u64base_index_u64),\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32index_u32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64index_u64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32index_u32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64index_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32index_u32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64index_u64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32index_u32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64index_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio void svst1h_scatter(svbool_t __p0, svuint32_t __p1, svint32_t __p2) {
  svst1h_scatter_u32base_s32( __p0,  __p1,  __p2);
}
__aio void svst1h_scatter(svbool_t __p0, svuint32_t __p1, svuint32_t __p2) {
  svst1h_scatter_u32base_u32( __p0,  __p1,  __p2);
}
__aio void svst1h_scatter(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  svst1h_scatter_u64base_s64( __p0,  __p1,  __p2);
}
__aio void svst1h_scatter(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svst1h_scatter_u64base_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_scatter_offset(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32offset_s32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64offset_s64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32offset_s32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64offset_s64),\
    int16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32offset_s32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64offset_s64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32offset_s32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64offset_s64),\
    svuint32_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_scatter_u32base_offset_s32,\
        svuint32_t: __builtin_sve_svst1h_scatter_u32base_offset_u32),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_scatter_u64base_offset_s64,\
        svuint64_t: __builtin_sve_svst1h_scatter_u64base_offset_u64),\
    uint16_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32offset_u32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64offset_u64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32offset_u32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64offset_u64),\
    uint16_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1h_scatter_s32offset_u32,\
      svint64_t: __builtin_sve_svst1h_scatter_s64offset_u64,\
      svuint32_t: __builtin_sve_svst1h_scatter_u32offset_u32,\
      svuint64_t: __builtin_sve_svst1h_scatter_u64offset_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1h_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_vnum_s32,\
        svint64_t: __builtin_sve_svst1h_vnum_s64),\
    int16_t const *: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_vnum_s32,\
        svint64_t: __builtin_sve_svst1h_vnum_s64),\
    uint16_t *: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_vnum_u32,\
        svuint64_t: __builtin_sve_svst1h_vnum_u64),\
    uint16_t const *: \
    _Generic((__p3),\
        default: __builtin_sve_svst1h_vnum_u32,\
        svuint64_t: __builtin_sve_svst1h_vnum_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svst1w_s64,\
    int32_t const *: __builtin_sve_svst1w_s64,\
    uint32_t *: __builtin_sve_svst1w_u64,\
    uint32_t const *: __builtin_sve_svst1w_u64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_index(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64index_s64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64index_s64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64index_s64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64index_s64),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1w_scatter_u64base_index_s64,\
        svuint64_t: __builtin_sve_svst1w_scatter_u64base_index_u64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64index_u64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64index_u64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64index_u64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64index_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio void svst1w_scatter(svbool_t __p0, svuint64_t __p1, svint64_t __p2) {
  svst1w_scatter_u64base_s64( __p0,  __p1,  __p2);
}
__aio void svst1w_scatter(svbool_t __p0, svuint64_t __p1, svuint64_t __p2) {
  svst1w_scatter_u64base_u64( __p0,  __p1,  __p2);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_scatter_offset(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64offset_s64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64offset_s64),\
    int32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64offset_s64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64offset_s64),\
    svuint64_t: \
    _Generic((__p3),\
        default: __builtin_sve_svst1w_scatter_u64base_offset_s64,\
        svuint64_t: __builtin_sve_svst1w_scatter_u64base_offset_u64),\
    uint32_t *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64offset_u64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64offset_u64),\
    uint32_t const *: \
    _Generic((__p2),\
      default: __builtin_sve_svst1w_scatter_s64offset_u64,\
      svuint64_t: __builtin_sve_svst1w_scatter_u64offset_u64))(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst1w_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svst1w_vnum_s64,\
    int32_t const *: __builtin_sve_svst1w_vnum_s64,\
    uint32_t *: __builtin_sve_svst1w_vnum_u64,\
    uint32_t const *: __builtin_sve_svst1w_vnum_u64)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2(__p0, __p1, __p2)  \
__extension__({ \
  /* __p2 used more than once */ \
  __typeof(__p2) __tmp__p2 = __p2; \
  _Generic((__p1),\
    default: __builtin_sve_svst2_f16,\
    float16_t const *: __builtin_sve_svst2_f16,\
    float32_t *: __builtin_sve_svst2_f32,\
    float32_t const *: __builtin_sve_svst2_f32,\
    float64_t *: __builtin_sve_svst2_f64,\
    float64_t const *: __builtin_sve_svst2_f64,\
    int16_t *: __builtin_sve_svst2_s16,\
    int16_t const *: __builtin_sve_svst2_s16,\
    int32_t *: __builtin_sve_svst2_s32,\
    int32_t const *: __builtin_sve_svst2_s32,\
    int64_t *: __builtin_sve_svst2_s64,\
    int64_t const *: __builtin_sve_svst2_s64,\
    int8_t *: __builtin_sve_svst2_s8,\
    int8_t const *: __builtin_sve_svst2_s8,\
    uint16_t *: __builtin_sve_svst2_u16,\
    uint16_t const *: __builtin_sve_svst2_u16,\
    uint32_t *: __builtin_sve_svst2_u32,\
    uint32_t const *: __builtin_sve_svst2_u32,\
    uint64_t *: __builtin_sve_svst2_u64,\
    uint64_t const *: __builtin_sve_svst2_u64,\
    uint8_t *: __builtin_sve_svst2_u8,\
    uint8_t const *: __builtin_sve_svst2_u8)(__p0, __p1, __tmp__p2.v0, __tmp__p2.v1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst2_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  /* __p3 used more than once */ \
  __typeof(__p3) __tmp__p3 = __p3; \
  _Generic((__p1),\
    default: __builtin_sve_svst2_vnum_f16,\
    float16_t const *: __builtin_sve_svst2_vnum_f16,\
    float32_t *: __builtin_sve_svst2_vnum_f32,\
    float32_t const *: __builtin_sve_svst2_vnum_f32,\
    float64_t *: __builtin_sve_svst2_vnum_f64,\
    float64_t const *: __builtin_sve_svst2_vnum_f64,\
    int16_t *: __builtin_sve_svst2_vnum_s16,\
    int16_t const *: __builtin_sve_svst2_vnum_s16,\
    int32_t *: __builtin_sve_svst2_vnum_s32,\
    int32_t const *: __builtin_sve_svst2_vnum_s32,\
    int64_t *: __builtin_sve_svst2_vnum_s64,\
    int64_t const *: __builtin_sve_svst2_vnum_s64,\
    int8_t *: __builtin_sve_svst2_vnum_s8,\
    int8_t const *: __builtin_sve_svst2_vnum_s8,\
    uint16_t *: __builtin_sve_svst2_vnum_u16,\
    uint16_t const *: __builtin_sve_svst2_vnum_u16,\
    uint32_t *: __builtin_sve_svst2_vnum_u32,\
    uint32_t const *: __builtin_sve_svst2_vnum_u32,\
    uint64_t *: __builtin_sve_svst2_vnum_u64,\
    uint64_t const *: __builtin_sve_svst2_vnum_u64,\
    uint8_t *: __builtin_sve_svst2_vnum_u8,\
    uint8_t const *: __builtin_sve_svst2_vnum_u8)(__p0, __p1, __p2, __tmp__p3.v0, __tmp__p3.v1); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3(__p0, __p1, __p2)  \
__extension__({ \
  /* __p2 used more than once */ \
  __typeof(__p2) __tmp__p2 = __p2; \
  _Generic((__p1),\
    default: __builtin_sve_svst3_f16,\
    float16_t const *: __builtin_sve_svst3_f16,\
    float32_t *: __builtin_sve_svst3_f32,\
    float32_t const *: __builtin_sve_svst3_f32,\
    float64_t *: __builtin_sve_svst3_f64,\
    float64_t const *: __builtin_sve_svst3_f64,\
    int16_t *: __builtin_sve_svst3_s16,\
    int16_t const *: __builtin_sve_svst3_s16,\
    int32_t *: __builtin_sve_svst3_s32,\
    int32_t const *: __builtin_sve_svst3_s32,\
    int64_t *: __builtin_sve_svst3_s64,\
    int64_t const *: __builtin_sve_svst3_s64,\
    int8_t *: __builtin_sve_svst3_s8,\
    int8_t const *: __builtin_sve_svst3_s8,\
    uint16_t *: __builtin_sve_svst3_u16,\
    uint16_t const *: __builtin_sve_svst3_u16,\
    uint32_t *: __builtin_sve_svst3_u32,\
    uint32_t const *: __builtin_sve_svst3_u32,\
    uint64_t *: __builtin_sve_svst3_u64,\
    uint64_t const *: __builtin_sve_svst3_u64,\
    uint8_t *: __builtin_sve_svst3_u8,\
    uint8_t const *: __builtin_sve_svst3_u8)(__p0, __p1, __tmp__p2.v0, __tmp__p2.v1, __tmp__p2.v2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst3_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  /* __p3 used more than once */ \
  __typeof(__p3) __tmp__p3 = __p3; \
  _Generic((__p1),\
    default: __builtin_sve_svst3_vnum_f16,\
    float16_t const *: __builtin_sve_svst3_vnum_f16,\
    float32_t *: __builtin_sve_svst3_vnum_f32,\
    float32_t const *: __builtin_sve_svst3_vnum_f32,\
    float64_t *: __builtin_sve_svst3_vnum_f64,\
    float64_t const *: __builtin_sve_svst3_vnum_f64,\
    int16_t *: __builtin_sve_svst3_vnum_s16,\
    int16_t const *: __builtin_sve_svst3_vnum_s16,\
    int32_t *: __builtin_sve_svst3_vnum_s32,\
    int32_t const *: __builtin_sve_svst3_vnum_s32,\
    int64_t *: __builtin_sve_svst3_vnum_s64,\
    int64_t const *: __builtin_sve_svst3_vnum_s64,\
    int8_t *: __builtin_sve_svst3_vnum_s8,\
    int8_t const *: __builtin_sve_svst3_vnum_s8,\
    uint16_t *: __builtin_sve_svst3_vnum_u16,\
    uint16_t const *: __builtin_sve_svst3_vnum_u16,\
    uint32_t *: __builtin_sve_svst3_vnum_u32,\
    uint32_t const *: __builtin_sve_svst3_vnum_u32,\
    uint64_t *: __builtin_sve_svst3_vnum_u64,\
    uint64_t const *: __builtin_sve_svst3_vnum_u64,\
    uint8_t *: __builtin_sve_svst3_vnum_u8,\
    uint8_t const *: __builtin_sve_svst3_vnum_u8)(__p0, __p1, __p2, __tmp__p3.v0, __tmp__p3.v1, __tmp__p3.v2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4(__p0, __p1, __p2)  \
__extension__({ \
  /* __p2 used more than once */ \
  __typeof(__p2) __tmp__p2 = __p2; \
  _Generic((__p1),\
    default: __builtin_sve_svst4_f16,\
    float16_t const *: __builtin_sve_svst4_f16,\
    float32_t *: __builtin_sve_svst4_f32,\
    float32_t const *: __builtin_sve_svst4_f32,\
    float64_t *: __builtin_sve_svst4_f64,\
    float64_t const *: __builtin_sve_svst4_f64,\
    int16_t *: __builtin_sve_svst4_s16,\
    int16_t const *: __builtin_sve_svst4_s16,\
    int32_t *: __builtin_sve_svst4_s32,\
    int32_t const *: __builtin_sve_svst4_s32,\
    int64_t *: __builtin_sve_svst4_s64,\
    int64_t const *: __builtin_sve_svst4_s64,\
    int8_t *: __builtin_sve_svst4_s8,\
    int8_t const *: __builtin_sve_svst4_s8,\
    uint16_t *: __builtin_sve_svst4_u16,\
    uint16_t const *: __builtin_sve_svst4_u16,\
    uint32_t *: __builtin_sve_svst4_u32,\
    uint32_t const *: __builtin_sve_svst4_u32,\
    uint64_t *: __builtin_sve_svst4_u64,\
    uint64_t const *: __builtin_sve_svst4_u64,\
    uint8_t *: __builtin_sve_svst4_u8,\
    uint8_t const *: __builtin_sve_svst4_u8)(__p0, __p1, __tmp__p2.v0, __tmp__p2.v1, __tmp__p2.v2, __tmp__p2.v3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svst4_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  /* __p3 used more than once */ \
  __typeof(__p3) __tmp__p3 = __p3; \
  _Generic((__p1),\
    default: __builtin_sve_svst4_vnum_f16,\
    float16_t const *: __builtin_sve_svst4_vnum_f16,\
    float32_t *: __builtin_sve_svst4_vnum_f32,\
    float32_t const *: __builtin_sve_svst4_vnum_f32,\
    float64_t *: __builtin_sve_svst4_vnum_f64,\
    float64_t const *: __builtin_sve_svst4_vnum_f64,\
    int16_t *: __builtin_sve_svst4_vnum_s16,\
    int16_t const *: __builtin_sve_svst4_vnum_s16,\
    int32_t *: __builtin_sve_svst4_vnum_s32,\
    int32_t const *: __builtin_sve_svst4_vnum_s32,\
    int64_t *: __builtin_sve_svst4_vnum_s64,\
    int64_t const *: __builtin_sve_svst4_vnum_s64,\
    int8_t *: __builtin_sve_svst4_vnum_s8,\
    int8_t const *: __builtin_sve_svst4_vnum_s8,\
    uint16_t *: __builtin_sve_svst4_vnum_u16,\
    uint16_t const *: __builtin_sve_svst4_vnum_u16,\
    uint32_t *: __builtin_sve_svst4_vnum_u32,\
    uint32_t const *: __builtin_sve_svst4_vnum_u32,\
    uint64_t *: __builtin_sve_svst4_vnum_u64,\
    uint64_t const *: __builtin_sve_svst4_vnum_u64,\
    uint8_t *: __builtin_sve_svst4_vnum_u8,\
    uint8_t const *: __builtin_sve_svst4_vnum_u8)(__p0, __p1, __p2, __tmp__p3.v0, __tmp__p3.v1, __tmp__p3.v2, __tmp__p3.v3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svstnt1_f16,\
    float16_t const *: __builtin_sve_svstnt1_f16,\
    float32_t *: __builtin_sve_svstnt1_f32,\
    float32_t const *: __builtin_sve_svstnt1_f32,\
    float64_t *: __builtin_sve_svstnt1_f64,\
    float64_t const *: __builtin_sve_svstnt1_f64,\
    int16_t *: __builtin_sve_svstnt1_s16,\
    int16_t const *: __builtin_sve_svstnt1_s16,\
    int32_t *: __builtin_sve_svstnt1_s32,\
    int32_t const *: __builtin_sve_svstnt1_s32,\
    int64_t *: __builtin_sve_svstnt1_s64,\
    int64_t const *: __builtin_sve_svstnt1_s64,\
    int8_t *: __builtin_sve_svstnt1_s8,\
    int8_t const *: __builtin_sve_svstnt1_s8,\
    uint16_t *: __builtin_sve_svstnt1_u16,\
    uint16_t const *: __builtin_sve_svstnt1_u16,\
    uint32_t *: __builtin_sve_svstnt1_u32,\
    uint32_t const *: __builtin_sve_svstnt1_u32,\
    uint64_t *: __builtin_sve_svstnt1_u64,\
    uint64_t const *: __builtin_sve_svstnt1_u64,\
    uint8_t *: __builtin_sve_svstnt1_u8,\
    uint8_t const *: __builtin_sve_svstnt1_u8)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svstnt1_vnum(__p0, __p1, __p2, __p3)  \
__extension__({ \
  _Generic((__p1),\
    default: __builtin_sve_svstnt1_vnum_f16,\
    float16_t const *: __builtin_sve_svstnt1_vnum_f16,\
    float32_t *: __builtin_sve_svstnt1_vnum_f32,\
    float32_t const *: __builtin_sve_svstnt1_vnum_f32,\
    float64_t *: __builtin_sve_svstnt1_vnum_f64,\
    float64_t const *: __builtin_sve_svstnt1_vnum_f64,\
    int16_t *: __builtin_sve_svstnt1_vnum_s16,\
    int16_t const *: __builtin_sve_svstnt1_vnum_s16,\
    int32_t *: __builtin_sve_svstnt1_vnum_s32,\
    int32_t const *: __builtin_sve_svstnt1_vnum_s32,\
    int64_t *: __builtin_sve_svstnt1_vnum_s64,\
    int64_t const *: __builtin_sve_svstnt1_vnum_s64,\
    int8_t *: __builtin_sve_svstnt1_vnum_s8,\
    int8_t const *: __builtin_sve_svstnt1_vnum_s8,\
    uint16_t *: __builtin_sve_svstnt1_vnum_u16,\
    uint16_t const *: __builtin_sve_svstnt1_vnum_u16,\
    uint32_t *: __builtin_sve_svstnt1_vnum_u32,\
    uint32_t const *: __builtin_sve_svstnt1_vnum_u32,\
    uint64_t *: __builtin_sve_svstnt1_vnum_u64,\
    uint64_t const *: __builtin_sve_svstnt1_vnum_u64,\
    uint8_t *: __builtin_sve_svstnt1_vnum_u8,\
    uint8_t const *: __builtin_sve_svstnt1_vnum_u8)(__p0, __p1, __p2, __p3); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsub_x(__p0, __p1, __p2)  \
__extension__({ \
  svsub_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsub_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svsub_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsub_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_f16,\
      svfloat16_t: __builtin_sve_svsub_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_f32,\
      svfloat32_t: __builtin_sve_svsub_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_f64,\
      svfloat64_t: __builtin_sve_svsub_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_s16,\
      svint16_t: __builtin_sve_svsub_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_s32,\
      svint32_t: __builtin_sve_svsub_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_s64,\
      svint64_t: __builtin_sve_svsub_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsub_s8,\
      svint8_t: __builtin_sve_svsub_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svsub_u16,\
      default: __builtin_sve_svsub_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svsub_u32,\
      default: __builtin_sve_svsub_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svsub_u64,\
      default: __builtin_sve_svsub_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svsub_u8,\
      default: __builtin_sve_svsub_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsubr_x(__p0, __p1, __p2)  \
__extension__({ \
  svsubr_m(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsubr_z(__p0, __p1, __p2)  \
__extension__({ \
  svbool_t __s0 = __p0; /* __p0 used more than once */ \
  svsubr_m(__s0, __svsel(__s0, __p1, __svzero(__p1)), __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svsubr_m(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p1),\
    default: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_f16,\
      svfloat16_t: __builtin_sve_svsubr_f16),\
    svfloat32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_f32,\
      svfloat32_t: __builtin_sve_svsubr_f32),\
    svfloat64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_f64,\
      svfloat64_t: __builtin_sve_svsubr_f64),\
    svint16_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_s16,\
      svint16_t: __builtin_sve_svsubr_s16),\
    svint32_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_s32,\
      svint32_t: __builtin_sve_svsubr_s32),\
    svint64_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_s64,\
      svint64_t: __builtin_sve_svsubr_s64),\
    svint8_t: \
    _Generic((__p2),\
      default: __builtin_sve_svsubr_s8,\
      svint8_t: __builtin_sve_svsubr_s8),\
    svuint16_t: \
    _Generic((__p2),\
      svuint16_t: __builtin_sve_svsubr_u16,\
      default: __builtin_sve_svsubr_u16),\
    svuint32_t: \
    _Generic((__p2),\
      svuint32_t: __builtin_sve_svsubr_u32,\
      default: __builtin_sve_svsubr_u32),\
    svuint64_t: \
    _Generic((__p2),\
      svuint64_t: __builtin_sve_svsubr_u64,\
      default: __builtin_sve_svsubr_u64),\
    svuint8_t: \
    _Generic((__p2),\
      svuint8_t: __builtin_sve_svsubr_u8,\
      default: __builtin_sve_svsubr_u8))(__p0, __p1, __svdup(__p1, __p2)); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svtbl(svfloat16_t __p0, svuint16_t __p1) {
  return svtbl_f16( __p0,  __p1);
}
__aio svfloat32_t svtbl(svfloat32_t __p0, svuint32_t __p1) {
  return svtbl_f32( __p0,  __p1);
}
__aio svfloat64_t svtbl(svfloat64_t __p0, svuint64_t __p1) {
  return svtbl_f64( __p0,  __p1);
}
__aio svint16_t svtbl(svint16_t __p0, svuint16_t __p1) {
  return svtbl_s16( __p0,  __p1);
}
__aio svint32_t svtbl(svint32_t __p0, svuint32_t __p1) {
  return svtbl_s32( __p0,  __p1);
}
__aio svint64_t svtbl(svint64_t __p0, svuint64_t __p1) {
  return svtbl_s64( __p0,  __p1);
}
__aio svint8_t svtbl(svint8_t __p0, svuint8_t __p1) {
  return svtbl_s8( __p0,  __p1);
}
__aio svuint16_t svtbl(svuint16_t __p0, svuint16_t __p1) {
  return svtbl_u16( __p0,  __p1);
}
__aio svuint32_t svtbl(svuint32_t __p0, svuint32_t __p1) {
  return svtbl_u32( __p0,  __p1);
}
__aio svuint64_t svtbl(svuint64_t __p0, svuint64_t __p1) {
  return svtbl_u64( __p0,  __p1);
}
__aio svuint8_t svtbl(svuint8_t __p0, svuint8_t __p1) {
  return svtbl_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
#define svtmad(__p0, __p1, __p2)  \
__extension__({ \
  _Generic((__p0),\
  default: __builtin_sve_svtmad_f16,\
  svfloat32_t: __builtin_sve_svtmad_f32,\
  svfloat64_t: __builtin_sve_svtmad_f64)(__p0, __p1, __p2); \
})

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svtrn1(svfloat16_t __p0, svfloat16_t __p1) {
  return svtrn1_f16( __p0,  __p1);
}
__aio svfloat32_t svtrn1(svfloat32_t __p0, svfloat32_t __p1) {
  return svtrn1_f32( __p0,  __p1);
}
__aio svfloat64_t svtrn1(svfloat64_t __p0, svfloat64_t __p1) {
  return svtrn1_f64( __p0,  __p1);
}
__aio svint16_t svtrn1(svint16_t __p0, svint16_t __p1) {
  return svtrn1_s16( __p0,  __p1);
}
__aio svint32_t svtrn1(svint32_t __p0, svint32_t __p1) {
  return svtrn1_s32( __p0,  __p1);
}
__aio svint64_t svtrn1(svint64_t __p0, svint64_t __p1) {
  return svtrn1_s64( __p0,  __p1);
}
__aio svint8_t svtrn1(svint8_t __p0, svint8_t __p1) {
  return svtrn1_s8( __p0,  __p1);
}
__aio svuint16_t svtrn1(svuint16_t __p0, svuint16_t __p1) {
  return svtrn1_u16( __p0,  __p1);
}
__aio svuint32_t svtrn1(svuint32_t __p0, svuint32_t __p1) {
  return svtrn1_u32( __p0,  __p1);
}
__aio svuint64_t svtrn1(svuint64_t __p0, svuint64_t __p1) {
  return svtrn1_u64( __p0,  __p1);
}
__aio svuint8_t svtrn1(svuint8_t __p0, svuint8_t __p1) {
  return svtrn1_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svtrn2(svfloat16_t __p0, svfloat16_t __p1) {
  return svtrn2_f16( __p0,  __p1);
}
__aio svfloat32_t svtrn2(svfloat32_t __p0, svfloat32_t __p1) {
  return svtrn2_f32( __p0,  __p1);
}
__aio svfloat64_t svtrn2(svfloat64_t __p0, svfloat64_t __p1) {
  return svtrn2_f64( __p0,  __p1);
}
__aio svint16_t svtrn2(svint16_t __p0, svint16_t __p1) {
  return svtrn2_s16( __p0,  __p1);
}
__aio svint32_t svtrn2(svint32_t __p0, svint32_t __p1) {
  return svtrn2_s32( __p0,  __p1);
}
__aio svint64_t svtrn2(svint64_t __p0, svint64_t __p1) {
  return svtrn2_s64( __p0,  __p1);
}
__aio svint8_t svtrn2(svint8_t __p0, svint8_t __p1) {
  return svtrn2_s8( __p0,  __p1);
}
__aio svuint16_t svtrn2(svuint16_t __p0, svuint16_t __p1) {
  return svtrn2_u16( __p0,  __p1);
}
__aio svuint32_t svtrn2(svuint32_t __p0, svuint32_t __p1) {
  return svtrn2_u32( __p0,  __p1);
}
__aio svuint64_t svtrn2(svuint64_t __p0, svuint64_t __p1) {
  return svtrn2_u64( __p0,  __p1);
}
__aio svuint8_t svtrn2(svuint8_t __p0, svuint8_t __p1) {
  return svtrn2_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svtsmul(svfloat16_t __p0, svuint16_t __p1) {
  return svtsmul_f16( __p0,  __p1);
}
__aio svfloat32_t svtsmul(svfloat32_t __p0, svuint32_t __p1) {
  return svtsmul_f32( __p0,  __p1);
}
__aio svfloat64_t svtsmul(svfloat64_t __p0, svuint64_t __p1) {
  return svtsmul_f64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svtssel(svfloat16_t __p0, svuint16_t __p1) {
  return svtssel_f16( __p0,  __p1);
}
__aio svfloat32_t svtssel(svfloat32_t __p0, svuint32_t __p1) {
  return svtssel_f32( __p0,  __p1);
}
__aio svfloat64_t svtssel(svfloat64_t __p0, svuint64_t __p1) {
  return svtssel_f64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svunpkhi(svbool_t __p0) {
  return svunpkhi_b( __p0);
}
__aio svint32_t svunpkhi(svint16_t __p0) {
  return svunpkhi_s32( __p0);
}
__aio svint64_t svunpkhi(svint32_t __p0) {
  return svunpkhi_s64( __p0);
}
__aio svint16_t svunpkhi(svint8_t __p0) {
  return svunpkhi_s16( __p0);
}
__aio svuint32_t svunpkhi(svuint16_t __p0) {
  return svunpkhi_u32( __p0);
}
__aio svuint64_t svunpkhi(svuint32_t __p0) {
  return svunpkhi_u64( __p0);
}
__aio svuint16_t svunpkhi(svuint8_t __p0) {
  return svunpkhi_u16( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svunpklo(svbool_t __p0) {
  return svunpklo_b( __p0);
}
__aio svint32_t svunpklo(svint16_t __p0) {
  return svunpklo_s32( __p0);
}
__aio svint64_t svunpklo(svint32_t __p0) {
  return svunpklo_s64( __p0);
}
__aio svint16_t svunpklo(svint8_t __p0) {
  return svunpklo_s16( __p0);
}
__aio svuint32_t svunpklo(svuint16_t __p0) {
  return svunpklo_u32( __p0);
}
__aio svuint64_t svunpklo(svuint32_t __p0) {
  return svunpklo_u64( __p0);
}
__aio svuint16_t svunpklo(svuint8_t __p0) {
  return svunpklo_u16( __p0);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svuzp1(svfloat16_t __p0, svfloat16_t __p1) {
  return svuzp1_f16( __p0,  __p1);
}
__aio svfloat32_t svuzp1(svfloat32_t __p0, svfloat32_t __p1) {
  return svuzp1_f32( __p0,  __p1);
}
__aio svfloat64_t svuzp1(svfloat64_t __p0, svfloat64_t __p1) {
  return svuzp1_f64( __p0,  __p1);
}
__aio svint16_t svuzp1(svint16_t __p0, svint16_t __p1) {
  return svuzp1_s16( __p0,  __p1);
}
__aio svint32_t svuzp1(svint32_t __p0, svint32_t __p1) {
  return svuzp1_s32( __p0,  __p1);
}
__aio svint64_t svuzp1(svint64_t __p0, svint64_t __p1) {
  return svuzp1_s64( __p0,  __p1);
}
__aio svint8_t svuzp1(svint8_t __p0, svint8_t __p1) {
  return svuzp1_s8( __p0,  __p1);
}
__aio svuint16_t svuzp1(svuint16_t __p0, svuint16_t __p1) {
  return svuzp1_u16( __p0,  __p1);
}
__aio svuint32_t svuzp1(svuint32_t __p0, svuint32_t __p1) {
  return svuzp1_u32( __p0,  __p1);
}
__aio svuint64_t svuzp1(svuint64_t __p0, svuint64_t __p1) {
  return svuzp1_u64( __p0,  __p1);
}
__aio svuint8_t svuzp1(svuint8_t __p0, svuint8_t __p1) {
  return svuzp1_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svuzp2(svfloat16_t __p0, svfloat16_t __p1) {
  return svuzp2_f16( __p0,  __p1);
}
__aio svfloat32_t svuzp2(svfloat32_t __p0, svfloat32_t __p1) {
  return svuzp2_f32( __p0,  __p1);
}
__aio svfloat64_t svuzp2(svfloat64_t __p0, svfloat64_t __p1) {
  return svuzp2_f64( __p0,  __p1);
}
__aio svint16_t svuzp2(svint16_t __p0, svint16_t __p1) {
  return svuzp2_s16( __p0,  __p1);
}
__aio svint32_t svuzp2(svint32_t __p0, svint32_t __p1) {
  return svuzp2_s32( __p0,  __p1);
}
__aio svint64_t svuzp2(svint64_t __p0, svint64_t __p1) {
  return svuzp2_s64( __p0,  __p1);
}
__aio svint8_t svuzp2(svint8_t __p0, svint8_t __p1) {
  return svuzp2_s8( __p0,  __p1);
}
__aio svuint16_t svuzp2(svuint16_t __p0, svuint16_t __p1) {
  return svuzp2_u16( __p0,  __p1);
}
__aio svuint32_t svuzp2(svuint32_t __p0, svuint32_t __p1) {
  return svuzp2_u32( __p0,  __p1);
}
__aio svuint64_t svuzp2(svuint64_t __p0, svuint64_t __p1) {
  return svuzp2_u64( __p0,  __p1);
}
__aio svuint8_t svuzp2(svuint8_t __p0, svuint8_t __p1) {
  return svuzp2_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilele_b8(int32_t __p0, int32_t __p1) {
  return svwhilele_b8_s32( __p0,  __p1);
}
__aio svbool_t svwhilele_b8(int64_t __p0, int64_t __p1) {
  return svwhilele_b8_s64( __p0,  __p1);
}
__aio svbool_t svwhilele_b8(uint32_t __p0, uint32_t __p1) {
  return svwhilele_b8_u32( __p0,  __p1);
}
__aio svbool_t svwhilele_b8(uint64_t __p0, uint64_t __p1) {
  return svwhilele_b8_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilele_b32(int32_t __p0, int32_t __p1) {
  return svwhilele_b32_s32( __p0,  __p1);
}
__aio svbool_t svwhilele_b32(int64_t __p0, int64_t __p1) {
  return svwhilele_b32_s64( __p0,  __p1);
}
__aio svbool_t svwhilele_b32(uint32_t __p0, uint32_t __p1) {
  return svwhilele_b32_u32( __p0,  __p1);
}
__aio svbool_t svwhilele_b32(uint64_t __p0, uint64_t __p1) {
  return svwhilele_b32_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilele_b64(int32_t __p0, int32_t __p1) {
  return svwhilele_b64_s32( __p0,  __p1);
}
__aio svbool_t svwhilele_b64(int64_t __p0, int64_t __p1) {
  return svwhilele_b64_s64( __p0,  __p1);
}
__aio svbool_t svwhilele_b64(uint32_t __p0, uint32_t __p1) {
  return svwhilele_b64_u32( __p0,  __p1);
}
__aio svbool_t svwhilele_b64(uint64_t __p0, uint64_t __p1) {
  return svwhilele_b64_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilele_b16(int32_t __p0, int32_t __p1) {
  return svwhilele_b16_s32( __p0,  __p1);
}
__aio svbool_t svwhilele_b16(int64_t __p0, int64_t __p1) {
  return svwhilele_b16_s64( __p0,  __p1);
}
__aio svbool_t svwhilele_b16(uint32_t __p0, uint32_t __p1) {
  return svwhilele_b16_u32( __p0,  __p1);
}
__aio svbool_t svwhilele_b16(uint64_t __p0, uint64_t __p1) {
  return svwhilele_b16_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilelt_b8(int32_t __p0, int32_t __p1) {
  return svwhilelt_b8_s32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b8(int64_t __p0, int64_t __p1) {
  return svwhilelt_b8_s64( __p0,  __p1);
}
__aio svbool_t svwhilelt_b8(uint32_t __p0, uint32_t __p1) {
  return svwhilelt_b8_u32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b8(uint64_t __p0, uint64_t __p1) {
  return svwhilelt_b8_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilelt_b32(int32_t __p0, int32_t __p1) {
  return svwhilelt_b32_s32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b32(int64_t __p0, int64_t __p1) {
  return svwhilelt_b32_s64( __p0,  __p1);
}
__aio svbool_t svwhilelt_b32(uint32_t __p0, uint32_t __p1) {
  return svwhilelt_b32_u32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b32(uint64_t __p0, uint64_t __p1) {
  return svwhilelt_b32_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilelt_b64(int32_t __p0, int32_t __p1) {
  return svwhilelt_b64_s32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b64(int64_t __p0, int64_t __p1) {
  return svwhilelt_b64_s64( __p0,  __p1);
}
__aio svbool_t svwhilelt_b64(uint32_t __p0, uint32_t __p1) {
  return svwhilelt_b64_u32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b64(uint64_t __p0, uint64_t __p1) {
  return svwhilelt_b64_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svbool_t svwhilelt_b16(int32_t __p0, int32_t __p1) {
  return svwhilelt_b16_s32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b16(int64_t __p0, int64_t __p1) {
  return svwhilelt_b16_s64( __p0,  __p1);
}
__aio svbool_t svwhilelt_b16(uint32_t __p0, uint32_t __p1) {
  return svwhilelt_b16_u32( __p0,  __p1);
}
__aio svbool_t svwhilelt_b16(uint64_t __p0, uint64_t __p1) {
  return svwhilelt_b16_u64( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svzip1(svfloat16_t __p0, svfloat16_t __p1) {
  return svzip1_f16( __p0,  __p1);
}
__aio svfloat32_t svzip1(svfloat32_t __p0, svfloat32_t __p1) {
  return svzip1_f32( __p0,  __p1);
}
__aio svfloat64_t svzip1(svfloat64_t __p0, svfloat64_t __p1) {
  return svzip1_f64( __p0,  __p1);
}
__aio svint16_t svzip1(svint16_t __p0, svint16_t __p1) {
  return svzip1_s16( __p0,  __p1);
}
__aio svint32_t svzip1(svint32_t __p0, svint32_t __p1) {
  return svzip1_s32( __p0,  __p1);
}
__aio svint64_t svzip1(svint64_t __p0, svint64_t __p1) {
  return svzip1_s64( __p0,  __p1);
}
__aio svint8_t svzip1(svint8_t __p0, svint8_t __p1) {
  return svzip1_s8( __p0,  __p1);
}
__aio svuint16_t svzip1(svuint16_t __p0, svuint16_t __p1) {
  return svzip1_u16( __p0,  __p1);
}
__aio svuint32_t svzip1(svuint32_t __p0, svuint32_t __p1) {
  return svzip1_u32( __p0,  __p1);
}
__aio svuint64_t svzip1(svuint64_t __p0, svuint64_t __p1) {
  return svzip1_u64( __p0,  __p1);
}
__aio svuint8_t svzip1(svuint8_t __p0, svuint8_t __p1) {
  return svzip1_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#ifdef __LITTLE_ENDIAN__
__aio svfloat16_t svzip2(svfloat16_t __p0, svfloat16_t __p1) {
  return svzip2_f16( __p0,  __p1);
}
__aio svfloat32_t svzip2(svfloat32_t __p0, svfloat32_t __p1) {
  return svzip2_f32( __p0,  __p1);
}
__aio svfloat64_t svzip2(svfloat64_t __p0, svfloat64_t __p1) {
  return svzip2_f64( __p0,  __p1);
}
__aio svint16_t svzip2(svint16_t __p0, svint16_t __p1) {
  return svzip2_s16( __p0,  __p1);
}
__aio svint32_t svzip2(svint32_t __p0, svint32_t __p1) {
  return svzip2_s32( __p0,  __p1);
}
__aio svint64_t svzip2(svint64_t __p0, svint64_t __p1) {
  return svzip2_s64( __p0,  __p1);
}
__aio svint8_t svzip2(svint8_t __p0, svint8_t __p1) {
  return svzip2_s8( __p0,  __p1);
}
__aio svuint16_t svzip2(svuint16_t __p0, svuint16_t __p1) {
  return svzip2_u16( __p0,  __p1);
}
__aio svuint32_t svzip2(svuint32_t __p0, svuint32_t __p1) {
  return svzip2_u32( __p0,  __p1);
}
__aio svuint64_t svzip2(svuint64_t __p0, svuint64_t __p1) {
  return svzip2_u64( __p0,  __p1);
}
__aio svuint8_t svzip2(svuint8_t __p0, svuint8_t __p1) {
  return svzip2_u8( __p0,  __p1);
}

#else
#error BIG ENDIAN not supported yet
#endif

#define MAKE_DUP_B(BITS) \
__ai svbool_t svdup_b##BITS(bool op) {\
  return op ? svptrue_b##BITS() : svpfalse_b();\
}
MAKE_DUP_B(8)
MAKE_DUP_B(16)
MAKE_DUP_B(32)
MAKE_DUP_B(64)
#define svdup_n_b8  svdup_b8
#define svdup_n_b16 svdup_b16
#define svdup_n_b32 svdup_b32
#define svdup_n_b64 svdup_b64

#define MAKE_DUPQ_16(TYPE,SUFFIX,PTRUE) \
 __ai sv##TYPE svdupq_##SUFFIX(TYPE x0, TYPE x1,\
                               TYPE x2, TYPE x3,\
                               TYPE x4, TYPE x5,\
                               TYPE x6, TYPE x7,\
                               TYPE x8, TYPE x9,\
                               TYPE x10, TYPE x11,\
                               TYPE x12, TYPE x13,\
                               TYPE x14, TYPE x15) {\
  TYPE x[] = { x0, x1, x2, x3, x4, x5, x6, x7,\
               x8, x9, x10, x11, x12, x13, x14, x15 };\
  return svld1rq_##SUFFIX(PTRUE, x);\
}
MAKE_DUPQ_16(int8_t, s8, svptrue_b8())
MAKE_DUPQ_16(uint8_t, u8, svptrue_b8())
#define svdupq_n_s8 svdupq_s8
#define svdupq_n_u8 svdupq_u8

#define MAKE_DUPQ_8(TYPE,SUFFIX,PTRUE) \
 __ai sv##TYPE svdupq_##SUFFIX(TYPE x0, TYPE x1,\
                               TYPE x2, TYPE x3,\
                               TYPE x4, TYPE x5,\
                               TYPE x6, TYPE x7) {\
  TYPE x[] = { x0, x1, x2, x3, x4, x5, x6, x7 };\
  return svld1rq_##SUFFIX(PTRUE, x);\
}
MAKE_DUPQ_8(int16_t, s16, svptrue_b16())
MAKE_DUPQ_8(uint16_t, u16, svptrue_b16())
#define svdupq_n_s16 svdupq_s16
#define svdupq_n_u16 svdupq_u16

#define svdupq_f16(x0, x1, x2, x3, x4, x5, x6, x7) __extension__ ({\
  float16_t x[] = { (x0), (x1), (x2), (x3), (x4), (x5), (x6), (x7) };\
  svfloat16_t __ret = svld1rq_f16(svptrue_b16(), x);\
  __ret;\
})
#define svdupq_n_f16 svdupq_f16

#define MAKE_DUPQ_4(TYPE,SUFFIX,PTRUE) \
 __ai sv##TYPE svdupq_##SUFFIX(TYPE x0, TYPE x1,\
                               TYPE x2, TYPE x3) {\
  TYPE x[] = { x0, x1, x2, x3 };\
  return svld1rq_##SUFFIX(PTRUE, x);\
}
MAKE_DUPQ_4(int32_t, s32, svptrue_b32())
MAKE_DUPQ_4(uint32_t, u32, svptrue_b32())
MAKE_DUPQ_4(float32_t, f32, svptrue_b32())
#define svdupq_n_s32 svdupq_s32
#define svdupq_n_u32 svdupq_u32
#define svdupq_n_f32 svdupq_f32

#define MAKE_DUPQ_2(TYPE,SUFFIX,PTRUE) \
 __ai sv##TYPE svdupq_##SUFFIX(TYPE x0, TYPE x1) {\
  TYPE x[] = { x0, x1 };\
  return svld1rq_##SUFFIX(PTRUE, x);\
}
MAKE_DUPQ_2(int64_t, s64, svptrue_b64())
MAKE_DUPQ_2(uint64_t, u64, svptrue_b64())
MAKE_DUPQ_2(float64_t, f64, svptrue_b64())
#define svdupq_n_u64 svdupq_u64
#define svdupq_n_s64 svdupq_s64
#define svdupq_n_f64 svdupq_f64

__ai svbool_t svdupq_b8(bool x0,  bool x1,  bool x2,  bool x3,
                        bool x4,  bool x5,  bool x6,  bool x7,
                        bool x8,  bool x9,  bool x10, bool x11,
                        bool x12, bool x13, bool x14, bool x15) {
  svuint8_t x = svdupq_u8(x0, x1, x2,  x3,  x4,  x5,  x6,  x7,
                          x8, x9, x10, x11, x12, x13, x14, x15);
  return svcmpne(svptrue_b8(), x, 0);
}

__ai svbool_t svdupq_b16(bool x0, bool x1, bool x2, bool x3,
                         bool x4, bool x5, bool x6, bool x7) {
  svuint16_t x = svdupq_u16(x0, x1, x2, x3, x4, x5, x6, x7);
  return svcmpne(svptrue_b16(), x, 0);
}

__ai svbool_t svdupq_b32(bool x0, bool x1, bool x2, bool x3) {
  svuint32_t x = svdupq_u32(x0, x1, x2, x3);
  return svcmpne(svptrue_b32(), x, 0);
}

__ai svbool_t svdupq_b64(bool x0, bool x1) {
  svuint64_t x = svdupq_u64(x0, x1);
  return svcmpne(svptrue_b64(), x, 0);
}

#define svdupq_n_b8 svdupq_b8
#define svdupq_n_b16 svdupq_b16
#define svdupq_n_b32 svdupq_b32
#define svdupq_n_b64 svdupq_b64

#endif /* __ARM_SVE_H */
